<h1>esprima</h1>
<pre><code class="lang-js"><span class="comment">/*
  Copyright (C) 2012 Ariya Hidayat &lt;ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens &lt;mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn &lt;joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal &lt;kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki &lt;utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos &lt;arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat &lt;ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/</span>

<span class="comment">/*jslint bitwise:true plusplus:true */</span>
<span class="comment">/*global esprima:true, exports:true,
throwError: true, createLiteral: true, generateStatement: true,
parseAssignmentExpression: true, parseBlock: true, parseExpression: true,
parseFunctionDeclaration: true, parseFunctionExpression: true,
parseFunctionSourceElements: true, parseVariableIdentifier: true,
parseLeftHandSideExpression: true,
parseStatement: true, parseSourceElement: true */</span>

(<span class="function"><span class="keyword">function</span> <span class="params">(exports)</span> {</span>
    <span class="string">'use strict'</span>;

    <span class="keyword">var</span> Token,
        TokenName,
        Syntax,
        PropertyKind,
        Messages,
        Regex,
        source,
        allowIn,
        lastParenthesized,
        strict,
        index,
        lineNumber,
        lineStart,
        length,
        buffer,
        extra,
        labelSet,
        inIteration,
        inSwitch,
        inFunctionBody;

    Token = {
        BooleanLiteral: <span class="number">1</span>,
        EOF: <span class="number">2</span>,
        Identifier: <span class="number">3</span>,
        Keyword: <span class="number">4</span>,
        NullLiteral: <span class="number">5</span>,
        NumericLiteral: <span class="number">6</span>,
        Punctuator: <span class="number">7</span>,
        StringLiteral: <span class="number">8</span>
    };

    TokenName = {};
    TokenName[Token.BooleanLiteral] = <span class="string">'Boolean'</span>;
    TokenName[Token.EOF] = <span class="string">'&lt;end>'</span>;
    TokenName[Token.Identifier] = <span class="string">'Identifier'</span>;
    TokenName[Token.Keyword] = <span class="string">'Keyword'</span>;
    TokenName[Token.NullLiteral] = <span class="string">'Null'</span>;
    TokenName[Token.NumericLiteral] = <span class="string">'Numeric'</span>;
    TokenName[Token.Punctuator] = <span class="string">'Punctuator'</span>;
    TokenName[Token.StringLiteral] = <span class="string">'String'</span>;

    Syntax = {
        AssignmentExpression: <span class="string">'AssignmentExpression'</span>,
        ArrayExpression: <span class="string">'ArrayExpression'</span>,
        BlockStatement: <span class="string">'BlockStatement'</span>,
        BinaryExpression: <span class="string">'BinaryExpression'</span>,
        BreakStatement: <span class="string">'BreakStatement'</span>,
        CallExpression: <span class="string">'CallExpression'</span>,
        CatchClause: <span class="string">'CatchClause'</span>,
        ConditionalExpression: <span class="string">'ConditionalExpression'</span>,
        ContinueStatement: <span class="string">'ContinueStatement'</span>,
        DoWhileStatement: <span class="string">'DoWhileStatement'</span>,
        DebuggerStatement: <span class="string">'DebuggerStatement'</span>,
        EmptyStatement: <span class="string">'EmptyStatement'</span>,
        ExpressionStatement: <span class="string">'ExpressionStatement'</span>,
        ForStatement: <span class="string">'ForStatement'</span>,
        ForInStatement: <span class="string">'ForInStatement'</span>,
        FunctionDeclaration: <span class="string">'FunctionDeclaration'</span>,
        FunctionExpression: <span class="string">'FunctionExpression'</span>,
        Identifier: <span class="string">'Identifier'</span>,
        IfStatement: <span class="string">'IfStatement'</span>,
        Literal: <span class="string">'Literal'</span>,
        LabeledStatement: <span class="string">'LabeledStatement'</span>,
        LogicalExpression: <span class="string">'LogicalExpression'</span>,
        MemberExpression: <span class="string">'MemberExpression'</span>,
        NewExpression: <span class="string">'NewExpression'</span>,
        ObjectExpression: <span class="string">'ObjectExpression'</span>,
        Program: <span class="string">'Program'</span>,
        Property: <span class="string">'Property'</span>,
        ReturnStatement: <span class="string">'ReturnStatement'</span>,
        SequenceExpression: <span class="string">'SequenceExpression'</span>,
        SwitchStatement: <span class="string">'SwitchStatement'</span>,
        SwitchCase: <span class="string">'SwitchCase'</span>,
        ThisExpression: <span class="string">'ThisExpression'</span>,
        ThrowStatement: <span class="string">'ThrowStatement'</span>,
        TryStatement: <span class="string">'TryStatement'</span>,
        UnaryExpression: <span class="string">'UnaryExpression'</span>,
        UpdateExpression: <span class="string">'UpdateExpression'</span>,
        VariableDeclaration: <span class="string">'VariableDeclaration'</span>,
        VariableDeclarator: <span class="string">'VariableDeclarator'</span>,
        WhileStatement: <span class="string">'WhileStatement'</span>,
        WithStatement: <span class="string">'WithStatement'</span>
    };

    PropertyKind = {
        Data: <span class="number">1</span>,
        Get: <span class="number">2</span>,
        Set: <span class="number">4</span>
    };

    <span class="comment">// Error messages should be identical to V8.</span>
    Messages = {
        UnexpectedToken:  <span class="string">'Unexpected token %0'</span>,
        UnexpectedNumber:  <span class="string">'Unexpected number'</span>,
        UnexpectedString:  <span class="string">'Unexpected string'</span>,
        UnexpectedIdentifier:  <span class="string">'Unexpected identifier'</span>,
        UnexpectedReserved:  <span class="string">'Unexpected reserved word'</span>,
        UnexpectedEOS:  <span class="string">'Unexpected end of input'</span>,
        NewlineAfterThrow:  <span class="string">'Illegal newline after throw'</span>,
        InvalidRegExp: <span class="string">'Invalid regular expression'</span>,
        UnterminatedRegExp:  <span class="string">'Invalid regular expression: missing /'</span>,
        InvalidLHSInAssignment:  <span class="string">'Invalid left-hand side in assignment'</span>,
        InvalidLHSInForIn:  <span class="string">'Invalid left-hand side in for-in'</span>,
        NoCatchOrFinally:  <span class="string">'Missing catch or finally after try'</span>,
        UnknownLabel: <span class="string">'Undefined label \'%0\''</span>,
        Redeclaration: <span class="string">'%0 \'%1\' has already been declared'</span>,
        IllegalContinue: <span class="string">'Illegal continue statement'</span>,
        IllegalBreak: <span class="string">'Illegal break statement'</span>,
        IllegalReturn: <span class="string">'Illegal return statement'</span>,
        StrictModeWith:  <span class="string">'Strict mode code may not include a with statement'</span>,
        StrictCatchVariable:  <span class="string">'Catch variable may not be eval or arguments in strict mode'</span>,
        StrictVarName:  <span class="string">'Variable name may not be eval or arguments in strict mode'</span>,
        StrictParamName:  <span class="string">'Parameter name eval or arguments is not allowed in strict mode'</span>,
        StrictParamDupe: <span class="string">'Strict mode function may not have duplicate parameter names'</span>,
        StrictFunctionName:  <span class="string">'Function name may not be eval or arguments in strict mode'</span>,
        StrictOctalLiteral:  <span class="string">'Octal literals are not allowed in strict mode.'</span>,
        StrictDelete:  <span class="string">'Delete of an unqualified identifier in strict mode.'</span>,
        StrictDuplicateProperty:  <span class="string">'Duplicate data property in object literal not allowed in strict mode'</span>,
        AccessorDataProperty:  <span class="string">'Object literal may not have data and accessor property with the same name'</span>,
        AccessorGetSet:  <span class="string">'Object literal may not have multiple get/set accessors with the same name'</span>,
        StrictLHSAssignment:  <span class="string">'Assignment to eval or arguments is not allowed in strict mode'</span>,
        StrictLHSPostfix:  <span class="string">'Postfix increment/decrement may not have eval or arguments operand in strict mode'</span>,
        StrictLHSPrefix:  <span class="string">'Prefix increment/decrement may not have eval or arguments operand in strict mode'</span>,
        StrictReservedWord:  <span class="string">'Use of future reserved word in strict mode'</span>
    };

    <span class="comment">// See also tools/generate-unicode-regex.py.</span>
    Regex = {
        NonAsciiIdentifierStart: <span class="keyword">new</span> RegExp(<span class="string">'[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'</span>),
        NonAsciiIdentifierPart: <span class="keyword">new</span> RegExp(<span class="string">'[\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0\u08a2-\u08ac\u08e4-\u08fe\u0900-\u0963\u0966-\u096f\u0971-\u0977\u0979-\u097f\u0981-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d02\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191c\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1d00-\u1de6\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua697\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a\uaa7b\uaa80-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]'</span>)
    };

    <span class="comment">// Ensure the condition is true, otherwise throw an error.</span>
    <span class="comment">// This is only to have a better contract semantic, i.e. another safety net</span>
    <span class="comment">// to catch a logic error. The condition shall be fulfilled in normal case.</span>
    <span class="comment">// Do NOT use this to enforce a certain condition on any user input.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">assert</span><span class="params">(condition, message)</span> {</span>
        <span class="keyword">if</span> (!condition) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'ASSERT: '</span> + message);
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">sliceSource</span><span class="params">(from, to)</span> {</span>
        <span class="keyword">return</span> source.slice(from, to);
    }

    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="string">'esprima'</span>[<span class="number">0</span>] === <span class="string">'undefined'</span>) {
        sliceSource = <span class="function"><span class="keyword">function</span> <span class="title">sliceArraySource</span><span class="params">(from, to)</span> {</span>
            <span class="keyword">return</span> source.slice(from, to).join(<span class="string">''</span>);
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isDecimalDigit</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> <span class="string">'0123456789'</span>.indexOf(ch) >= <span class="number">0</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isHexDigit</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> <span class="string">'0123456789abcdefABCDEF'</span>.indexOf(ch) >= <span class="number">0</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isOctalDigit</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> <span class="string">'01234567'</span>.indexOf(ch) >= <span class="number">0</span>;
    }


    <span class="comment">// 7.2 White Space</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isWhiteSpace</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> (ch === <span class="string">' '</span>) || (ch === <span class="string">'\u0009'</span>) || (ch === <span class="string">'\u000B'</span>) ||
            (ch === <span class="string">'\u000C'</span>) || (ch === <span class="string">'\u00A0'</span>) ||
            (ch.charCodeAt(<span class="number">0</span>) >= <span class="number">0x1680</span> &amp;&amp;
             <span class="string">'\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\uFEFF'</span>.indexOf(ch) >= <span class="number">0</span>);
    }

    <span class="comment">// 7.3 Line Terminators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isLineTerminator</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> (ch === <span class="string">'\n'</span> || ch === <span class="string">'\r'</span> || ch === <span class="string">'\u2028'</span> || ch === <span class="string">'\u2029'</span>);
    }

    <span class="comment">// 7.6 Identifier Names and Identifiers</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierStart</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> (ch === <span class="string">'$'</span>) || (ch === <span class="string">'_'</span>) || (ch === <span class="string">'\\'</span>) ||
            (ch >= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch >= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) ||
            ((ch.charCodeAt(<span class="number">0</span>) >= <span class="number">0x80</span>) &amp;&amp; Regex.NonAsciiIdentifierStart.test(ch));
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierPart</span><span class="params">(ch)</span> {</span>
        <span class="keyword">return</span> (ch === <span class="string">'$'</span>) || (ch === <span class="string">'_'</span>) || (ch === <span class="string">'\\'</span>) ||
            (ch >= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch >= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>) ||
            ((ch >= <span class="string">'0'</span>) &amp;&amp; (ch &lt;= <span class="string">'9'</span>)) ||
            ((ch.charCodeAt(<span class="number">0</span>) >= <span class="number">0x80</span>) &amp;&amp; Regex.NonAsciiIdentifierPart.test(ch));
    }

    <span class="comment">// 7.6.1.2 Future Reserved Words</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isFutureReservedWord</span><span class="params">(id)</span> {</span>
        <span class="keyword">switch</span> (id) {

        <span class="comment">// Future reserved words.</span>
        <span class="keyword">case</span> <span class="string">'class'</span>:
        <span class="keyword">case</span> <span class="string">'enum'</span>:
        <span class="keyword">case</span> <span class="string">'export'</span>:
        <span class="keyword">case</span> <span class="string">'extends'</span>:
        <span class="keyword">case</span> <span class="string">'import'</span>:
        <span class="keyword">case</span> <span class="string">'super'</span>:
            <span class="keyword">return</span> <span class="literal">true</span>;
        }

        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isStrictModeReservedWord</span><span class="params">(id)</span> {</span>
        <span class="keyword">switch</span> (id) {

        <span class="comment">// Strict Mode reserved words.</span>
        <span class="keyword">case</span> <span class="string">'implements'</span>:
        <span class="keyword">case</span> <span class="string">'interface'</span>:
        <span class="keyword">case</span> <span class="string">'package'</span>:
        <span class="keyword">case</span> <span class="string">'private'</span>:
        <span class="keyword">case</span> <span class="string">'protected'</span>:
        <span class="keyword">case</span> <span class="string">'public'</span>:
        <span class="keyword">case</span> <span class="string">'static'</span>:
        <span class="keyword">case</span> <span class="string">'yield'</span>:
        <span class="keyword">case</span> <span class="string">'let'</span>:
            <span class="keyword">return</span> <span class="literal">true</span>;
        }

        <span class="keyword">return</span> <span class="literal">false</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isRestrictedWord</span><span class="params">(id)</span> {</span>
        <span class="keyword">return</span> id === <span class="string">'eval'</span> || id === <span class="string">'arguments'</span>;
    }

    <span class="comment">// 7.6.1.1 Keywords</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isKeyword</span><span class="params">(id)</span> {</span>
        <span class="keyword">var</span> keyword = <span class="literal">false</span>;
        <span class="keyword">switch</span> (id.length) {
        <span class="keyword">case</span> <span class="number">2</span>:
            keyword = (id === <span class="string">'if'</span>) || (id === <span class="string">'in'</span>) || (id === <span class="string">'do'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">3</span>:
            keyword = (id === <span class="string">'var'</span>) || (id === <span class="string">'for'</span>) || (id === <span class="string">'new'</span>) || (id === <span class="string">'try'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">4</span>:
            keyword = (id === <span class="string">'this'</span>) || (id === <span class="string">'else'</span>) || (id === <span class="string">'case'</span>) || (id === <span class="string">'void'</span>) || (id === <span class="string">'with'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">5</span>:
            keyword = (id === <span class="string">'while'</span>) || (id === <span class="string">'break'</span>) || (id === <span class="string">'catch'</span>) || (id === <span class="string">'throw'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">6</span>:
            keyword = (id === <span class="string">'return'</span>) || (id === <span class="string">'typeof'</span>) || (id === <span class="string">'delete'</span>) || (id === <span class="string">'switch'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">7</span>:
            keyword = (id === <span class="string">'default'</span>) || (id === <span class="string">'finally'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">8</span>:
            keyword = (id === <span class="string">'function'</span>) || (id === <span class="string">'continue'</span>) || (id === <span class="string">'debugger'</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">10</span>:
            keyword = (id === <span class="string">'instanceof'</span>);
            <span class="keyword">break</span>;
        }

        <span class="keyword">if</span> (keyword) {
            <span class="keyword">return</span> <span class="literal">true</span>;
        }

        <span class="keyword">switch</span> (id) {
        <span class="comment">// Future reserved words.</span>
        <span class="comment">// 'const' is specialized as Keyword in V8.</span>
        <span class="keyword">case</span> <span class="string">'const'</span>:
            <span class="keyword">return</span> <span class="literal">true</span>;

        <span class="comment">// For compatiblity to SpiderMonkey and ES.next</span>
        <span class="keyword">case</span> <span class="string">'yield'</span>:
        <span class="keyword">case</span> <span class="string">'let'</span>:
            <span class="keyword">return</span> <span class="literal">true</span>;
        }

        <span class="keyword">if</span> (strict &amp;&amp; isStrictModeReservedWord(id)) {
            <span class="keyword">return</span> <span class="literal">true</span>;
        }

        <span class="keyword">return</span> isFutureReservedWord(id);
    }

    <span class="comment">// Return the next character and move forward.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">nextChar</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> source[index++];
    }

    <span class="comment">// 7.4 Comments</span>

    <span class="function"><span class="keyword">function</span> <span class="title">skipComment</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> ch, blockComment, lineComment;

        blockComment = <span class="literal">false</span>;
        lineComment = <span class="literal">false</span>;

        <span class="keyword">while</span> (index &lt; length) {
            ch = source[index];

            <span class="keyword">if</span> (lineComment) {
                ch = nextChar();
                <span class="keyword">if</span> (isLineTerminator(ch)) {
                    lineComment = <span class="literal">false</span>;
                    <span class="keyword">if</span> (ch === <span class="string">'\r'</span> &amp;&amp; source[index] === <span class="string">'\n'</span>) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (blockComment) {
                <span class="keyword">if</span> (isLineTerminator(ch)) {
                    <span class="keyword">if</span> (ch === <span class="string">'\r'</span> &amp;&amp; source[index + <span class="number">1</span>] === <span class="string">'\n'</span>) {
                        ++index;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                } <span class="keyword">else</span> {
                    ch = nextChar();
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                    <span class="keyword">if</span> (ch === <span class="string">'*'</span>) {
                        ch = source[index];
                        <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                            ++index;
                            blockComment = <span class="literal">false</span>;
                        }
                    }
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                ch = source[index + <span class="number">1</span>];
                <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                    index += <span class="number">2</span>;
                    lineComment = <span class="literal">true</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">'*'</span>) {
                    index += <span class="number">2</span>;
                    blockComment = <span class="literal">true</span>;
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">break</span>;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (isWhiteSpace(ch)) {
                ++index;
            } <span class="keyword">else</span> <span class="keyword">if</span> (isLineTerminator(ch)) {
                ++index;
                <span class="keyword">if</span> (ch ===  <span class="string">'\r'</span> &amp;&amp; source[index] === <span class="string">'\n'</span>) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">scanHexEscape</span><span class="params">(prefix)</span> {</span>
        <span class="keyword">var</span> i, len, ch, code = <span class="number">0</span>;

        len = (prefix === <span class="string">'u'</span>) ? <span class="number">4</span> : <span class="number">2</span>;
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) {
            <span class="keyword">if</span> (index &lt; length &amp;&amp; isHexDigit(source[index])) {
                ch = nextChar();
                code = code * <span class="number">16</span> + <span class="string">'0123456789abcdef'</span>.indexOf(ch.toLowerCase());
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> <span class="string">''</span>;
            }
        }
        <span class="keyword">return</span> String.fromCharCode(code);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">scanIdentifier</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> ch, start, id, restore;

        ch = source[index];
        <span class="keyword">if</span> (!isIdentifierStart(ch)) {
            <span class="keyword">return</span>;
        }

        start = index;
        <span class="keyword">if</span> (ch === <span class="string">'\\'</span>) {
            ++index;
            <span class="keyword">if</span> (source[index] !== <span class="string">'u'</span>) {
                <span class="keyword">return</span>;
            }
            ++index;
            restore = index;
            ch = scanHexEscape(<span class="string">'u'</span>);
            <span class="keyword">if</span> (ch) {
                <span class="keyword">if</span> (ch === <span class="string">'\\'</span> || !isIdentifierStart(ch)) {
                    <span class="keyword">return</span>;
                }
                id = ch;
            } <span class="keyword">else</span> {
                index = restore;
                id = <span class="string">'u'</span>;
            }
        } <span class="keyword">else</span> {
            id = nextChar();
        }

        <span class="keyword">while</span> (index &lt; length) {
            ch = source[index];
            <span class="keyword">if</span> (!isIdentifierPart(ch)) {
                <span class="keyword">break</span>;
            }
            <span class="keyword">if</span> (ch === <span class="string">'\\'</span>) {
                ++index;
                <span class="keyword">if</span> (source[index] !== <span class="string">'u'</span>) {
                    <span class="keyword">return</span>;
                }
                ++index;
                restore = index;
                ch = scanHexEscape(<span class="string">'u'</span>);
                <span class="keyword">if</span> (ch) {
                    <span class="keyword">if</span> (ch === <span class="string">'\\'</span> || !isIdentifierPart(ch)) {
                        <span class="keyword">return</span>;
                    }
                    id += ch;
                } <span class="keyword">else</span> {
                    index = restore;
                    id += <span class="string">'u'</span>;
                }
            } <span class="keyword">else</span> {
                id += nextChar();
            }
        }

        <span class="comment">// There is no keyword or literal with only one character.</span>
        <span class="comment">// Thus, it must be an identifier.</span>
        <span class="keyword">if</span> (id.length === <span class="number">1</span>) {
            <span class="keyword">return</span> {
                type: Token.Identifier,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (isKeyword(id)) {
            <span class="keyword">return</span> {
                type: Token.Keyword,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="comment">// 7.8.1 Null Literals</span>

        <span class="keyword">if</span> (id === <span class="string">'null'</span>) {
            <span class="keyword">return</span> {
                type: Token.NullLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="comment">// 7.8.2 Boolean Literals</span>

        <span class="keyword">if</span> (id === <span class="string">'true'</span> || id === <span class="string">'false'</span>) {
            <span class="keyword">return</span> {
                type: Token.BooleanLiteral,
                value: id,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">return</span> {
            type: Token.Identifier,
            value: id,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    <span class="comment">// 7.7 Punctuators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">scanPunctuator</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> start = index,
            ch1 = source[index],
            ch2,
            ch3,
            ch4;

        <span class="comment">// Check for most common single-character punctuators.</span>

        <span class="keyword">if</span> (ch1 === <span class="string">';'</span> || ch1 === <span class="string">'{'</span> || ch1 === <span class="string">'}'</span>) {
            ++index;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (ch1 === <span class="string">','</span> || ch1 === <span class="string">'('</span> || ch1 === <span class="string">')'</span>) {
            ++index;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: ch1,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="comment">// Dot (.) can also start a floating-point number, hence the need</span>
        <span class="comment">// to check the next character.</span>

        ch2 = source[index + <span class="number">1</span>];
        <span class="keyword">if</span> (ch1 === <span class="string">'.'</span> &amp;&amp; !isDecimalDigit(ch2)) {
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: nextChar(),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="comment">// Peek more characters.</span>

        ch3 = source[index + <span class="number">2</span>];
        ch4 = source[index + <span class="number">3</span>];

        <span class="comment">// 4-character punctuator: >>>=</span>

        <span class="keyword">if</span> (ch1 === <span class="string">'>'</span> &amp;&amp; ch2 === <span class="string">'>'</span> &amp;&amp; ch3 === <span class="string">'>'</span>) {
            <span class="keyword">if</span> (ch4 === <span class="string">'='</span>) {
                index += <span class="number">4</span>;
                <span class="keyword">return</span> {
                    type: Token.Punctuator,
                    value: <span class="string">'>>>='</span>,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        <span class="comment">// 3-character punctuators: === !== >>> &lt;&lt;= >>=</span>

        <span class="keyword">if</span> (ch1 === <span class="string">'='</span> &amp;&amp; ch2 === <span class="string">'='</span> &amp;&amp; ch3 === <span class="string">'='</span>) {
            index += <span class="number">3</span>;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: <span class="string">'==='</span>,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (ch1 === <span class="string">'!'</span> &amp;&amp; ch2 === <span class="string">'='</span> &amp;&amp; ch3 === <span class="string">'='</span>) {
            index += <span class="number">3</span>;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: <span class="string">'!=='</span>,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (ch1 === <span class="string">'>'</span> &amp;&amp; ch2 === <span class="string">'>'</span> &amp;&amp; ch3 === <span class="string">'>'</span>) {
            index += <span class="number">3</span>;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: <span class="string">'>>>'</span>,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (ch1 === <span class="string">'&lt;'</span> &amp;&amp; ch2 === <span class="string">'&lt;'</span> &amp;&amp; ch3 === <span class="string">'='</span>) {
            index += <span class="number">3</span>;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: <span class="string">'&lt;&lt;='</span>,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="keyword">if</span> (ch1 === <span class="string">'>'</span> &amp;&amp; ch2 === <span class="string">'>'</span> &amp;&amp; ch3 === <span class="string">'='</span>) {
            index += <span class="number">3</span>;
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: <span class="string">'>>='</span>,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }

        <span class="comment">// 2-character punctuators: &lt;= >= == != ++ -- &lt;&lt; >> &amp;&amp; ||</span>
        <span class="comment">// += -= *= %= &amp;= |= ^= /=</span>

        <span class="keyword">if</span> (ch2 === <span class="string">'='</span>) {
            <span class="keyword">if</span> (<span class="string">'&lt;>=!+-*%&amp;|^/'</span>.indexOf(ch1) >= <span class="number">0</span>) {
                index += <span class="number">2</span>;
                <span class="keyword">return</span> {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        <span class="keyword">if</span> (ch1 === ch2 &amp;&amp; (<span class="string">'+-&lt;>&amp;|'</span>.indexOf(ch1) >= <span class="number">0</span>)) {
            <span class="keyword">if</span> (<span class="string">'+-&lt;>&amp;|'</span>.indexOf(ch2) >= <span class="number">0</span>) {
                index += <span class="number">2</span>;
                <span class="keyword">return</span> {
                    type: Token.Punctuator,
                    value: ch1 + ch2,
                    lineNumber: lineNumber,
                    lineStart: lineStart,
                    range: [start, index]
                };
            }
        }

        <span class="comment">// The remaining 1-character punctuators.</span>

        <span class="keyword">if</span> (<span class="string">'[]&lt;>+-*%&amp;|^!~?:=/'</span>.indexOf(ch1) >= <span class="number">0</span>) {
            <span class="keyword">return</span> {
                type: Token.Punctuator,
                value: nextChar(),
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [start, index]
            };
        }
    }

    <span class="comment">// 7.8.3 Numeric Literals</span>

    <span class="function"><span class="keyword">function</span> <span class="title">scanNumericLiteral</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> number, start, ch;

        ch = source[index];
        assert(isDecimalDigit(ch) || (ch === <span class="string">'.'</span>),
            <span class="string">'Numeric literal must start with a decimal digit or a decimal point'</span>);

        start = index;
        number = <span class="string">''</span>;
        <span class="keyword">if</span> (ch !== <span class="string">'.'</span>) {
            number = nextChar();
            ch = source[index];

            <span class="comment">// Hex number starts with '0x'.</span>
            <span class="comment">// Octal number starts with '0'.</span>
            <span class="keyword">if</span> (number === <span class="string">'0'</span>) {
                <span class="keyword">if</span> (ch === <span class="string">'x'</span> || ch === <span class="string">'X'</span>) {
                    number += nextChar();
                    <span class="keyword">while</span> (index &lt; length) {
                        ch = source[index];
                        <span class="keyword">if</span> (!isHexDigit(ch)) {
                            <span class="keyword">break</span>;
                        }
                        number += nextChar();
                    }

                    <span class="keyword">if</span> (number.length &lt;= <span class="number">2</span>) {
                        <span class="comment">// only 0x</span>
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }

                    <span class="keyword">if</span> (index &lt; length) {
                        ch = source[index];
                        <span class="keyword">if</span> (isIdentifierStart(ch)) {
                            throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                        }
                    }
                    <span class="keyword">return</span> {
                        type: Token.NumericLiteral,
                        value: parseInt(number, <span class="number">16</span>),
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                } <span class="keyword">else</span> <span class="keyword">if</span> (isOctalDigit(ch)) {
                    number += nextChar();
                    <span class="keyword">while</span> (index &lt; length) {
                        ch = source[index];
                        <span class="keyword">if</span> (!isOctalDigit(ch)) {
                            <span class="keyword">break</span>;
                        }
                        number += nextChar();
                    }

                    <span class="keyword">if</span> (index &lt; length) {
                        ch = source[index];
                        <span class="keyword">if</span> (isIdentifierStart(ch) || isDecimalDigit(ch)) {
                            throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                        }
                    }
                    <span class="keyword">return</span> {
                        type: Token.NumericLiteral,
                        value: parseInt(number, <span class="number">8</span>),
                        octal: <span class="literal">true</span>,
                        lineNumber: lineNumber,
                        lineStart: lineStart,
                        range: [start, index]
                    };
                }

                <span class="comment">// decimal number starts with '0' such as '09' is illegal.</span>
                <span class="keyword">if</span> (isDecimalDigit(ch)) {
                    throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                }
            }

            <span class="keyword">while</span> (index &lt; length) {
                ch = source[index];
                <span class="keyword">if</span> (!isDecimalDigit(ch)) {
                    <span class="keyword">break</span>;
                }
                number += nextChar();
            }
        }

        <span class="keyword">if</span> (ch === <span class="string">'.'</span>) {
            number += nextChar();
            <span class="keyword">while</span> (index &lt; length) {
                ch = source[index];
                <span class="keyword">if</span> (!isDecimalDigit(ch)) {
                    <span class="keyword">break</span>;
                }
                number += nextChar();
            }
        }

        <span class="keyword">if</span> (ch === <span class="string">'e'</span> || ch === <span class="string">'E'</span>) {
            number += nextChar();

            ch = source[index];
            <span class="keyword">if</span> (ch === <span class="string">'+'</span> || ch === <span class="string">'-'</span>) {
                number += nextChar();
            }

            ch = source[index];
            <span class="keyword">if</span> (isDecimalDigit(ch)) {
                number += nextChar();
                <span class="keyword">while</span> (index &lt; length) {
                    ch = source[index];
                    <span class="keyword">if</span> (!isDecimalDigit(ch)) {
                        <span class="keyword">break</span>;
                    }
                    number += nextChar();
                }
            } <span class="keyword">else</span> {
                ch = <span class="string">'character '</span> + ch;
                <span class="keyword">if</span> (index >= length) {
                    ch = <span class="string">'&lt;end>'</span>;
                }
                throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
            }
        }

        <span class="keyword">if</span> (index &lt; length) {
            ch = source[index];
            <span class="keyword">if</span> (isIdentifierStart(ch)) {
                throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
            }
        }

        <span class="keyword">return</span> {
            type: Token.NumericLiteral,
            value: parseFloat(number),
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    <span class="comment">// 7.8.4 String Literals</span>

    <span class="function"><span class="keyword">function</span> <span class="title">scanStringLiteral</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> str = <span class="string">''</span>, quote, start, ch, code, unescaped, restore, octal = <span class="literal">false</span>;

        quote = source[index];
        assert((quote === <span class="string">'\''</span> || quote === <span class="string">'"'</span>),
            <span class="string">'String literal must starts with a quote'</span>);

        start = index;
        ++index;

        <span class="keyword">while</span> (index &lt; length) {
            ch = nextChar();

            <span class="keyword">if</span> (ch === quote) {
                quote = <span class="string">''</span>;
                <span class="keyword">break</span>;
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">'\\'</span>) {
                ch = nextChar();
                <span class="keyword">if</span> (!isLineTerminator(ch)) {
                    <span class="keyword">switch</span> (ch) {
                    <span class="keyword">case</span> <span class="string">'n'</span>:
                        str += <span class="string">'\n'</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'r'</span>:
                        str += <span class="string">'\r'</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'t'</span>:
                        str += <span class="string">'\t'</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'u'</span>:
                    <span class="keyword">case</span> <span class="string">'x'</span>:
                        restore = index;
                        unescaped = scanHexEscape(ch);
                        <span class="keyword">if</span> (unescaped) {
                            str += unescaped;
                        } <span class="keyword">else</span> {
                            index = restore;
                            str += ch;
                        }
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'b'</span>:
                        str += <span class="string">'\b'</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'f'</span>:
                        str += <span class="string">'\f'</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">case</span> <span class="string">'v'</span>:
                        str += <span class="string">'\v'</span>;
                        <span class="keyword">break</span>;

                    <span class="keyword">default</span>:
                        <span class="keyword">if</span> (isOctalDigit(ch)) {
                            code = <span class="string">'01234567'</span>.indexOf(ch);

                            <span class="comment">// \0 is not octal escape sequence</span>
                            <span class="keyword">if</span> (code !== <span class="number">0</span>) {
                                octal = <span class="literal">true</span>;
                            }

                            <span class="keyword">if</span> (index &lt; length &amp;&amp; isOctalDigit(source[index])) {
                                octal = <span class="literal">true</span>;
                                code = code * <span class="number">8</span> + <span class="string">'01234567'</span>.indexOf(nextChar());

                                <span class="comment">// 3 digits are only allowed when string starts</span>
                                <span class="comment">// with 0, 1, 2, 3</span>
                                <span class="keyword">if</span> (<span class="string">'0123'</span>.indexOf(ch) >= <span class="number">0</span> &amp;&amp;
                                        index &lt; length &amp;&amp;
                                        isOctalDigit(source[index])) {
                                    code = code * <span class="number">8</span> + <span class="string">'01234567'</span>.indexOf(nextChar());
                                }
                            }
                            str += String.fromCharCode(code);
                        } <span class="keyword">else</span> {
                            str += ch;
                        }
                        <span class="keyword">break</span>;
                    }
                } <span class="keyword">else</span> {
                    ++lineNumber;
                    <span class="keyword">if</span> (ch ===  <span class="string">'\r'</span> &amp;&amp; source[index] === <span class="string">'\n'</span>) {
                        ++index;
                    }
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (isLineTerminator(ch)) {
                <span class="keyword">break</span>;
            } <span class="keyword">else</span> {
                str += ch;
            }
        }

        <span class="keyword">if</span> (quote !== <span class="string">''</span>) {
            throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
        }

        <span class="keyword">return</span> {
            type: Token.StringLiteral,
            value: str,
            octal: octal,
            lineNumber: lineNumber,
            lineStart: lineStart,
            range: [start, index]
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">scanRegExp</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> str = <span class="string">''</span>, ch, start, pattern, flags, value, classMarker = <span class="literal">false</span>, restore;

        buffer = <span class="literal">null</span>;
        skipComment();

        start = index;
        ch = source[index];
        assert(ch === <span class="string">'/'</span>, <span class="string">'Regular expression literal must start with a slash'</span>);
        str = nextChar();

        <span class="keyword">while</span> (index &lt; length) {
            ch = nextChar();
            str += ch;
            <span class="keyword">if</span> (classMarker) {
                <span class="keyword">if</span> (ch === <span class="string">']'</span>) {
                    classMarker = <span class="literal">false</span>;
                }
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (ch === <span class="string">'\\'</span>) {
                    str += nextChar();
                }
                <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                    <span class="keyword">break</span>;
                }
                <span class="keyword">if</span> (ch === <span class="string">'['</span>) {
                    classMarker = <span class="literal">true</span>;
                }
                <span class="keyword">if</span> (isLineTerminator(ch)) {
                    throwError({}, Messages.UnterminatedRegExp);
                }
            }
        }

        <span class="keyword">if</span> (str.length === <span class="number">1</span>) {
            throwError({}, Messages.UnterminatedRegExp);
        }

        <span class="comment">// Exclude leading and trailing slash.</span>
        pattern = str.substr(<span class="number">1</span>, str.length - <span class="number">2</span>);

        flags = <span class="string">''</span>;
        <span class="keyword">while</span> (index &lt; length) {
            ch = source[index];
            <span class="keyword">if</span> (!isIdentifierPart(ch)) {
                <span class="keyword">break</span>;
            }

            ++index;
            <span class="keyword">if</span> (ch === <span class="string">'\\'</span> &amp;&amp; index &lt; length) {
                ch = source[index];
                <span class="keyword">if</span> (ch === <span class="string">'u'</span>) {
                    ++index;
                    restore = index;
                    ch = scanHexEscape(<span class="string">'u'</span>);
                    <span class="keyword">if</span> (ch) {
                        flags += ch;
                        str += <span class="string">'\\u'</span>;
                        <span class="keyword">for</span> (; restore &lt; index; ++restore) {
                            str += source[restore];
                        }
                    } <span class="keyword">else</span> {
                        index = restore;
                        flags += <span class="string">'u'</span>;
                        str += <span class="string">'\\u'</span>;
                    }
                } <span class="keyword">else</span> {
                    str += <span class="string">'\\'</span>;
                }
            } <span class="keyword">else</span> {
                flags += ch;
                str += ch;
            }
        }

        <span class="keyword">try</span> {
            value = <span class="keyword">new</span> RegExp(pattern, flags);
        } <span class="keyword">catch</span> (e) {
            throwError({}, Messages.InvalidRegExp);
        }

        <span class="keyword">return</span> {
            literal: str,
            value: value,
            range: [start, index]
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">isIdentifierName</span><span class="params">(token)</span> {</span>
        <span class="keyword">return</span> token.type === Token.Identifier ||
            token.type === Token.Keyword ||
            token.type === Token.BooleanLiteral ||
            token.type === Token.NullLiteral;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">advance</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> ch, token;

        skipComment();

        <span class="keyword">if</span> (index >= length) {
            <span class="keyword">return</span> {
                type: Token.EOF,
                lineNumber: lineNumber,
                lineStart: lineStart,
                range: [index, index]
            };
        }

        token = scanPunctuator();
        <span class="keyword">if</span> (<span class="keyword">typeof</span> token !== <span class="string">'undefined'</span>) {
            <span class="keyword">return</span> token;
        }

        ch = source[index];

        <span class="keyword">if</span> (ch === <span class="string">'\''</span> || ch === <span class="string">'"'</span>) {
            <span class="keyword">return</span> scanStringLiteral();
        }

        <span class="keyword">if</span> (ch === <span class="string">'.'</span> || isDecimalDigit(ch)) {
            <span class="keyword">return</span> scanNumericLiteral();
        }

        token = scanIdentifier();
        <span class="keyword">if</span> (<span class="keyword">typeof</span> token !== <span class="string">'undefined'</span>) {
            <span class="keyword">return</span> token;
        }

        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
    }

    <span class="function"><span class="keyword">function</span> <span class="title">lex</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token;

        <span class="keyword">if</span> (buffer) {
            index = buffer.range[<span class="number">1</span>];
            lineNumber = buffer.lineNumber;
            lineStart = buffer.lineStart;
            token = buffer;
            buffer = <span class="literal">null</span>;
            <span class="keyword">return</span> token;
        }

        buffer = <span class="literal">null</span>;
        <span class="keyword">return</span> advance();
    }

    <span class="function"><span class="keyword">function</span> <span class="title">lookahead</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> pos, line, start;

        <span class="keyword">if</span> (buffer !== <span class="literal">null</span>) {
            <span class="keyword">return</span> buffer;
        }

        pos = index;
        line = lineNumber;
        start = lineStart;
        buffer = advance();
        index = pos;
        lineNumber = line;
        lineStart = start;

        <span class="keyword">return</span> buffer;
    }

    <span class="comment">// Return true if there is a line terminator before the next token.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">peekLineTerminator</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> pos, line, start, found;

        pos = index;
        line = lineNumber;
        start = lineStart;
        skipComment();
        found = lineNumber !== line;
        index = pos;
        lineNumber = line;
        lineStart = start;

        <span class="keyword">return</span> found;
    }

    <span class="comment">// Throw an exception</span>

    <span class="function"><span class="keyword">function</span> <span class="title">throwError</span><span class="params">(token, messageFormat)</span> {</span>
        <span class="keyword">var</span> error,
            args = Array.prototype.slice.call(arguments, <span class="number">2</span>),
            msg = messageFormat.replace(
                <span class="regexp">/%(\d)/g</span>,
                <span class="function"><span class="keyword">function</span> <span class="params">(whole, index)</span> {</span>
                    <span class="keyword">return</span> args[index] || <span class="string">''</span>;
                }
            );

        <span class="keyword">if</span> (<span class="keyword">typeof</span> token.lineNumber === <span class="string">'number'</span>) {
            error = <span class="keyword">new</span> Error(<span class="string">'Line '</span> + token.lineNumber + <span class="string">': '</span> + msg);
            error.index = token.range[<span class="number">0</span>];
            error.lineNumber = token.lineNumber;
            error.column = token.range[<span class="number">0</span>] - lineStart + <span class="number">1</span>;
        } <span class="keyword">else</span> {
            error = <span class="keyword">new</span> Error(<span class="string">'Line '</span> + lineNumber + <span class="string">': '</span> + msg);
            error.index = index;
            error.lineNumber = lineNumber;
            error.column = index - lineStart + <span class="number">1</span>;
        }

        <span class="keyword">throw</span> error;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">throwErrorTolerant</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> error;
        <span class="keyword">try</span> {
            throwError.apply(<span class="literal">null</span>, arguments);
        } <span class="keyword">catch</span> (e) {
            <span class="keyword">if</span> (extra.errors) {
                extra.errors.push(e);
            } <span class="keyword">else</span> {
                <span class="keyword">throw</span> e;
            }
        }
    }


    <span class="comment">// Throw an exception because of the token.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">throwUnexpected</span><span class="params">(token)</span> {</span>
        <span class="keyword">var</span> s;

        <span class="keyword">if</span> (token.type === Token.EOF) {
            throwError(token, Messages.UnexpectedEOS);
        }

        <span class="keyword">if</span> (token.type === Token.NumericLiteral) {
            throwError(token, Messages.UnexpectedNumber);
        }

        <span class="keyword">if</span> (token.type === Token.StringLiteral) {
            throwError(token, Messages.UnexpectedString);
        }

        <span class="keyword">if</span> (token.type === Token.Identifier) {
            throwError(token, Messages.UnexpectedIdentifier);
        }

        <span class="keyword">if</span> (token.type === Token.Keyword) {
            <span class="keyword">if</span> (isFutureReservedWord(token.value)) {
                throwError(token, Messages.UnexpectedReserved);
            } <span class="keyword">else</span> <span class="keyword">if</span> (strict &amp;&amp; isStrictModeReservedWord(token.value)) {
                throwError(token, Messages.StrictReservedWord);
            }
            throwError(token, Messages.UnexpectedToken, token.value);
        }

        <span class="comment">// BooleanLiteral, NullLiteral, or Punctuator.</span>
        throwError(token, Messages.UnexpectedToken, token.value);
    }

    <span class="comment">// Expect the next token to match the specified punctuator.</span>
    <span class="comment">// If not, an exception will be thrown.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">expect</span><span class="params">(value)</span> {</span>
        <span class="keyword">var</span> token = lex();
        <span class="keyword">if</span> (token.type !== Token.Punctuator || token.value !== value) {
            throwUnexpected(token);
        }
    }

    <span class="comment">// Expect the next token to match the specified keyword.</span>
    <span class="comment">// If not, an exception will be thrown.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">expectKeyword</span><span class="params">(keyword)</span> {</span>
        <span class="keyword">var</span> token = lex();
        <span class="keyword">if</span> (token.type !== Token.Keyword || token.value !== keyword) {
            throwUnexpected(token);
        }
    }

    <span class="comment">// Return true if the next token matches the specified punctuator.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">match</span><span class="params">(value)</span> {</span>
        <span class="keyword">var</span> token = lookahead();
        <span class="keyword">return</span> token.type === Token.Punctuator &amp;&amp; token.value === value;
    }

    <span class="comment">// Return true if the next token matches the specified keyword</span>

    <span class="function"><span class="keyword">function</span> <span class="title">matchKeyword</span><span class="params">(keyword)</span> {</span>
        <span class="keyword">var</span> token = lookahead();
        <span class="keyword">return</span> token.type === Token.Keyword &amp;&amp; token.value === keyword;
    }

    <span class="comment">// Return true if the next token is an assignment operator</span>

    <span class="function"><span class="keyword">function</span> <span class="title">matchAssign</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lookahead(),
            op = token.value;

        <span class="keyword">if</span> (token.type !== Token.Punctuator) {
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">return</span> op === <span class="string">'='</span> ||
            op === <span class="string">'*='</span> ||
            op === <span class="string">'/='</span> ||
            op === <span class="string">'%='</span> ||
            op === <span class="string">'+='</span> ||
            op === <span class="string">'-='</span> ||
            op === <span class="string">'&lt;&lt;='</span> ||
            op === <span class="string">'>>='</span> ||
            op === <span class="string">'>>>='</span> ||
            op === <span class="string">'&amp;='</span> ||
            op === <span class="string">'^='</span> ||
            op === <span class="string">'|='</span>;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">consumeSemicolon</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, line;

        <span class="comment">// Catch the very common case first.</span>
        <span class="keyword">if</span> (source[index] === <span class="string">';'</span>) {
            lex();
            <span class="keyword">return</span>;
        }

        line = lineNumber;
        skipComment();
        <span class="keyword">if</span> (lineNumber !== line) {
            <span class="keyword">return</span>;
        }

        <span class="keyword">if</span> (match(<span class="string">';'</span>)) {
            lex();
            <span class="keyword">return</span>;
        }

        token = lookahead();
        <span class="keyword">if</span> (token.type !== Token.EOF &amp;&amp; !match(<span class="string">'}'</span>)) {
            throwUnexpected(token);
        }
        <span class="keyword">return</span>;
    }

    <span class="comment">// Return true if provided expression is LeftHandSideExpression</span>

    <span class="function"><span class="keyword">function</span> <span class="title">isLeftHandSide</span><span class="params">(expr)</span> {</span>
        <span class="keyword">switch</span> (expr.type) {
        <span class="keyword">case</span> <span class="string">'AssignmentExpression'</span>:
        <span class="keyword">case</span> <span class="string">'BinaryExpression'</span>:
        <span class="keyword">case</span> <span class="string">'ConditionalExpression'</span>:
        <span class="keyword">case</span> <span class="string">'LogicalExpression'</span>:
        <span class="keyword">case</span> <span class="string">'SequenceExpression'</span>:
        <span class="keyword">case</span> <span class="string">'UnaryExpression'</span>:
        <span class="keyword">case</span> <span class="string">'UpdateExpression'</span>:
            <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="comment">// 11.1.4 Array Initialiser</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseArrayInitialiser</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> elements = [],
            undef;

        expect(<span class="string">'['</span>);

        <span class="keyword">while</span> (!match(<span class="string">']'</span>)) {
            <span class="keyword">if</span> (match(<span class="string">','</span>)) {
                lex();
                elements.push(undef);
            } <span class="keyword">else</span> {
                elements.push(parseAssignmentExpression());

                <span class="keyword">if</span> (!match(<span class="string">']'</span>)) {
                    expect(<span class="string">','</span>);
                }
            }
        }

        expect(<span class="string">']'</span>);

        <span class="keyword">return</span> {
            type: Syntax.ArrayExpression,
            elements: elements
        };
    }

    <span class="comment">// 11.1.5 Object Initialiser</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parsePropertyFunction</span><span class="params">(param, first)</span> {</span>
        <span class="keyword">var</span> previousStrict, body;

        previousStrict = strict;
        body = parseFunctionSourceElements();
        <span class="keyword">if</span> (first &amp;&amp; strict &amp;&amp; isRestrictedWord(param[<span class="number">0</span>].name)) {
            throwError(first, Messages.StrictParamName);
        }
        strict = previousStrict;

        <span class="keyword">return</span> {
            type: Syntax.FunctionExpression,
            id: <span class="literal">null</span>,
            params: param,
            body: body
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseObjectPropertyKey</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lex(),
            key;

        <span class="keyword">switch</span> (token.type) {

        <span class="keyword">case</span> Token.StringLiteral:
        <span class="keyword">case</span> Token.NumericLiteral:
            <span class="keyword">if</span> (strict &amp;&amp; token.octal) {
                throwError(token, Messages.StrictOctalLiteral);
            }
            key = createLiteral(token);
            <span class="keyword">break</span>;

        <span class="keyword">case</span> Token.Identifier:
        <span class="keyword">case</span> Token.Keyword:
        <span class="keyword">case</span> Token.BooleanLiteral:
        <span class="keyword">case</span> Token.NullLiteral:
            key = {
                type: Syntax.Identifier,
                name: token.value
            };
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            <span class="comment">// Unreachable, since parseObjectProperty() will not call this</span>
            <span class="comment">// function with any other type of token.</span>
        }

        <span class="keyword">return</span> key;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseObjectProperty</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, property, key, id, param;

        token = lookahead();

        <span class="keyword">switch</span> (token.type) {

        <span class="keyword">case</span> Token.Identifier:
            id = parseObjectPropertyKey();

            <span class="comment">// Property Assignment: Getter and Setter.</span>

            <span class="keyword">if</span> (token.value === <span class="string">'get'</span> &amp;&amp; !match(<span class="string">':'</span>)) {
                key = parseObjectPropertyKey();
                expect(<span class="string">'('</span>);
                expect(<span class="string">')'</span>);
                property = {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction([]),
                    kind: <span class="string">'get'</span>
                };
            } <span class="keyword">else</span> <span class="keyword">if</span> (token.value === <span class="string">'set'</span> &amp;&amp; !match(<span class="string">':'</span>)) {
                key = parseObjectPropertyKey();
                expect(<span class="string">'('</span>);
                token = lookahead();
                <span class="keyword">if</span> (token.type !== Token.Identifier) {
                    throwUnexpected(lex());
                }
                param = [ parseVariableIdentifier() ];
                expect(<span class="string">')'</span>);
                property = {
                    type: Syntax.Property,
                    key: key,
                    value: parsePropertyFunction(param, token),
                    kind: <span class="string">'set'</span>
                };
            } <span class="keyword">else</span> {
                expect(<span class="string">':'</span>);
                property = {
                    type: Syntax.Property,
                    key: id,
                    value: parseAssignmentExpression(),
                    kind: <span class="string">'init'</span>
                };
            }
            <span class="keyword">break</span>;

        <span class="keyword">case</span> Token.Keyword:
        <span class="keyword">case</span> Token.BooleanLiteral:
        <span class="keyword">case</span> Token.NullLiteral:
        <span class="keyword">case</span> Token.StringLiteral:
        <span class="keyword">case</span> Token.NumericLiteral:
            key = parseObjectPropertyKey();
            expect(<span class="string">':'</span>);
            property = {
                type: Syntax.Property,
                key: key,
                value: parseAssignmentExpression(),
                kind: <span class="string">'init'</span>
            };
            <span class="keyword">break</span>;

        <span class="keyword">default</span>:
            throwUnexpected(token);
        }

        <span class="keyword">return</span> property;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseObjectInitialiser</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, properties = [], property, name, kind, map = {}, toString = String;

        expect(<span class="string">'{'</span>);

        <span class="keyword">while</span> (!match(<span class="string">'}'</span>)) {
            property = parseObjectProperty();

            <span class="keyword">if</span> (property.key.type === Syntax.Identifier) {
                name = property.key.name;
            } <span class="keyword">else</span> {
                name = toString(property.key.value);
            }
            kind = (property.kind === <span class="string">'init'</span>) ? PropertyKind.Data : (property.kind === <span class="string">'get'</span>) ? PropertyKind.Get : PropertyKind.Set;
            <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(map, name)) {
                <span class="keyword">if</span> (map[name] === PropertyKind.Data) {
                    <span class="keyword">if</span> (strict &amp;&amp; kind === PropertyKind.Data) {
                        throwError({}, Messages.StrictDuplicateProperty);
                    } <span class="keyword">else</span> <span class="keyword">if</span> (kind !== PropertyKind.Data) {
                        throwError({}, Messages.AccessorDataProperty);
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">if</span> (kind === PropertyKind.Data) {
                        throwError({}, Messages.AccessorDataProperty);
                    } <span class="keyword">else</span> <span class="keyword">if</span> (map[name] &amp; kind) {
                        throwError({}, Messages.AccessorGetSet);
                    }
                }
                map[name] |= kind;
            } <span class="keyword">else</span> {
                map[name] = kind;
            }

            properties.push(property);

            <span class="keyword">if</span> (!match(<span class="string">'}'</span>)) {
                expect(<span class="string">','</span>);
            }
        }

        expect(<span class="string">'}'</span>);

        <span class="keyword">return</span> {
            type: Syntax.ObjectExpression,
            properties: properties
        };
    }

    <span class="comment">// 11.1 Primary Expressions</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parsePrimaryExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr,
            token = lookahead(),
            type = token.type;

        <span class="keyword">if</span> (type === Token.Identifier) {
            <span class="keyword">return</span> {
                type: Syntax.Identifier,
                name: lex().value
            };
        }

        <span class="keyword">if</span> (type === Token.StringLiteral || type === Token.NumericLiteral) {
            <span class="keyword">if</span> (strict &amp;&amp; token.octal) {
                throwError(token, Messages.StrictOctalLiteral);
            }
            <span class="keyword">return</span> createLiteral(lex());
        }

        <span class="keyword">if</span> (type === Token.Keyword) {
            <span class="keyword">if</span> (matchKeyword(<span class="string">'this'</span>)) {
                lex();
                <span class="keyword">return</span> {
                    type: Syntax.ThisExpression
                };
            }

            <span class="keyword">if</span> (matchKeyword(<span class="string">'function'</span>)) {
                <span class="keyword">return</span> parseFunctionExpression();
            }
        }

        <span class="keyword">if</span> (type === Token.BooleanLiteral) {
            lex();
            token.value = (token.value === <span class="string">'true'</span>);
            <span class="keyword">return</span> createLiteral(token);
        }

        <span class="keyword">if</span> (type === Token.NullLiteral) {
            lex();
            token.value = <span class="literal">null</span>;
            <span class="keyword">return</span> createLiteral(token);
        }

        <span class="keyword">if</span> (match(<span class="string">'['</span>)) {
            <span class="keyword">return</span> parseArrayInitialiser();
        }

        <span class="keyword">if</span> (match(<span class="string">'{'</span>)) {
            <span class="keyword">return</span> parseObjectInitialiser();
        }

        <span class="keyword">if</span> (match(<span class="string">'('</span>)) {
            lex();
            lastParenthesized = expr = parseExpression();
            expect(<span class="string">')'</span>);
            <span class="keyword">return</span> expr;
        }

        <span class="keyword">if</span> (match(<span class="string">'/'</span>) || match(<span class="string">'/='</span>)) {
            <span class="keyword">return</span> createLiteral(scanRegExp());
        }

        <span class="keyword">return</span> throwUnexpected(lex());
    }

    <span class="comment">// 11.2 Left-Hand-Side Expressions</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseArguments</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> args = [];

        expect(<span class="string">'('</span>);

        <span class="keyword">if</span> (!match(<span class="string">')'</span>)) {
            <span class="keyword">while</span> (index &lt; length) {
                args.push(parseAssignmentExpression());
                <span class="keyword">if</span> (match(<span class="string">')'</span>)) {
                    <span class="keyword">break</span>;
                }
                expect(<span class="string">','</span>);
            }
        }

        expect(<span class="string">')'</span>);

        <span class="keyword">return</span> args;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseNonComputedProperty</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lex();

        <span class="keyword">if</span> (!isIdentifierName(token)) {
            throwUnexpected(token);
        }

        <span class="keyword">return</span> {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseNonComputedMember</span><span class="params">(object)</span> {</span>
        <span class="keyword">return</span> {
            type: Syntax.MemberExpression,
            computed: <span class="literal">false</span>,
            object: object,
            property: parseNonComputedProperty()
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseComputedMember</span><span class="params">(object)</span> {</span>
        <span class="keyword">var</span> property, expr;

        expect(<span class="string">'['</span>);
        property = parseExpression();
        expr = {
            type: Syntax.MemberExpression,
            computed: <span class="literal">true</span>,
            object: object,
            property: property
        };
        expect(<span class="string">']'</span>);
        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseCallMember</span><span class="params">(object)</span> {</span>
        <span class="keyword">return</span> {
            type: Syntax.CallExpression,
            callee: object,
            <span class="string">'arguments'</span>: parseArguments()
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseNewExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr;

        expectKeyword(<span class="string">'new'</span>);

        expr = {
            type: Syntax.NewExpression,
            callee: parseLeftHandSideExpression(),
            <span class="string">'arguments'</span>: []
        };

        <span class="keyword">if</span> (match(<span class="string">'('</span>)) {
            expr[<span class="string">'arguments'</span>] = parseArguments();
        }

        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseLeftHandSideExpressionAllowCall</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> useNew, expr;

        useNew = matchKeyword(<span class="string">'new'</span>);
        expr = useNew ? parseNewExpression() : parsePrimaryExpression();

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'.'</span>)) {
                lex();
                expr = parseNonComputedMember(expr);
            } <span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">'['</span>)) {
                expr = parseComputedMember(expr);
            } <span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">'('</span>)) {
                expr = parseCallMember(expr);
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseLeftHandSideExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> useNew, expr;

        useNew = matchKeyword(<span class="string">'new'</span>);
        expr = useNew ? parseNewExpression() : parsePrimaryExpression();

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'.'</span>)) {
                lex();
                expr = parseNonComputedMember(expr);
            } <span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">'['</span>)) {
                expr = parseComputedMember(expr);
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.3 Postfix Expressions</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parsePostfixExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseLeftHandSideExpressionAllowCall();

        <span class="keyword">if</span> ((match(<span class="string">'++'</span>) || match(<span class="string">'--'</span>)) &amp;&amp; !peekLineTerminator()) {
            <span class="comment">// 11.3.1, 11.3.2</span>
            <span class="keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                throwError({}, Messages.StrictLHSPostfix);
            }
            expr = {
                type: Syntax.UpdateExpression,
                operator: lex().value,
                argument: expr,
                prefix: <span class="literal">false</span>
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.4 Unary Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseUnaryExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, expr;

        <span class="keyword">if</span> (match(<span class="string">'++'</span>) || match(<span class="string">'--'</span>)) {
            token = lex();
            expr = parseUnaryExpression();
            <span class="comment">// 11.4.4, 11.4.5</span>
            <span class="keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                throwError({}, Messages.StrictLHSPrefix);
            }
            expr = {
                type: Syntax.UpdateExpression,
                operator: token.value,
                argument: expr,
                prefix: <span class="literal">true</span>
            };
            <span class="keyword">return</span> expr;
        }

        <span class="keyword">if</span> (match(<span class="string">'+'</span>) || match(<span class="string">'-'</span>) || match(<span class="string">'~'</span>) || match(<span class="string">'!'</span>)) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression()
            };
            <span class="keyword">return</span> expr;
        }

        <span class="keyword">if</span> (matchKeyword(<span class="string">'delete'</span>) || matchKeyword(<span class="string">'void'</span>) || matchKeyword(<span class="string">'typeof'</span>)) {
            expr = {
                type: Syntax.UnaryExpression,
                operator: lex().value,
                argument: parseUnaryExpression()
            };
            <span class="keyword">if</span> (strict &amp;&amp; expr.operator === <span class="string">'delete'</span> &amp;&amp; expr.argument.type === Syntax.Identifier) {
                throwError({}, Messages.StrictDelete);
            }
            <span class="keyword">return</span> expr;
        }

        <span class="keyword">return</span> parsePostfixExpression();
    }

    <span class="comment">// 11.5 Multiplicative Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseMultiplicativeExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseUnaryExpression();

        <span class="keyword">while</span> (match(<span class="string">'*'</span>) || match(<span class="string">'/'</span>) || match(<span class="string">'%'</span>)) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseUnaryExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.6 Additive Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseAdditiveExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseMultiplicativeExpression();

        <span class="keyword">while</span> (match(<span class="string">'+'</span>) || match(<span class="string">'-'</span>)) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseMultiplicativeExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.7 Bitwise Shift Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseShiftExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseAdditiveExpression();

        <span class="keyword">while</span> (match(<span class="string">'&lt;&lt;'</span>) || match(<span class="string">'>>'</span>) || match(<span class="string">'>>>'</span>)) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseAdditiveExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }
    <span class="comment">// 11.8 Relational Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseRelationalExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr, previousAllowIn;

        previousAllowIn = allowIn;
        allowIn = <span class="literal">true</span>;
        expr = parseShiftExpression();
        allowIn = previousAllowIn;

        <span class="keyword">if</span> (match(<span class="string">'&lt;'</span>) || match(<span class="string">'>'</span>) || match(<span class="string">'&lt;='</span>) || match(<span class="string">'>='</span>)) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseRelationalExpression()
            };
        } <span class="keyword">else</span> <span class="keyword">if</span> (allowIn &amp;&amp; matchKeyword(<span class="string">'in'</span>)) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: <span class="string">'in'</span>,
                left: expr,
                right: parseRelationalExpression()
            };
        } <span class="keyword">else</span> <span class="keyword">if</span> (matchKeyword(<span class="string">'instanceof'</span>)) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: <span class="string">'instanceof'</span>,
                left: expr,
                right: parseRelationalExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.9 Equality Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseEqualityExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseRelationalExpression();

        <span class="keyword">while</span> (match(<span class="string">'=='</span>) || match(<span class="string">'!='</span>) || match(<span class="string">'==='</span>) || match(<span class="string">'!=='</span>)) {
            expr = {
                type: Syntax.BinaryExpression,
                operator: lex().value,
                left: expr,
                right: parseRelationalExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.10 Binary Bitwise Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseBitwiseANDExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseEqualityExpression();

        <span class="keyword">while</span> (match(<span class="string">'&amp;'</span>)) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: <span class="string">'&amp;'</span>,
                left: expr,
                right: parseEqualityExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseBitwiseORExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseBitwiseANDExpression();

        <span class="keyword">while</span> (match(<span class="string">'|'</span>)) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: <span class="string">'|'</span>,
                left: expr,
                right: parseBitwiseANDExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseBitwiseXORExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseBitwiseORExpression();

        <span class="keyword">while</span> (match(<span class="string">'^'</span>)) {
            lex();
            expr = {
                type: Syntax.BinaryExpression,
                operator: <span class="string">'^'</span>,
                left: expr,
                right: parseBitwiseORExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.11 Binary Logical Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseLogicalANDExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseBitwiseXORExpression();

        <span class="keyword">while</span> (match(<span class="string">'&amp;&amp;'</span>)) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: <span class="string">'&amp;&amp;'</span>,
                left: expr,
                right: parseBitwiseXORExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseLogicalORExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseLogicalANDExpression();

        <span class="keyword">while</span> (match(<span class="string">'||'</span>)) {
            lex();
            expr = {
                type: Syntax.LogicalExpression,
                operator: <span class="string">'||'</span>,
                left: expr,
                right: parseLogicalANDExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.12 Conditional Operator</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseConditionalExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr, previousAllowIn, consequent;

        expr = parseLogicalORExpression();

        <span class="keyword">if</span> (match(<span class="string">'?'</span>)) {
            lex();
            previousAllowIn = allowIn;
            allowIn = <span class="literal">true</span>;
            consequent = parseAssignmentExpression();
            allowIn = previousAllowIn;
            expect(<span class="string">':'</span>);

            expr = {
                type: Syntax.ConditionalExpression,
                test: expr,
                consequent: consequent,
                alternate: parseAssignmentExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.13 Assignment Operators</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseAssignmentExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr;

        expr = parseConditionalExpression();

        <span class="keyword">if</span> (matchAssign()) {
            <span class="comment">// LeftHandSideExpression</span>
            <span class="keyword">if</span> (lastParenthesized !== expr &amp;&amp; !isLeftHandSide(expr)) {
                throwError({}, Messages.InvalidLHSInAssignment);
            }

            <span class="comment">// 11.13.1</span>
            <span class="keyword">if</span> (strict &amp;&amp; expr.type === Syntax.Identifier &amp;&amp; isRestrictedWord(expr.name)) {
                throwError({}, Messages.StrictLHSAssignment);
            }

            expr = {
                type: Syntax.AssignmentExpression,
                operator: lex().value,
                left: expr,
                right: parseAssignmentExpression()
            };
        }

        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 11.14 Comma Operator</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseAssignmentExpression();

        <span class="keyword">if</span> (match(<span class="string">','</span>)) {
            expr = {
                type: Syntax.SequenceExpression,
                expressions: [ expr ]
            };

            <span class="keyword">while</span> (index &lt; length) {
                <span class="keyword">if</span> (!match(<span class="string">','</span>)) {
                    <span class="keyword">break</span>;
                }
                lex();
                expr.expressions.push(parseAssignmentExpression());
            }

        }
        <span class="keyword">return</span> expr;
    }

    <span class="comment">// 12.1 Block</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseStatementList</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> list = [],
            statement;

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'}'</span>)) {
                <span class="keyword">break</span>;
            }
            statement = parseSourceElement();
            <span class="keyword">if</span> (<span class="keyword">typeof</span> statement === <span class="string">'undefined'</span>) {
                <span class="keyword">break</span>;
            }
            list.push(statement);
        }

        <span class="keyword">return</span> list;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseBlock</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> block;

        expect(<span class="string">'{'</span>);

        block = parseStatementList();

        expect(<span class="string">'}'</span>);

        <span class="keyword">return</span> {
            type: Syntax.BlockStatement,
            body: block
        };
    }

    <span class="comment">// 12.2 Variable Statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseVariableIdentifier</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lex();

        <span class="keyword">if</span> (token.type !== Token.Identifier) {
            throwUnexpected(token);
        }

        <span class="keyword">return</span> {
            type: Syntax.Identifier,
            name: token.value
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseVariableDeclaration</span><span class="params">(kind)</span> {</span>
        <span class="keyword">var</span> id = parseVariableIdentifier(),
            init = <span class="literal">null</span>;

        <span class="comment">// 12.2.1</span>
        <span class="keyword">if</span> (strict &amp;&amp; isRestrictedWord(id.name)) {
            throwError({}, Messages.StrictVarName);
        }

        <span class="keyword">if</span> (kind === <span class="string">'const'</span>) {
            expect(<span class="string">'='</span>);
            init = parseAssignmentExpression();
        } <span class="keyword">else</span> <span class="keyword">if</span> (match(<span class="string">'='</span>)) {
            lex();
            init = parseAssignmentExpression();
        }

        <span class="keyword">return</span> {
            type: Syntax.VariableDeclarator,
            id: id,
            init: init
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseVariableDeclarationList</span><span class="params">(kind)</span> {</span>
        <span class="keyword">var</span> list = [];

        <span class="keyword">while</span> (index &lt; length) {
            list.push(parseVariableDeclaration(kind));
            <span class="keyword">if</span> (!match(<span class="string">','</span>)) {
                <span class="keyword">break</span>;
            }
            lex();
        }

        <span class="keyword">return</span> list;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseVariableStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> declarations;

        expectKeyword(<span class="string">'var'</span>);

        declarations = parseVariableDeclarationList();

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: <span class="string">'var'</span>
        };
    }

    <span class="comment">// kind may be `const` or `let`</span>
    <span class="comment">// Both are experimental and not in the specification yet.</span>
    <span class="comment">// see http://wiki.ecmascript.org/doku.php?id=harmony:const</span>
    <span class="comment">// and http://wiki.ecmascript.org/doku.php?id=harmony:let</span>
    <span class="function"><span class="keyword">function</span> <span class="title">parseConstLetDeclaration</span><span class="params">(kind)</span> {</span>
        <span class="keyword">var</span> declarations;

        expectKeyword(kind);

        declarations = parseVariableDeclarationList(kind);

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.VariableDeclaration,
            declarations: declarations,
            kind: kind
        };
    }

    <span class="comment">// 12.3 Empty Statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseEmptyStatement</span><span class="params">()</span> {</span>
        expect(<span class="string">';'</span>);

        <span class="keyword">return</span> {
            type: Syntax.EmptyStatement
        };
    }

    <span class="comment">// 12.4 Expression Statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseExpressionStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> expr = parseExpression();

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    <span class="comment">// 12.5 If statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseIfStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> test, consequent, alternate;

        expectKeyword(<span class="string">'if'</span>);

        expect(<span class="string">'('</span>);

        test = parseExpression();

        expect(<span class="string">')'</span>);

        consequent = parseStatement();

        <span class="keyword">if</span> (matchKeyword(<span class="string">'else'</span>)) {
            lex();
            alternate = parseStatement();
        } <span class="keyword">else</span> {
            alternate = <span class="literal">null</span>;
        }

        <span class="keyword">return</span> {
            type: Syntax.IfStatement,
            test: test,
            consequent: consequent,
            alternate: alternate
        };
    }

    <span class="comment">// 12.6 Iteration Statements</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseDoWhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> body, test, oldInIteration;

        expectKeyword(<span class="string">'do'</span>);

        oldInIteration = inIteration;
        inIteration = <span class="literal">true</span>;

        body = parseStatement();

        inIteration = oldInIteration;

        expectKeyword(<span class="string">'while'</span>);

        expect(<span class="string">'('</span>);

        test = parseExpression();

        expect(<span class="string">')'</span>);

        <span class="keyword">if</span> (match(<span class="string">';'</span>)) {
            lex();
        }

        <span class="keyword">return</span> {
            type: Syntax.DoWhileStatement,
            body: body,
            test: test
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseWhileStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> test, body, oldInIteration;

        expectKeyword(<span class="string">'while'</span>);

        expect(<span class="string">'('</span>);

        test = parseExpression();

        expect(<span class="string">')'</span>);

        oldInIteration = inIteration;
        inIteration = <span class="literal">true</span>;

        body = parseStatement();

        inIteration = oldInIteration;

        <span class="keyword">return</span> {
            type: Syntax.WhileStatement,
            test: test,
            body: body
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseForVariableDeclaration</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lex();

        <span class="keyword">return</span> {
            type: Syntax.VariableDeclaration,
            declarations: parseVariableDeclarationList(),
            kind: token.value
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseForStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> init, test, update, left, right, body, oldInIteration;

        init = test = update = <span class="literal">null</span>;

        expectKeyword(<span class="string">'for'</span>);

        expect(<span class="string">'('</span>);

        <span class="keyword">if</span> (match(<span class="string">';'</span>)) {
            lex();
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (matchKeyword(<span class="string">'var'</span>) || matchKeyword(<span class="string">'let'</span>)) {
                allowIn = <span class="literal">false</span>;
                init = parseForVariableDeclaration();
                allowIn = <span class="literal">true</span>;

                <span class="keyword">if</span> (init.declarations.length === <span class="number">1</span> &amp;&amp; matchKeyword(<span class="string">'in'</span>)) {
                    lex();
                    left = init;
                    right = parseExpression();
                    init = <span class="literal">null</span>;
                }
            } <span class="keyword">else</span> {
                allowIn = <span class="literal">false</span>;
                init = parseExpression();
                allowIn = <span class="literal">true</span>;

                <span class="keyword">if</span> (matchKeyword(<span class="string">'in'</span>)) {
                    <span class="comment">// LeftHandSideExpression</span>
                    <span class="keyword">if</span> (matchKeyword(<span class="string">'in'</span>) &amp;&amp; (lastParenthesized !== init &amp;&amp; !isLeftHandSide(init))) {
                        throwError({}, Messages.InvalidLHSInForIn);
                    }
                    lex();
                    left = init;
                    right = parseExpression();
                    init = <span class="literal">null</span>;
                }
            }

            <span class="keyword">if</span> (<span class="keyword">typeof</span> left === <span class="string">'undefined'</span>) {
                expect(<span class="string">';'</span>);
            }
        }

        <span class="keyword">if</span> (<span class="keyword">typeof</span> left === <span class="string">'undefined'</span>) {

            <span class="keyword">if</span> (!match(<span class="string">';'</span>)) {
                test = parseExpression();
            }
            expect(<span class="string">';'</span>);

            <span class="keyword">if</span> (!match(<span class="string">')'</span>)) {
                update = parseExpression();
            }
        }

        expect(<span class="string">')'</span>);

        oldInIteration = inIteration;
        inIteration = <span class="literal">true</span>;

        body = parseStatement();

        inIteration = oldInIteration;

        <span class="keyword">if</span> (<span class="keyword">typeof</span> left === <span class="string">'undefined'</span>) {
            <span class="keyword">return</span> {
                type: Syntax.ForStatement,
                init: init,
                test: test,
                update: update,
                body: body
            };
        }

        <span class="keyword">return</span> {
            type: Syntax.ForInStatement,
            left: left,
            right: right,
            body: body,
            each: <span class="literal">false</span>
        };
    }

    <span class="comment">// 12.7 The continue statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseContinueStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, label = <span class="literal">null</span>;

        expectKeyword(<span class="string">'continue'</span>);

        <span class="comment">// Optimize the most common form: 'continue;'.</span>
        <span class="keyword">if</span> (source[index] === <span class="string">';'</span>) {
            lex();
            
            <span class="keyword">if</span> (!inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            <span class="keyword">return</span> {
                type: Syntax.ContinueStatement,
                label: <span class="literal">null</span>
            };
        }

        <span class="keyword">if</span> (peekLineTerminator()) {
            <span class="keyword">if</span> (!inIteration) {
                throwError({}, Messages.IllegalContinue);
            }

            <span class="keyword">return</span> {
                type: Syntax.ContinueStatement,
                label: <span class="literal">null</span>
            };
        }

        token = lookahead();
        <span class="keyword">if</span> (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            <span class="keyword">if</span> (!Object.prototype.hasOwnProperty.call(labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        <span class="keyword">if</span> (label === <span class="literal">null</span> &amp;&amp; !inIteration) {
            throwError({}, Messages.IllegalContinue);
        }

        <span class="keyword">return</span> {
            type: Syntax.ContinueStatement,
            label: label
        };
    }

    <span class="comment">// 12.8 The break statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseBreakStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, label = <span class="literal">null</span>;

        expectKeyword(<span class="string">'break'</span>);

        <span class="comment">// Optimize the most common form: 'break;'.</span>
        <span class="keyword">if</span> (source[index] === <span class="string">';'</span>) {
            lex();
            
            <span class="keyword">if</span> (!(inIteration || inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            <span class="keyword">return</span> {
                type: Syntax.BreakStatement,
                label: <span class="literal">null</span>
            };
        }

        <span class="keyword">if</span> (peekLineTerminator()) {
            <span class="keyword">if</span> (!(inIteration || inSwitch)) {
                throwError({}, Messages.IllegalBreak);
            }

            <span class="keyword">return</span> {
                type: Syntax.BreakStatement,
                label: <span class="literal">null</span>
            };
        }

        token = lookahead();
        <span class="keyword">if</span> (token.type === Token.Identifier) {
            label = parseVariableIdentifier();

            <span class="keyword">if</span> (!Object.prototype.hasOwnProperty.call(labelSet, label.name)) {
                throwError({}, Messages.UnknownLabel, label.name);
            }
        }

        consumeSemicolon();

        <span class="keyword">if</span> (label === <span class="literal">null</span> &amp;&amp; !(inIteration || inSwitch)) {
            throwError({}, Messages.IllegalBreak);
        }

        <span class="keyword">return</span> {
            type: Syntax.BreakStatement,
            label: label
        };
    }

    <span class="comment">// 12.9 The return statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseReturnStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, argument = <span class="literal">null</span>;

        expectKeyword(<span class="string">'return'</span>);

        <span class="keyword">if</span> (!inFunctionBody) {
            throwErrorTolerant({}, Messages.IllegalReturn);
        }

        <span class="comment">// 'return' followed by a space and an identifier is very common.</span>
        <span class="keyword">if</span> (source[index] === <span class="string">' '</span>) {
            <span class="keyword">if</span> (isIdentifierStart(source[index + <span class="number">1</span>])) {
                argument = parseExpression();
                consumeSemicolon();
                <span class="keyword">return</span> {
                    type: Syntax.ReturnStatement,
                    argument: argument
                };
            }
        }

        <span class="keyword">if</span> (peekLineTerminator()) {
            <span class="keyword">return</span> {
                type: Syntax.ReturnStatement,
                argument: <span class="literal">null</span>
            };
        }

        <span class="keyword">if</span> (!match(<span class="string">';'</span>)) {
            token = lookahead();
            <span class="keyword">if</span> (!match(<span class="string">'}'</span>) &amp;&amp; token.type !== Token.EOF) {
                argument = parseExpression();
            }
        }

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.ReturnStatement,
            argument: argument
        };
    }

    <span class="comment">// 12.10 The with statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseWithStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> object, body;

        <span class="keyword">if</span> (strict) {
            throwErrorTolerant({}, Messages.StrictModeWith);
        }

        expectKeyword(<span class="string">'with'</span>);

        expect(<span class="string">'('</span>);

        object = parseExpression();

        expect(<span class="string">')'</span>);

        body = parseStatement();

        <span class="keyword">return</span> {
            type: Syntax.WithStatement,
            object: object,
            body: body
        };
    }

    <span class="comment">// 12.10 The swith statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseSwitchCase</span><span class="params">(test)</span> {</span>
        <span class="keyword">var</span> consequent = [],
            statement;

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'}'</span>) || matchKeyword(<span class="string">'default'</span>) || matchKeyword(<span class="string">'case'</span>)) {
                <span class="keyword">break</span>;
            }
            statement = parseStatement();
            <span class="keyword">if</span> (<span class="keyword">typeof</span> statement === <span class="string">'undefined'</span>) {
                <span class="keyword">break</span>;
            }
            consequent.push(statement);
        }

        <span class="keyword">return</span> {
            type: Syntax.SwitchCase,
            test: test,
            consequent: consequent
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseSwitchStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> discriminant, cases, test, oldInSwitch;

        expectKeyword(<span class="string">'switch'</span>);

        expect(<span class="string">'('</span>);

        discriminant = parseExpression();

        expect(<span class="string">')'</span>);

        expect(<span class="string">'{'</span>);

        <span class="keyword">if</span> (match(<span class="string">'}'</span>)) {
            lex();
            <span class="keyword">return</span> {
                type: Syntax.SwitchStatement,
                discriminant: discriminant
            };
        }

        cases = [];

        oldInSwitch = inSwitch;
        inSwitch = <span class="literal">true</span>;

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'}'</span>)) {
                <span class="keyword">break</span>;
            }

            <span class="keyword">if</span> (matchKeyword(<span class="string">'default'</span>)) {
                lex();
                test = <span class="literal">null</span>;
            } <span class="keyword">else</span> {
                expectKeyword(<span class="string">'case'</span>);
                test = parseExpression();
            }
            expect(<span class="string">':'</span>);

            cases.push(parseSwitchCase(test));
        }

        inSwitch = oldInSwitch;

        expect(<span class="string">'}'</span>);

        <span class="keyword">return</span> {
            type: Syntax.SwitchStatement,
            discriminant: discriminant,
            cases: cases
        };
    }

    <span class="comment">// 12.13 The throw statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseThrowStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> argument;

        expectKeyword(<span class="string">'throw'</span>);

        <span class="keyword">if</span> (peekLineTerminator()) {
            throwError({}, Messages.NewlineAfterThrow);
        }

        argument = parseExpression();

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.ThrowStatement,
            argument: argument
        };
    }

    <span class="comment">// 12.14 The try statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseCatchClause</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> param;

        expectKeyword(<span class="string">'catch'</span>);

        expect(<span class="string">'('</span>);
        <span class="keyword">if</span> (!match(<span class="string">')'</span>)) {
            param = parseExpression();
            <span class="comment">// 12.14.1</span>
            <span class="keyword">if</span> (strict &amp;&amp; param.type === Syntax.Identifier &amp;&amp; isRestrictedWord(param.name)) {
                throwError({}, Messages.StrictCatchVariable);
            }
        }
        expect(<span class="string">')'</span>);

        <span class="keyword">return</span> {
            type: Syntax.CatchClause,
            param: param,
            guard: <span class="literal">null</span>,
            body: parseBlock()
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseTryStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> block, handlers = [], finalizer = <span class="literal">null</span>;

        expectKeyword(<span class="string">'try'</span>);

        block = parseBlock();

        <span class="keyword">if</span> (matchKeyword(<span class="string">'catch'</span>)) {
            handlers.push(parseCatchClause());
        }

        <span class="keyword">if</span> (matchKeyword(<span class="string">'finally'</span>)) {
            lex();
            finalizer = parseBlock();
        }

        <span class="keyword">if</span> (handlers.length === <span class="number">0</span> &amp;&amp; !finalizer) {
            throwError({}, Messages.NoCatchOrFinally);
        }

        <span class="keyword">return</span> {
            type: Syntax.TryStatement,
            block: block,
            handlers: handlers,
            finalizer: finalizer
        };
    }

    <span class="comment">// 12.15 The debugger statement</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseDebuggerStatement</span><span class="params">()</span> {</span>
        expectKeyword(<span class="string">'debugger'</span>);

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.DebuggerStatement
        };
    }

    <span class="comment">// 12 Statements</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseStatement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lookahead(),
            expr,
            labeledBody;

        <span class="keyword">if</span> (token.type === Token.EOF) {
            throwUnexpected(token);
        }

        <span class="keyword">if</span> (token.type === Token.Punctuator) {
            <span class="keyword">switch</span> (token.value) {
            <span class="keyword">case</span> <span class="string">';'</span>:
                <span class="keyword">return</span> parseEmptyStatement();
            <span class="keyword">case</span> <span class="string">'{'</span>:
                <span class="keyword">return</span> parseBlock();
            <span class="keyword">case</span> <span class="string">'('</span>:
                <span class="keyword">return</span> parseExpressionStatement();
            <span class="keyword">default</span>:
                <span class="keyword">break</span>;
            }
        }

        <span class="keyword">if</span> (token.type === Token.Keyword) {
            <span class="keyword">switch</span> (token.value) {
            <span class="keyword">case</span> <span class="string">'break'</span>:
                <span class="keyword">return</span> parseBreakStatement();
            <span class="keyword">case</span> <span class="string">'continue'</span>:
                <span class="keyword">return</span> parseContinueStatement();
            <span class="keyword">case</span> <span class="string">'debugger'</span>:
                <span class="keyword">return</span> parseDebuggerStatement();
            <span class="keyword">case</span> <span class="string">'do'</span>:
                <span class="keyword">return</span> parseDoWhileStatement();
            <span class="keyword">case</span> <span class="string">'for'</span>:
                <span class="keyword">return</span> parseForStatement();
            <span class="keyword">case</span> <span class="string">'function'</span>:
                <span class="keyword">return</span> parseFunctionDeclaration();
            <span class="keyword">case</span> <span class="string">'if'</span>:
                <span class="keyword">return</span> parseIfStatement();
            <span class="keyword">case</span> <span class="string">'return'</span>:
                <span class="keyword">return</span> parseReturnStatement();
            <span class="keyword">case</span> <span class="string">'switch'</span>:
                <span class="keyword">return</span> parseSwitchStatement();
            <span class="keyword">case</span> <span class="string">'throw'</span>:
                <span class="keyword">return</span> parseThrowStatement();
            <span class="keyword">case</span> <span class="string">'try'</span>:
                <span class="keyword">return</span> parseTryStatement();
            <span class="keyword">case</span> <span class="string">'var'</span>:
                <span class="keyword">return</span> parseVariableStatement();
            <span class="keyword">case</span> <span class="string">'while'</span>:
                <span class="keyword">return</span> parseWhileStatement();
            <span class="keyword">case</span> <span class="string">'with'</span>:
                <span class="keyword">return</span> parseWithStatement();
            <span class="keyword">default</span>:
                <span class="keyword">break</span>;
            }
        }

        expr = parseExpression();

        <span class="comment">// 12.12 Labelled Statements</span>
        <span class="keyword">if</span> ((expr.type === Syntax.Identifier) &amp;&amp; match(<span class="string">':'</span>)) {
            lex();

            <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(labelSet, expr.name)) {
                throwError({}, Messages.Redeclaration, <span class="string">'Label'</span>, expr.name);
            }

            labelSet[expr.name] = <span class="literal">true</span>;
            labeledBody = parseStatement();
            <span class="keyword">delete</span> labelSet[expr.name];

            <span class="keyword">return</span> {
                type: Syntax.LabeledStatement,
                label: expr,
                body: labeledBody
            };
        }

        consumeSemicolon();

        <span class="keyword">return</span> {
            type: Syntax.ExpressionStatement,
            expression: expr
        };
    }

    <span class="comment">// 13 Function Definition</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionSourceElements</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> sourceElement, sourceElements = [], token, directive, firstRestricted, oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody;

        expect(<span class="string">'{'</span>);

        <span class="keyword">while</span> (index &lt; length) {
            token = lookahead();
            <span class="keyword">if</span> (token.type !== Token.StringLiteral) {
                <span class="keyword">break</span>;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            <span class="keyword">if</span> (sourceElement.expression.type !== Syntax.Literal) {
                <span class="comment">// this is not directive</span>
                <span class="keyword">break</span>;
            }
            directive = sliceSource(token.range[<span class="number">0</span>] + <span class="number">1</span>, token.range[<span class="number">1</span>] - <span class="number">1</span>);
            <span class="keyword">if</span> (directive === <span class="string">'use strict'</span>) {
                strict = <span class="literal">true</span>;
                <span class="keyword">if</span> (firstRestricted) {
                    throwError(firstRestricted, Messages.StrictOctalLiteral);
                }
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }

        oldLabelSet = labelSet;
        oldInIteration = inIteration;
        oldInSwitch = inSwitch;
        oldInFunctionBody = inFunctionBody;

        labelSet = {};
        inIteration = <span class="literal">false</span>;
        inSwitch = <span class="literal">false</span>;
        inFunctionBody = <span class="literal">true</span>;

        <span class="keyword">while</span> (index &lt; length) {
            <span class="keyword">if</span> (match(<span class="string">'}'</span>)) {
                <span class="keyword">break</span>;
            }
            sourceElement = parseSourceElement();
            <span class="keyword">if</span> (<span class="keyword">typeof</span> sourceElement === <span class="string">'undefined'</span>) {
                <span class="keyword">break</span>;
            }
            sourceElements.push(sourceElement);
        }

        expect(<span class="string">'}'</span>);

        labelSet = oldLabelSet;
        inIteration = oldInIteration;
        inSwitch = oldInSwitch;
        inFunctionBody = oldInFunctionBody;

        <span class="keyword">return</span> {
            type: Syntax.BlockStatement,
            body: sourceElements
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionDeclaration</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> id, param, params = [], body, token, firstRestricted, message, previousStrict, paramSet;

        expectKeyword(<span class="string">'function'</span>);
        token = lookahead();
        id = parseVariableIdentifier();
        <span class="keyword">if</span> (strict) {
            <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                throwError(token, Messages.StrictFunctionName);
            }
        } <span class="keyword">else</span> {
            <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictFunctionName;
            } <span class="keyword">else</span> <span class="keyword">if</span> (isStrictModeReservedWord(token.value)) {
                firstRestricted = token;
                message = Messages.StrictReservedWord;
            }
        }

        expect(<span class="string">'('</span>);

        <span class="keyword">if</span> (!match(<span class="string">')'</span>)) {
            paramSet = {};
            <span class="keyword">while</span> (index &lt; length) {
                token = lookahead();
                param = parseVariableIdentifier();
                <span class="keyword">if</span> (strict) {
                    <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                        throwError(token, Messages.StrictParamName);
                    }
                    <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        throwError(token, Messages.StrictParamDupe);
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> (!firstRestricted) {
                    <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } <span class="keyword">else</span> <span class="keyword">if</span> (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } <span class="keyword">else</span> <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = <span class="literal">true</span>;
                <span class="keyword">if</span> (match(<span class="string">')'</span>)) {
                    <span class="keyword">break</span>;
                }
                expect(<span class="string">','</span>);
            }
        }

        expect(<span class="string">')'</span>);

        previousStrict = strict;
        body = parseFunctionSourceElements();
        <span class="keyword">if</span> (strict &amp;&amp; firstRestricted) {
            throwError(firstRestricted, message);
        }
        strict = previousStrict;

        <span class="keyword">return</span> {
            type: Syntax.FunctionDeclaration,
            id: id,
            params: params,
            body: body
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseFunctionExpression</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token, id = <span class="literal">null</span>, firstRestricted, message, param, params = [], body, previousStrict, paramSet;

        expectKeyword(<span class="string">'function'</span>);

        <span class="keyword">if</span> (!match(<span class="string">'('</span>)) {
            token = lookahead();
            id = parseVariableIdentifier();
            <span class="keyword">if</span> (strict) {
                <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                    throwError(token, Messages.StrictFunctionName);
                }
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictFunctionName;
                } <span class="keyword">else</span> <span class="keyword">if</span> (isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = Messages.StrictReservedWord;
                }
            }
        }

        expect(<span class="string">'('</span>);

        <span class="keyword">if</span> (!match(<span class="string">')'</span>)) {
            paramSet = {};
            <span class="keyword">while</span> (index &lt; length) {
                token = lookahead();
                param = parseVariableIdentifier();
                <span class="keyword">if</span> (strict) {
                    <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                        throwError(token, Messages.StrictParamName);
                    }
                    <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        throwError(token, Messages.StrictParamDupe);
                    }
                } <span class="keyword">else</span> <span class="keyword">if</span> (!firstRestricted) {
                    <span class="keyword">if</span> (isRestrictedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamName;
                    } <span class="keyword">else</span> <span class="keyword">if</span> (isStrictModeReservedWord(token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictReservedWord;
                    } <span class="keyword">else</span> <span class="keyword">if</span> (Object.prototype.hasOwnProperty.call(paramSet, token.value)) {
                        firstRestricted = token;
                        message = Messages.StrictParamDupe;
                    }
                }
                params.push(param);
                paramSet[param.name] = <span class="literal">true</span>;
                <span class="keyword">if</span> (match(<span class="string">')'</span>)) {
                    <span class="keyword">break</span>;
                }
                expect(<span class="string">','</span>);
            }
        }

        expect(<span class="string">')'</span>);

        previousStrict = strict;
        body = parseFunctionSourceElements();
        <span class="keyword">if</span> (strict &amp;&amp; firstRestricted) {
            throwError(firstRestricted, message);
        }
        strict = previousStrict;

        <span class="keyword">return</span> {
            type: Syntax.FunctionExpression,
            id: id,
            params: params,
            body: body
        };
    }

    <span class="comment">// 14 Program</span>

    <span class="function"><span class="keyword">function</span> <span class="title">parseSourceElement</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = lookahead();

        <span class="keyword">if</span> (token.type === Token.Keyword) {
            <span class="keyword">switch</span> (token.value) {
            <span class="keyword">case</span> <span class="string">'const'</span>:
            <span class="keyword">case</span> <span class="string">'let'</span>:
                <span class="keyword">return</span> parseConstLetDeclaration(token.value);
            <span class="keyword">case</span> <span class="string">'function'</span>:
                <span class="keyword">return</span> parseFunctionDeclaration();
            <span class="keyword">default</span>:
                <span class="keyword">return</span> parseStatement();
            }
        }

        <span class="keyword">if</span> (token.type !== Token.EOF) {
            <span class="keyword">return</span> parseStatement();
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseSourceElements</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> sourceElement, sourceElements = [], token, directive, firstRestricted;

        <span class="keyword">while</span> (index &lt; length) {
            token = lookahead();
            <span class="keyword">if</span> (token.type !== Token.StringLiteral) {
                <span class="keyword">break</span>;
            }

            sourceElement = parseSourceElement();
            sourceElements.push(sourceElement);
            <span class="keyword">if</span> (sourceElement.expression.type !== Syntax.Literal) {
                <span class="comment">// this is not directive</span>
                <span class="keyword">break</span>;
            }
            directive = sliceSource(token.range[<span class="number">0</span>] + <span class="number">1</span>, token.range[<span class="number">1</span>] - <span class="number">1</span>);
            <span class="keyword">if</span> (directive === <span class="string">'use strict'</span>) {
                strict = <span class="literal">true</span>;
                <span class="keyword">if</span> (firstRestricted) {
                    throwError(firstRestricted, Messages.StrictOctalLiteral);
                }
            } <span class="keyword">else</span> {
                <span class="keyword">if</span> (!firstRestricted &amp;&amp; token.octal) {
                    firstRestricted = token;
                }
            }
        }

        <span class="keyword">while</span> (index &lt; length) {
            sourceElement = parseSourceElement();
            <span class="keyword">if</span> (<span class="keyword">typeof</span> sourceElement === <span class="string">'undefined'</span>) {
                <span class="keyword">break</span>;
            }
            sourceElements.push(sourceElement);
        }
        <span class="keyword">return</span> sourceElements;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parseProgram</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> program;
        strict = <span class="literal">false</span>;
        program = {
            type: Syntax.Program,
            body: parseSourceElements()
        };
        <span class="keyword">return</span> program;
    }

    <span class="comment">// The following functions are needed only when the option to preserve</span>
    <span class="comment">// the comments is active.</span>

    <span class="function"><span class="keyword">function</span> <span class="title">addComment</span><span class="params">(start, end, type, value)</span> {</span>
        assert(<span class="keyword">typeof</span> start === <span class="string">'number'</span>, <span class="string">'Comment must have valid position'</span>);

        <span class="comment">// Because the way the actual token is scanned, often the comments</span>
        <span class="comment">// (if any) are skipped twice during the lexical analysis.</span>
        <span class="comment">// Thus, we need to skip adding a comment if the comment array already</span>
        <span class="comment">// handled it.</span>
        <span class="keyword">if</span> (extra.comments.length > <span class="number">0</span>) {
            <span class="keyword">if</span> (extra.comments[extra.comments.length - <span class="number">1</span>].range[<span class="number">1</span>] > start) {
                <span class="keyword">return</span>;
            }
        }

        extra.comments.push({
            range: [start, end],
            type: type,
            value: value
        });
    }

    <span class="function"><span class="keyword">function</span> <span class="title">scanComment</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> comment, ch, start, blockComment, lineComment;

        comment = <span class="string">''</span>;
        blockComment = <span class="literal">false</span>;
        lineComment = <span class="literal">false</span>;

        <span class="keyword">while</span> (index &lt; length) {
            ch = source[index];

            <span class="keyword">if</span> (lineComment) {
                ch = nextChar();
                <span class="keyword">if</span> (index >= length) {
                    lineComment = <span class="literal">false</span>;
                    comment += ch;
                    addComment(start, index - <span class="number">1</span>, <span class="string">'Line'</span>, comment);
                } <span class="keyword">else</span> <span class="keyword">if</span> (isLineTerminator(ch)) {
                    lineComment = <span class="literal">false</span>;
                    addComment(start, index - <span class="number">1</span>, <span class="string">'Line'</span>, comment);
                    <span class="keyword">if</span> (ch === <span class="string">'\r'</span> &amp;&amp; source[index] === <span class="string">'\n'</span>) {
                        ++index;
                    }
                    ++lineNumber;
                    lineStart = index;
                    comment = <span class="string">''</span>;
                } <span class="keyword">else</span> {
                    comment += ch;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (blockComment) {
                <span class="keyword">if</span> (isLineTerminator(ch)) {
                    <span class="keyword">if</span> (ch === <span class="string">'\r'</span> &amp;&amp; source[index + <span class="number">1</span>] === <span class="string">'\n'</span>) {
                        ++index;
                        comment += <span class="string">'\r\n'</span>;
                    } <span class="keyword">else</span> {
                        comment += ch;
                    }
                    ++lineNumber;
                    ++index;
                    lineStart = index;
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                } <span class="keyword">else</span> {
                    ch = nextChar();
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                    comment += ch;
                    <span class="keyword">if</span> (ch === <span class="string">'*'</span>) {
                        ch = source[index];
                        <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                            comment = comment.substr(<span class="number">0</span>, comment.length - <span class="number">1</span>);
                            blockComment = <span class="literal">false</span>;
                            ++index;
                            addComment(start, index - <span class="number">1</span>, <span class="string">'Block'</span>, comment);
                            comment = <span class="string">''</span>;
                        }
                    }
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                ch = source[index + <span class="number">1</span>];
                <span class="keyword">if</span> (ch === <span class="string">'/'</span>) {
                    start = index;
                    index += <span class="number">2</span>;
                    lineComment = <span class="literal">true</span>;
                } <span class="keyword">else</span> <span class="keyword">if</span> (ch === <span class="string">'*'</span>) {
                    start = index;
                    index += <span class="number">2</span>;
                    blockComment = <span class="literal">true</span>;
                    <span class="keyword">if</span> (index >= length) {
                        throwError({}, Messages.UnexpectedToken, <span class="string">'ILLEGAL'</span>);
                    }
                } <span class="keyword">else</span> {
                    <span class="keyword">break</span>;
                }
            } <span class="keyword">else</span> <span class="keyword">if</span> (isWhiteSpace(ch)) {
                ++index;
            } <span class="keyword">else</span> <span class="keyword">if</span> (isLineTerminator(ch)) {
                ++index;
                <span class="keyword">if</span> (ch ===  <span class="string">'\r'</span> &amp;&amp; source[index] === <span class="string">'\n'</span>) {
                    ++index;
                }
                ++lineNumber;
                lineStart = index;
            } <span class="keyword">else</span> {
                <span class="keyword">break</span>;
            }
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">collectToken</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> token = extra.advance(),
            range,
            value;

        <span class="keyword">if</span> (token.type !== Token.EOF) {
            range = [token.range[<span class="number">0</span>], token.range[<span class="number">1</span>] - <span class="number">1</span>];
            value = sliceSource(token.range[<span class="number">0</span>], token.range[<span class="number">1</span>]);
            extra.tokens.push({
                type: TokenName[token.type],
                value: value,
                range: range
            });
        }

        <span class="keyword">return</span> token;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">collectRegex</span><span class="params">()</span> {</span>
        <span class="keyword">var</span> pos, regex, token;

        skipComment();

        pos = index;
        regex = extra.scanRegExp();

        <span class="comment">// Pop the previous token, which is likely '/' or '/='</span>
        <span class="keyword">if</span> (extra.tokens.length > <span class="number">0</span>) {
            token = extra.tokens[extra.tokens.length - <span class="number">1</span>];
            <span class="keyword">if</span> (token.range[<span class="number">0</span>] === pos &amp;&amp; token.type === <span class="string">'Punctuator'</span>) {
                <span class="keyword">if</span> (token.value === <span class="string">'/'</span> || token.value === <span class="string">'/='</span>) {
                    extra.tokens.pop();
                }
            }
        }

        extra.tokens.push({
            type: <span class="string">'RegularExpression'</span>,
            value: regex.literal,
            range: [pos, index - <span class="number">1</span>]
        });

        <span class="keyword">return</span> regex;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">createLiteral</span><span class="params">(token)</span> {</span>
        <span class="keyword">return</span> {
            type: Syntax.Literal,
            value: token.value
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">createRawLiteral</span><span class="params">(token)</span> {</span>
        <span class="keyword">return</span> {
            type: Syntax.Literal,
            value: token.value,
            raw: sliceSource(token.range[<span class="number">0</span>], token.range[<span class="number">1</span>])
        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">wrapTrackingFunction</span><span class="params">(range, loc)</span> {</span>

        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(parseFunction)</span> {</span>

            <span class="function"><span class="keyword">function</span> <span class="title">isBinary</span><span class="params">(node)</span> {</span>
                <span class="keyword">return</span> node.type === Syntax.LogicalExpression ||
                    node.type === Syntax.BinaryExpression;
            }

            <span class="function"><span class="keyword">function</span> <span class="title">visit</span><span class="params">(node)</span> {</span>
                <span class="keyword">if</span> (isBinary(node.left)) {
                    visit(node.left);
                }
                <span class="keyword">if</span> (isBinary(node.right)) {
                    visit(node.right);
                }

                <span class="keyword">if</span> (range &amp;&amp; <span class="keyword">typeof</span> node.range === <span class="string">'undefined'</span>) {
                    node.range = [node.left.range[<span class="number">0</span>], node.right.range[<span class="number">1</span>]];
                }
                <span class="keyword">if</span> (loc &amp;&amp; <span class="keyword">typeof</span> node.loc === <span class="string">'undefined'</span>) {
                    node.loc = {
                        start: node.left.loc.start,
                        end: node.right.loc.end
                    };
                }
            }

            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
                <span class="keyword">var</span> node, rangeInfo, locInfo;

                skipComment();
                rangeInfo = [index, <span class="number">0</span>];
                locInfo = {
                    start: {
                        line: lineNumber,
                        column: index - lineStart
                    }
                };

                node = parseFunction.apply(<span class="literal">null</span>, arguments);
                <span class="keyword">if</span> (<span class="keyword">typeof</span> node !== <span class="string">'undefined'</span>) {

                    <span class="keyword">if</span> (range) {
                        rangeInfo[<span class="number">1</span>] = index - <span class="number">1</span>;
                        node.range = rangeInfo;
                    }

                    <span class="keyword">if</span> (loc) {
                        locInfo.end = {
                            line: lineNumber,
                            column: index - lineStart
                        };
                        node.loc = locInfo;
                    }

                    <span class="keyword">if</span> (isBinary(node)) {
                        visit(node);
                    }

                    <span class="keyword">if</span> (node.type === Syntax.MemberExpression) {
                        <span class="keyword">if</span> (<span class="keyword">typeof</span> node.object.range !== <span class="string">'undefined'</span>) {
                            node.range[<span class="number">0</span>] = node.object.range[<span class="number">0</span>];
                        }
                        <span class="keyword">if</span> (<span class="keyword">typeof</span> node.object.loc !== <span class="string">'undefined'</span>) {
                            node.loc.start = node.object.loc.start;
                        }
                    }
                    <span class="keyword">return</span> node;
                }
            };

        };
    }

    <span class="function"><span class="keyword">function</span> <span class="title">patch</span><span class="params">()</span> {</span>

        <span class="keyword">var</span> wrapTracking;

        <span class="keyword">if</span> (extra.comments) {
            extra.skipComment = skipComment;
            skipComment = scanComment;
        }

        <span class="keyword">if</span> (extra.raw) {
            extra.createLiteral = createLiteral;
            createLiteral = createRawLiteral;
        }

        <span class="keyword">if</span> (extra.range || extra.loc) {

            wrapTracking = wrapTrackingFunction(extra.range, extra.loc);

            extra.parseAdditiveExpression = parseAdditiveExpression;
            extra.parseAssignmentExpression = parseAssignmentExpression;
            extra.parseBitwiseANDExpression = parseBitwiseANDExpression;
            extra.parseBitwiseORExpression = parseBitwiseORExpression;
            extra.parseBitwiseXORExpression = parseBitwiseXORExpression;
            extra.parseBlock = parseBlock;
            extra.parseFunctionSourceElements = parseFunctionSourceElements;
            extra.parseCallMember = parseCallMember;
            extra.parseCatchClause = parseCatchClause;
            extra.parseComputedMember = parseComputedMember;
            extra.parseConditionalExpression = parseConditionalExpression;
            extra.parseConstLetDeclaration = parseConstLetDeclaration;
            extra.parseEqualityExpression = parseEqualityExpression;
            extra.parseExpression = parseExpression;
            extra.parseForVariableDeclaration = parseForVariableDeclaration;
            extra.parseFunctionDeclaration = parseFunctionDeclaration;
            extra.parseFunctionExpression = parseFunctionExpression;
            extra.parseLogicalANDExpression = parseLogicalANDExpression;
            extra.parseLogicalORExpression = parseLogicalORExpression;
            extra.parseMultiplicativeExpression = parseMultiplicativeExpression;
            extra.parseNewExpression = parseNewExpression;
            extra.parseNonComputedMember = parseNonComputedMember;
            extra.parseNonComputedProperty = parseNonComputedProperty;
            extra.parseObjectProperty = parseObjectProperty;
            extra.parseObjectPropertyKey = parseObjectPropertyKey;
            extra.parsePostfixExpression = parsePostfixExpression;
            extra.parsePrimaryExpression = parsePrimaryExpression;
            extra.parseProgram = parseProgram;
            extra.parsePropertyFunction = parsePropertyFunction;
            extra.parseRelationalExpression = parseRelationalExpression;
            extra.parseStatement = parseStatement;
            extra.parseShiftExpression = parseShiftExpression;
            extra.parseSwitchCase = parseSwitchCase;
            extra.parseUnaryExpression = parseUnaryExpression;
            extra.parseVariableDeclaration = parseVariableDeclaration;
            extra.parseVariableIdentifier = parseVariableIdentifier;

            parseAdditiveExpression = wrapTracking(extra.parseAdditiveExpression);
            parseAssignmentExpression = wrapTracking(extra.parseAssignmentExpression);
            parseBitwiseANDExpression = wrapTracking(extra.parseBitwiseANDExpression);
            parseBitwiseORExpression = wrapTracking(extra.parseBitwiseORExpression);
            parseBitwiseXORExpression = wrapTracking(extra.parseBitwiseXORExpression);
            parseBlock = wrapTracking(extra.parseBlock);
            parseFunctionSourceElements = wrapTracking(extra.parseFunctionSourceElements);
            parseCallMember = wrapTracking(extra.parseCallMember);
            parseCatchClause = wrapTracking(extra.parseCatchClause);
            parseComputedMember = wrapTracking(extra.parseComputedMember);
            parseConditionalExpression = wrapTracking(extra.parseConditionalExpression);
            parseConstLetDeclaration = wrapTracking(extra.parseConstLetDeclaration);
            parseEqualityExpression = wrapTracking(extra.parseEqualityExpression);
            parseExpression = wrapTracking(extra.parseExpression);
            parseForVariableDeclaration = wrapTracking(extra.parseForVariableDeclaration);
            parseFunctionDeclaration = wrapTracking(extra.parseFunctionDeclaration);
            parseFunctionExpression = wrapTracking(extra.parseFunctionExpression);
            parseLogicalANDExpression = wrapTracking(extra.parseLogicalANDExpression);
            parseLogicalORExpression = wrapTracking(extra.parseLogicalORExpression);
            parseMultiplicativeExpression = wrapTracking(extra.parseMultiplicativeExpression);
            parseNewExpression = wrapTracking(extra.parseNewExpression);
            parseNonComputedMember = wrapTracking(extra.parseNonComputedMember);
            parseNonComputedProperty = wrapTracking(extra.parseNonComputedProperty);
            parseObjectProperty = wrapTracking(extra.parseObjectProperty);
            parseObjectPropertyKey = wrapTracking(extra.parseObjectPropertyKey);
            parsePostfixExpression = wrapTracking(extra.parsePostfixExpression);
            parsePrimaryExpression = wrapTracking(extra.parsePrimaryExpression);
            parseProgram = wrapTracking(extra.parseProgram);
            parsePropertyFunction = wrapTracking(extra.parsePropertyFunction);
            parseRelationalExpression = wrapTracking(extra.parseRelationalExpression);
            parseStatement = wrapTracking(extra.parseStatement);
            parseShiftExpression = wrapTracking(extra.parseShiftExpression);
            parseSwitchCase = wrapTracking(extra.parseSwitchCase);
            parseUnaryExpression = wrapTracking(extra.parseUnaryExpression);
            parseVariableDeclaration = wrapTracking(extra.parseVariableDeclaration);
            parseVariableIdentifier = wrapTracking(extra.parseVariableIdentifier);
        }

        <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.tokens !== <span class="string">'undefined'</span>) {
            extra.advance = advance;
            extra.scanRegExp = scanRegExp;

            advance = collectToken;
            scanRegExp = collectRegex;
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">unpatch</span><span class="params">()</span> {</span>
        <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.skipComment === <span class="string">'function'</span>) {
            skipComment = extra.skipComment;
        }

        <span class="keyword">if</span> (extra.raw) {
            createLiteral = extra.createLiteral;
        }

        <span class="keyword">if</span> (extra.range || extra.loc) {
            parseAdditiveExpression = extra.parseAdditiveExpression;
            parseAssignmentExpression = extra.parseAssignmentExpression;
            parseBitwiseANDExpression = extra.parseBitwiseANDExpression;
            parseBitwiseORExpression = extra.parseBitwiseORExpression;
            parseBitwiseXORExpression = extra.parseBitwiseXORExpression;
            parseBlock = extra.parseBlock;
            parseFunctionSourceElements = extra.parseFunctionSourceElements;
            parseCallMember = extra.parseCallMember;
            parseCatchClause = extra.parseCatchClause;
            parseComputedMember = extra.parseComputedMember;
            parseConditionalExpression = extra.parseConditionalExpression;
            parseConstLetDeclaration = extra.parseConstLetDeclaration;
            parseEqualityExpression = extra.parseEqualityExpression;
            parseExpression = extra.parseExpression;
            parseForVariableDeclaration = extra.parseForVariableDeclaration;
            parseFunctionDeclaration = extra.parseFunctionDeclaration;
            parseFunctionExpression = extra.parseFunctionExpression;
            parseLogicalANDExpression = extra.parseLogicalANDExpression;
            parseLogicalORExpression = extra.parseLogicalORExpression;
            parseMultiplicativeExpression = extra.parseMultiplicativeExpression;
            parseNewExpression = extra.parseNewExpression;
            parseNonComputedMember = extra.parseNonComputedMember;
            parseNonComputedProperty = extra.parseNonComputedProperty;
            parseObjectProperty = extra.parseObjectProperty;
            parseObjectPropertyKey = extra.parseObjectPropertyKey;
            parsePrimaryExpression = extra.parsePrimaryExpression;
            parsePostfixExpression = extra.parsePostfixExpression;
            parseProgram = extra.parseProgram;
            parsePropertyFunction = extra.parsePropertyFunction;
            parseRelationalExpression = extra.parseRelationalExpression;
            parseStatement = extra.parseStatement;
            parseShiftExpression = extra.parseShiftExpression;
            parseSwitchCase = extra.parseSwitchCase;
            parseUnaryExpression = extra.parseUnaryExpression;
            parseVariableDeclaration = extra.parseVariableDeclaration;
            parseVariableIdentifier = extra.parseVariableIdentifier;
        }

        <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.scanRegExp === <span class="string">'function'</span>) {
            advance = extra.advance;
            scanRegExp = extra.scanRegExp;
        }
    }

    <span class="function"><span class="keyword">function</span> <span class="title">stringToArray</span><span class="params">(str)</span> {</span>
        <span class="keyword">var</span> length = str.length,
            result = [],
            i;
        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; ++i) {
            result[i] = str.charAt(i);
        }
        <span class="keyword">return</span> result;
    }

    <span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(code, options)</span> {</span>
        <span class="keyword">var</span> program, toString;

        toString = String;
        <span class="keyword">if</span> (<span class="keyword">typeof</span> code !== <span class="string">'string'</span> &amp;&amp; !(code <span class="keyword">instanceof</span> String)) {
            code = toString(code);
        }

        source = code;
        index = <span class="number">0</span>;
        lineNumber = (source.length > <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;
        lineStart = <span class="number">0</span>;
        length = source.length;
        buffer = <span class="literal">null</span>;
        allowIn = <span class="literal">true</span>;
        labelSet = {};
        inSwitch = <span class="literal">false</span>;
        inIteration = <span class="literal">false</span>;
        lastParenthesized = <span class="literal">null</span>;
        inFunctionBody = <span class="literal">false</span>;

        extra = {};
        <span class="keyword">if</span> (<span class="keyword">typeof</span> options !== <span class="string">'undefined'</span>) {
            extra.range = (<span class="keyword">typeof</span> options.range === <span class="string">'boolean'</span>) &amp;&amp; options.range;
            extra.loc = (<span class="keyword">typeof</span> options.loc === <span class="string">'boolean'</span>) &amp;&amp; options.loc;
            extra.raw = (<span class="keyword">typeof</span> options.raw === <span class="string">'boolean'</span>) &amp;&amp; options.raw;
            <span class="keyword">if</span> (<span class="keyword">typeof</span> options.tokens === <span class="string">'boolean'</span> &amp;&amp; options.tokens) {
                extra.tokens = [];
            }
            <span class="keyword">if</span> (<span class="keyword">typeof</span> options.comment === <span class="string">'boolean'</span> &amp;&amp; options.comment) {
                extra.comments = [];
            }
            <span class="keyword">if</span> (<span class="keyword">typeof</span> options.tolerant === <span class="string">'boolean'</span> &amp;&amp; options.tolerant) {
                extra.errors = [];
            }
        }

        <span class="keyword">if</span> (length > <span class="number">0</span>) {
            <span class="keyword">if</span> (<span class="keyword">typeof</span> source[<span class="number">0</span>] === <span class="string">'undefined'</span>) {
                <span class="comment">// Try first to convert to a string. This is good as fast path</span>
                <span class="comment">// for old IE which understands string indexing for string</span>
                <span class="comment">// literals only and not for string object.</span>
                <span class="keyword">if</span> (code <span class="keyword">instanceof</span> String) {
                    source = code.valueOf();
                }

                <span class="comment">// Force accessing the characters via an array.</span>
                <span class="keyword">if</span> (<span class="keyword">typeof</span> source[<span class="number">0</span>] === <span class="string">'undefined'</span>) {
                    source = stringToArray(code);
                }
            }
        }

        patch();
        <span class="keyword">try</span> {
            program = parseProgram();
            <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.comments !== <span class="string">'undefined'</span>) {
                program.comments = extra.comments;
            }
            <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.tokens !== <span class="string">'undefined'</span>) {
                program.tokens = extra.tokens;
            }
            <span class="keyword">if</span> (<span class="keyword">typeof</span> extra.errors !== <span class="string">'undefined'</span>) {
                program.errors = extra.errors;
            }
        } <span class="keyword">catch</span> (e) {
            <span class="keyword">throw</span> e;
        } <span class="keyword">finally</span> {
            unpatch();
            extra = {};
        }

        <span class="keyword">return</span> program;
    }

    <span class="comment">// Sync with package.json.</span>
    exports.version = <span class="string">'0.9.9'</span>;

    exports.parse = parse;

}(<span class="keyword">typeof</span> exports === <span class="string">'undefined'</span> ? (esprima = {}) : exports));
<span class="comment">/* vim: set sw=4 ts=4 et tw=80 : */</span>
</code></pre>