<h1>lexer.js</h1>
<pre><code class="lang-js"><span class="comment">// Generated by CoffeeScript 1.4.0</span>
(<span class="keyword">function</span>() {
  <span class="keyword">var</span> BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HEREDOC, HEREDOC_ILLEGAL, HEREDOC_INDENT, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDEXABLE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTILINER, MULTI_DENT, NOT_REGEX, NOT_SPACED_REGEX, NUMBER, OPERATOR, REGEX, RELATION, RESERVED, Rewriter, SHIFT, SIMPLESTR, STRICT_PROSCRIBED, TRAILING_SPACES, UNARY, WHITESPACE, compact, count, key, last, starts, _ref, _ref1,
    __indexOf = [].indexOf || <span class="keyword">function</span>(item) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) { <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>[i] === item) <span class="keyword">return</span> i; } <span class="keyword">return</span> -<span class="number">1</span>; };

  _ref = require(<span class="string">'./rewriter'</span>), Rewriter = _ref.Rewriter, INVERSES = _ref.INVERSES;

  _ref1 = require(<span class="string">'./helpers'</span>), count = _ref1.count, starts = _ref1.starts, compact = _ref1.compact, last = _ref1.last;

  exports.Lexer = Lexer = (<span class="keyword">function</span>() {

    <span class="function"><span class="keyword">function</span> <span class="title">Lexer</span><span class="params">()</span> {</span>}

    Lexer.prototype.tokenize = <span class="keyword">function</span>(code, opts) {
      <span class="keyword">var</span> i, tag;
      <span class="keyword">if</span> (opts == <span class="literal">null</span>) {
        opts = {};
      }
      <span class="keyword">if</span> (WHITESPACE.test(code)) {
        code = <span class="string">"\n"</span> + code;
      }
      code = code.replace(<span class="regexp">/\r/g</span>, <span class="string">''</span>).replace(TRAILING_SPACES, <span class="string">''</span>);
      <span class="keyword">this</span>.code = code;
      <span class="keyword">this</span>.line = opts.line || <span class="number">0</span>;
      <span class="keyword">this</span>.indent = <span class="number">0</span>;
      <span class="keyword">this</span>.indebt = <span class="number">0</span>;
      <span class="keyword">this</span>.outdebt = <span class="number">0</span>;
      <span class="keyword">this</span>.indents = [];
      <span class="keyword">this</span>.ends = [];
      <span class="keyword">this</span>.tokens = [];
      i = <span class="number">0</span>;
      <span class="keyword">while</span> (<span class="keyword">this</span>.chunk = code.slice(i)) {
        i += <span class="keyword">this</span>.identifierToken() || <span class="keyword">this</span>.commentToken() || <span class="keyword">this</span>.whitespaceToken() || <span class="keyword">this</span>.lineToken() || <span class="keyword">this</span>.heredocToken() || <span class="keyword">this</span>.stringToken() || <span class="keyword">this</span>.numberToken() || <span class="keyword">this</span>.regexToken() || <span class="keyword">this</span>.jsToken() || <span class="keyword">this</span>.literalToken();
      }
      <span class="keyword">this</span>.closeIndentation();
      <span class="keyword">if</span> (tag = <span class="keyword">this</span>.ends.pop()) {
        <span class="keyword">this</span>.error(<span class="string">"missing "</span> + tag);
      }
      <span class="keyword">if</span> (opts.rewrite === <span class="literal">false</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens;
      }
      <span class="keyword">return</span> (<span class="keyword">new</span> Rewriter).rewrite(<span class="keyword">this</span>.tokens);
    };

    Lexer.prototype.identifierToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> colon, forcedIdentifier, id, input, match, prev, tag, _ref2, _ref3;
      <span class="keyword">if</span> (!(match = IDENTIFIER.exec(<span class="keyword">this</span>.chunk))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      input = match[<span class="number">0</span>], id = match[<span class="number">1</span>], colon = match[<span class="number">2</span>];
      <span class="keyword">if</span> (id === <span class="string">'own'</span> &amp;&amp; <span class="keyword">this</span>.tag() === <span class="string">'FOR'</span>) {
        <span class="keyword">this</span>.token(<span class="string">'OWN'</span>, id);
        <span class="keyword">return</span> id.length;
      }
      forcedIdentifier = colon || (prev = last(<span class="keyword">this</span>.tokens)) &amp;&amp; (((_ref2 = prev[<span class="number">0</span>]) === <span class="string">'.'</span> || _ref2 === <span class="string">'?.'</span> || _ref2 === <span class="string">'::'</span>) || !prev.spaced &amp;&amp; prev[<span class="number">0</span>] === <span class="string">'@'</span>);
      tag = <span class="string">'IDENTIFIER'</span>;
      <span class="keyword">if</span> (!forcedIdentifier &amp;&amp; (__indexOf.call(JS_KEYWORDS, id) >= <span class="number">0</span> || __indexOf.call(COFFEE_KEYWORDS, id) >= <span class="number">0</span>)) {
        tag = id.toUpperCase();
        <span class="keyword">if</span> (tag === <span class="string">'WHEN'</span> &amp;&amp; (_ref3 = <span class="keyword">this</span>.tag(), __indexOf.call(LINE_BREAK, _ref3) >= <span class="number">0</span>)) {
          tag = <span class="string">'LEADING_WHEN'</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">'FOR'</span>) {
          <span class="keyword">this</span>.seenFor = <span class="literal">true</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (tag === <span class="string">'UNLESS'</span>) {
          tag = <span class="string">'IF'</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (__indexOf.call(UNARY, tag) >= <span class="number">0</span>) {
          tag = <span class="string">'UNARY'</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (__indexOf.call(RELATION, tag) >= <span class="number">0</span>) {
          <span class="keyword">if</span> (tag !== <span class="string">'INSTANCEOF'</span> &amp;&amp; <span class="keyword">this</span>.seenFor) {
            tag = <span class="string">'FOR'</span> + tag;
            <span class="keyword">this</span>.seenFor = <span class="literal">false</span>;
          } <span class="keyword">else</span> {
            tag = <span class="string">'RELATION'</span>;
            <span class="keyword">if</span> (<span class="keyword">this</span>.value() === <span class="string">'!'</span>) {
              <span class="keyword">this</span>.tokens.pop();
              id = <span class="string">'!'</span> + id;
            }
          }
        }
      }
      <span class="keyword">if</span> (__indexOf.call(JS_FORBIDDEN, id) >= <span class="number">0</span>) {
        <span class="keyword">if</span> (forcedIdentifier) {
          tag = <span class="string">'IDENTIFIER'</span>;
          id = <span class="keyword">new</span> String(id);
          id.reserved = <span class="literal">true</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (__indexOf.call(RESERVED, id) >= <span class="number">0</span>) {
          <span class="keyword">this</span>.error(<span class="string">"reserved word \""</span> + id + <span class="string">"\""</span>);
        }
      }
      <span class="keyword">if</span> (!forcedIdentifier) {
        <span class="keyword">if</span> (__indexOf.call(COFFEE_ALIASES, id) >= <span class="number">0</span>) {
          id = COFFEE_ALIAS_MAP[id];
        }
        tag = (<span class="keyword">function</span>() {
          <span class="keyword">switch</span> (id) {
            <span class="keyword">case</span> <span class="string">'!'</span>:
              <span class="keyword">return</span> <span class="string">'UNARY'</span>;
            <span class="keyword">case</span> <span class="string">'=='</span>:
            <span class="keyword">case</span> <span class="string">'!='</span>:
              <span class="keyword">return</span> <span class="string">'COMPARE'</span>;
            <span class="keyword">case</span> <span class="string">'&amp;&amp;'</span>:
            <span class="keyword">case</span> <span class="string">'||'</span>:
              <span class="keyword">return</span> <span class="string">'LOGIC'</span>;
            <span class="keyword">case</span> <span class="string">'true'</span>:
            <span class="keyword">case</span> <span class="string">'false'</span>:
              <span class="keyword">return</span> <span class="string">'BOOL'</span>;
            <span class="keyword">case</span> <span class="string">'break'</span>:
            <span class="keyword">case</span> <span class="string">'continue'</span>:
              <span class="keyword">return</span> <span class="string">'STATEMENT'</span>;
            <span class="keyword">default</span>:
              <span class="keyword">return</span> tag;
          }
        })();
      }
      <span class="keyword">this</span>.token(tag, id);
      <span class="keyword">if</span> (colon) {
        <span class="keyword">this</span>.token(<span class="string">':'</span>, <span class="string">':'</span>);
      }
      <span class="keyword">return</span> input.length;
    };

    Lexer.prototype.numberToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> binaryLiteral, lexedLength, match, number, octalLiteral;
      <span class="keyword">if</span> (!(match = NUMBER.exec(<span class="keyword">this</span>.chunk))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      number = match[<span class="number">0</span>];
      <span class="keyword">if</span> (<span class="regexp">/^0[BOX]/</span>.test(number)) {
        <span class="keyword">this</span>.error(<span class="string">"radix prefix '"</span> + number + <span class="string">"' must be lowercase"</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/E/</span>.test(number) &amp;&amp; !<span class="regexp">/^0x/</span>.test(number)) {
        <span class="keyword">this</span>.error(<span class="string">"exponential notation '"</span> + number + <span class="string">"' must be indicated with a lowercase 'e'"</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^0\d*[89]/</span>.test(number)) {
        <span class="keyword">this</span>.error(<span class="string">"decimal literal '"</span> + number + <span class="string">"' must not be prefixed with '0'"</span>);
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^0\d+/</span>.test(number)) {
        <span class="keyword">this</span>.error(<span class="string">"octal literal '"</span> + number + <span class="string">"' must be prefixed with '0o'"</span>);
      }
      lexedLength = number.length;
      <span class="keyword">if</span> (octalLiteral = <span class="regexp">/^0o([0-7]+)/</span>.exec(number)) {
        number = <span class="string">'0x'</span> + (parseInt(octalLiteral[<span class="number">1</span>], <span class="number">8</span>)).toString(<span class="number">16</span>);
      }
      <span class="keyword">if</span> (binaryLiteral = <span class="regexp">/^0b([01]+)/</span>.exec(number)) {
        number = <span class="string">'0x'</span> + (parseInt(binaryLiteral[<span class="number">1</span>], <span class="number">2</span>)).toString(<span class="number">16</span>);
      }
      <span class="keyword">this</span>.token(<span class="string">'NUMBER'</span>, number);
      <span class="keyword">return</span> lexedLength;
    };

    Lexer.prototype.stringToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> match, octalEsc, string;
      <span class="keyword">switch</span> (<span class="keyword">this</span>.chunk.charAt(<span class="number">0</span>)) {
        <span class="keyword">case</span> <span class="string">"'"</span>:
          <span class="keyword">if</span> (!(match = SIMPLESTR.exec(<span class="keyword">this</span>.chunk))) {
            <span class="keyword">return</span> <span class="number">0</span>;
          }
          <span class="keyword">this</span>.token(<span class="string">'STRING'</span>, (string = match[<span class="number">0</span>]).replace(MULTILINER, <span class="string">'\\\n'</span>));
          <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="string">'"'</span>:
          <span class="keyword">if</span> (!(string = <span class="keyword">this</span>.balancedString(<span class="keyword">this</span>.chunk, <span class="string">'"'</span>))) {
            <span class="keyword">return</span> <span class="number">0</span>;
          }
          <span class="keyword">if</span> (<span class="number">0</span> &lt; string.indexOf(<span class="string">'#{'</span>, <span class="number">1</span>)) {
            <span class="keyword">this</span>.interpolateString(string.slice(<span class="number">1</span>, -<span class="number">1</span>));
          } <span class="keyword">else</span> {
            <span class="keyword">this</span>.token(<span class="string">'STRING'</span>, <span class="keyword">this</span>.escapeLines(string));
          }
          <span class="keyword">break</span>;
        <span class="keyword">default</span>:
          <span class="keyword">return</span> <span class="number">0</span>;
      }
      <span class="keyword">if</span> (octalEsc = <span class="regexp">/^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/</span>.test(string)) {
        <span class="keyword">this</span>.error(<span class="string">"octal escape sequences "</span> + string + <span class="string">" are not allowed"</span>);
      }
      <span class="keyword">this</span>.line += count(string, <span class="string">'\n'</span>);
      <span class="keyword">return</span> string.length;
    };

    Lexer.prototype.heredocToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> doc, heredoc, match, quote;
      <span class="keyword">if</span> (!(match = HEREDOC.exec(<span class="keyword">this</span>.chunk))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      heredoc = match[<span class="number">0</span>];
      quote = heredoc.charAt(<span class="number">0</span>);
      doc = <span class="keyword">this</span>.sanitizeHeredoc(match[<span class="number">2</span>], {
        quote: quote,
        indent: <span class="literal">null</span>
      });
      <span class="keyword">if</span> (quote === <span class="string">'"'</span> &amp;&amp; <span class="number">0</span> &lt;= doc.indexOf(<span class="string">'#{'</span>)) {
        <span class="keyword">this</span>.interpolateString(doc, {
          heredoc: <span class="literal">true</span>
        });
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.token(<span class="string">'STRING'</span>, <span class="keyword">this</span>.makeString(doc, quote, <span class="literal">true</span>));
      }
      <span class="keyword">this</span>.line += count(heredoc, <span class="string">'\n'</span>);
      <span class="keyword">return</span> heredoc.length;
    };

    Lexer.prototype.commentToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> comment, here, match;
      <span class="keyword">if</span> (!(match = <span class="keyword">this</span>.chunk.match(COMMENT))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      comment = match[<span class="number">0</span>], here = match[<span class="number">1</span>];
      <span class="keyword">if</span> (here) {
        <span class="keyword">this</span>.token(<span class="string">'HERECOMMENT'</span>, <span class="keyword">this</span>.sanitizeHeredoc(here, {
          herecomment: <span class="literal">true</span>,
          indent: Array(<span class="keyword">this</span>.indent + <span class="number">1</span>).join(<span class="string">' '</span>)
        }));
      }
      <span class="keyword">this</span>.line += count(comment, <span class="string">'\n'</span>);
      <span class="keyword">return</span> comment.length;
    };

    Lexer.prototype.jsToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> match, script;
      <span class="keyword">if</span> (!(<span class="keyword">this</span>.chunk.charAt(<span class="number">0</span>) === <span class="string">'`'</span> &amp;&amp; (match = JSTOKEN.exec(<span class="keyword">this</span>.chunk)))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      <span class="keyword">this</span>.token(<span class="string">'JS'</span>, (script = match[<span class="number">0</span>]).slice(<span class="number">1</span>, -<span class="number">1</span>));
      <span class="keyword">this</span>.line += count(script, <span class="string">'\n'</span>);
      <span class="keyword">return</span> script.length;
    };

    Lexer.prototype.regexToken = <span class="keyword">function</span>() {
      <span class="keyword">var</span> flags, length, match, prev, regex, _ref2, _ref3;
      <span class="keyword">if</span> (<span class="keyword">this</span>.chunk.charAt(<span class="number">0</span>) !== <span class="string">'/'</span>) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      <span class="keyword">if</span> (match = HEREGEX.exec(<span class="keyword">this</span>.chunk)) {
        length = <span class="keyword">this</span>.heregexToken(match);
        <span class="keyword">this</span>.line += count(match[<span class="number">0</span>], <span class="string">'\n'</span>);
        <span class="keyword">return</span> length;
      }
      prev = last(<span class="keyword">this</span>.tokens);
      <span class="keyword">if</span> (prev &amp;&amp; (_ref2 = prev[<span class="number">0</span>], __indexOf.call((prev.spaced ? NOT_REGEX : NOT_SPACED_REGEX), _ref2) >= <span class="number">0</span>)) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      <span class="keyword">if</span> (!(match = REGEX.exec(<span class="keyword">this</span>.chunk))) {
        <span class="keyword">return</span> <span class="number">0</span>;
      }
      _ref3 = match, match = _ref3[<span class="number">0</span>], regex = _ref3[<span class="number">1</span>], flags = _ref3[<span class="number">2</span>];
      <span class="keyword">if</span> (regex.slice(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">'/*'</span>) {
        <span class="keyword">this</span>.error(<span class="string">'regular expressions cannot begin with `*`'</span>);
      }
      <span class="keyword">if</span> (regex === <span class="string">'//'</span>) {
        regex = <span class="string">'/(?:)/'</span>;
      }
      <span class="keyword">this</span>.token(<span class="string">'REGEX'</span>, <span class="string">""</span> + regex + flags);
      <span class="keyword">return</span> match.length;
    };

    Lexer.prototype.heregexToken = <span class="keyword">function</span>(match) {
      <span class="keyword">var</span> body, flags, heregex, re, tag, tokens, value, _i, _len, _ref2, _ref3, _ref4, _ref5;
      heregex = match[<span class="number">0</span>], body = match[<span class="number">1</span>], flags = match[<span class="number">2</span>];
      <span class="keyword">if</span> (<span class="number">0</span> > body.indexOf(<span class="string">'#{'</span>)) {
        re = body.replace(HEREGEX_OMIT, <span class="string">''</span>).replace(<span class="regexp">/\//g</span>, <span class="string">'\\/'</span>);
        <span class="keyword">if</span> (re.match(<span class="regexp">/^\*/</span>)) {
          <span class="keyword">this</span>.error(<span class="string">'regular expressions cannot begin with `*`'</span>);
        }
        <span class="keyword">this</span>.token(<span class="string">'REGEX'</span>, <span class="string">"/"</span> + (re || <span class="string">'(?:)'</span>) + <span class="string">"/"</span> + flags);
        <span class="keyword">return</span> heregex.length;
      }
      <span class="keyword">this</span>.token(<span class="string">'IDENTIFIER'</span>, <span class="string">'RegExp'</span>);
      <span class="keyword">this</span>.tokens.push([<span class="string">'CALL_START'</span>, <span class="string">'('</span>]);
      tokens = [];
      _ref2 = <span class="keyword">this</span>.interpolateString(body, {
        regex: <span class="literal">true</span>
      });
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        _ref3 = _ref2[_i], tag = _ref3[<span class="number">0</span>], value = _ref3[<span class="number">1</span>];
        <span class="keyword">if</span> (tag === <span class="string">'TOKENS'</span>) {
          tokens.push.apply(tokens, value);
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (!(value = value.replace(HEREGEX_OMIT, <span class="string">''</span>))) {
            <span class="keyword">continue</span>;
          }
          value = value.replace(<span class="regexp">/\\/g, '\\\\');
          tokens.push(['STRING', this.makeString(value, '"', true)]);
        }
        tokens.push(['+', '+']);
      }
      tokens.pop();
      if (((_ref4 = tokens[0]) != null ? _ref4[0] : void 0) !== 'STRING') {
        this.tokens.push(['STRING', '""'], ['+', '+']);
      }
      (_ref5 = this.tokens).push.apply(_ref5, tokens);
      if (flags) {
        this.tokens.push([',', ','], ['STRING', '"' + flags + '"']);
      }
      this.token(')', ')');
      return heregex.length;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      this.line += count(indent, '\n');
      this.seenFor = false;
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken();
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff);
        this.indents.push(diff);
        this.ends.push('OUTDENT');
        this.outdebt = this.indebt = 0;
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines);
      }
      this.indent = size;
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines) {
      var dent, len;
      while (moveOut > 0) {
        len = this.indents.length - 1;
        if (this.indents[len] === void 0) {
          moveOut = 0;
        } else if (this.indents[len] === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (this.indents[len] &lt; this.outdebt) {
          this.outdebt -= this.indents[len];
          moveOut -= this.indents[len];
        } else {
          dent = this.indents.pop() - this.outdebt;
          moveOut -= dent;
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', dent);
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        this.token('TERMINATOR', '\n');
      }
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function() {
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n');
      }
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === '\\') {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, tag, value, _ref2, _ref3, _ref4, _ref5;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = last(this.tokens);
      if (value === '=' &amp;&amp; prev) {
        if (!prev[1].reserved &amp;&amp; (_ref2 = prev[1], __indexOf.call(JS_FORBIDDEN, _ref2) >= 0)) {
          this.error("reserved word \"" + (this.value()) + "\" can't be assigned");
        }
        if ((_ref3 = prev[1]) === '||' || _ref3 === '&amp;&amp;') {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
        }
      }
      if (value === ';') {
        this.seenFor = false;
        tag = 'TERMINATOR';
      } else if (__indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (__indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (__indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (__indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (__indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (__indexOf.call(LOGIC, value) >= 0 || value === '?' &amp;&amp; (prev != null ? prev.spaced : void 0)) {
        tag = 'LOGIC';
      } else if (prev &amp;&amp; !prev.spaced) {
        if (value === '(' &amp;&amp; (_ref4 = prev[0], __indexOf.call(CALLABLE, _ref4) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' &amp;&amp; (_ref5 = prev[0], __indexOf.call(INDEXABLE, _ref5) >= 0)) {
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push(INVERSES[value]);
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeHeredoc = function(doc, options) {
      var attempt, herecomment, indent, match, _ref2;
      indent = options.indent, herecomment = options.herecomment;
      if (herecomment) {
        if (HEREDOC_ILLEGAL.test(doc)) {
          this.error("block comment cannot contain \"*/</span>\<span class="string">", starting"</span>);
        }
        <span class="keyword">if</span> (doc.indexOf(<span class="string">'\n'</span>) &lt;= <span class="number">0</span>) {
          <span class="keyword">return</span> doc;
        }
      } <span class="keyword">else</span> {
        <span class="keyword">while</span> (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[<span class="number">1</span>];
          <span class="keyword">if</span> (indent === <span class="literal">null</span> || (<span class="number">0</span> &lt; (_ref2 = attempt.length) &amp;&amp; _ref2 &lt; indent.length)) {
            indent = attempt;
          }
        }
      }
      <span class="keyword">if</span> (indent) {
        doc = doc.replace(RegExp(<span class="string">"\\n"</span> + indent, <span class="string">"g"</span>), <span class="string">'\n'</span>);
      }
      <span class="keyword">if</span> (!herecomment) {
        doc = doc.replace(<span class="regexp">/^\n/</span>, <span class="string">''</span>);
      }
      <span class="keyword">return</span> doc;
    };

    Lexer.prototype.tagParameters = <span class="keyword">function</span>() {
      <span class="keyword">var</span> i, stack, tok, tokens;
      <span class="keyword">if</span> (<span class="keyword">this</span>.tag() !== <span class="string">')'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      stack = [];
      tokens = <span class="keyword">this</span>.tokens;
      i = tokens.length;
      tokens[--i][<span class="number">0</span>] = <span class="string">'PARAM_END'</span>;
      <span class="keyword">while</span> (tok = tokens[--i]) {
        <span class="keyword">switch</span> (tok[<span class="number">0</span>]) {
          <span class="keyword">case</span> <span class="string">')'</span>:
            stack.push(tok);
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="string">'('</span>:
          <span class="keyword">case</span> <span class="string">'CALL_START'</span>:
            <span class="keyword">if</span> (stack.length) {
              stack.pop();
            } <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] === <span class="string">'('</span>) {
              tok[<span class="number">0</span>] = <span class="string">'PARAM_START'</span>;
              <span class="keyword">return</span> <span class="keyword">this</span>;
            } <span class="keyword">else</span> {
              <span class="keyword">return</span> <span class="keyword">this</span>;
            }
        }
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Lexer.prototype.closeIndentation = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.outdentToken(<span class="keyword">this</span>.indent);
    };

    Lexer.prototype.balancedString = <span class="keyword">function</span>(str, end) {
      <span class="keyword">var</span> continueCount, i, letter, match, prev, stack, _i, _ref2;
      continueCount = <span class="number">0</span>;
      stack = [end];
      <span class="keyword">for</span> (i = _i = <span class="number">1</span>, _ref2 = str.length; <span class="number">1</span> &lt;= _ref2 ? _i &lt; _ref2 : _i > _ref2; i = <span class="number">1</span> &lt;= _ref2 ? ++_i : --_i) {
        <span class="keyword">if</span> (continueCount) {
          --continueCount;
          <span class="keyword">continue</span>;
        }
        <span class="keyword">switch</span> (letter = str.charAt(i)) {
          <span class="keyword">case</span> <span class="string">'\\'</span>:
            ++continueCount;
            <span class="keyword">continue</span>;
          <span class="keyword">case</span> end:
            stack.pop();
            <span class="keyword">if</span> (!stack.length) {
              <span class="keyword">return</span> str.slice(<span class="number">0</span>, +i + <span class="number">1</span> || <span class="number">9e9</span>);
            }
            end = stack[stack.length - <span class="number">1</span>];
            <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span> (end === <span class="string">'}'</span> &amp;&amp; (letter === <span class="string">'"'</span> || letter === <span class="string">"'"</span>)) {
          stack.push(end = letter);
        } <span class="keyword">else</span> <span class="keyword">if</span> (end === <span class="string">'}'</span> &amp;&amp; letter === <span class="string">'/'</span> &amp;&amp; (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
          continueCount += match[<span class="number">0</span>].length - <span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (end === <span class="string">'}'</span> &amp;&amp; letter === <span class="string">'{'</span>) {
          stack.push(end = <span class="string">'}'</span>);
        } <span class="keyword">else</span> <span class="keyword">if</span> (end === <span class="string">'"'</span> &amp;&amp; prev === <span class="string">'#'</span> &amp;&amp; letter === <span class="string">'{'</span>) {
          stack.push(end = <span class="string">'}'</span>);
        }
        prev = letter;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="string">"missing "</span> + (stack.pop()) + <span class="string">", starting"</span>);
    };

    Lexer.prototype.interpolateString = <span class="keyword">function</span>(str, options) {
      <span class="keyword">var</span> expr, heredoc, i, inner, interpolated, len, letter, nested, pi, regex, tag, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      <span class="keyword">if</span> (options == <span class="literal">null</span>) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex;
      tokens = [];
      pi = <span class="number">0</span>;
      i = -<span class="number">1</span>;
      <span class="keyword">while</span> (letter = str.charAt(i += <span class="number">1</span>)) {
        <span class="keyword">if</span> (letter === <span class="string">'\\'</span>) {
          i += <span class="number">1</span>;
          <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span> (!(letter === <span class="string">'#'</span> &amp;&amp; str.charAt(i + <span class="number">1</span>) === <span class="string">'{'</span> &amp;&amp; (expr = <span class="keyword">this</span>.balancedString(str.slice(i + <span class="number">1</span>), <span class="string">'}'</span>)))) {
          <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span> (pi &lt; i) {
          tokens.push([<span class="string">'NEOSTRING'</span>, str.slice(pi, i)]);
        }
        inner = expr.slice(<span class="number">1</span>, -<span class="number">1</span>);
        <span class="keyword">if</span> (inner.length) {
          nested = <span class="keyword">new</span> Lexer().tokenize(inner, {
            line: <span class="keyword">this</span>.line,
            rewrite: <span class="literal">false</span>
          });
          nested.pop();
          <span class="keyword">if</span> (((_ref2 = nested[<span class="number">0</span>]) != <span class="literal">null</span> ? _ref2[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>) === <span class="string">'TERMINATOR'</span>) {
            nested.shift();
          }
          <span class="keyword">if</span> (len = nested.length) {
            <span class="keyword">if</span> (len > <span class="number">1</span>) {
              nested.unshift([<span class="string">'('</span>, <span class="string">'('</span>, <span class="keyword">this</span>.line]);
              nested.push([<span class="string">')'</span>, <span class="string">')'</span>, <span class="keyword">this</span>.line]);
            }
            tokens.push([<span class="string">'TOKENS'</span>, nested]);
          }
        }
        i += expr.length;
        pi = i + <span class="number">1</span>;
      }
      <span class="keyword">if</span> ((i > pi &amp;&amp; pi &lt; str.length)) {
        tokens.push([<span class="string">'NEOSTRING'</span>, str.slice(pi)]);
      }
      <span class="keyword">if</span> (regex) {
        <span class="keyword">return</span> tokens;
      }
      <span class="keyword">if</span> (!tokens.length) {
        <span class="keyword">return</span> <span class="keyword">this</span>.token(<span class="string">'STRING'</span>, <span class="string">'""'</span>);
      }
      <span class="keyword">if</span> (tokens[<span class="number">0</span>][<span class="number">0</span>] !== <span class="string">'NEOSTRING'</span>) {
        tokens.unshift([<span class="string">''</span>, <span class="string">''</span>]);
      }
      <span class="keyword">if</span> (interpolated = tokens.length > <span class="number">1</span>) {
        <span class="keyword">this</span>.token(<span class="string">'('</span>, <span class="string">'('</span>);
      }
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = tokens.length; _i &lt; _len; i = ++_i) {
        _ref3 = tokens[i], tag = _ref3[<span class="number">0</span>], value = _ref3[<span class="number">1</span>];
        <span class="keyword">if</span> (i) {
          <span class="keyword">this</span>.token(<span class="string">'+'</span>, <span class="string">'+'</span>);
        }
        <span class="keyword">if</span> (tag === <span class="string">'TOKENS'</span>) {
          (_ref4 = <span class="keyword">this</span>.tokens).push.apply(_ref4, value);
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.token(<span class="string">'STRING'</span>, <span class="keyword">this</span>.makeString(value, <span class="string">'"'</span>, heredoc));
        }
      }
      <span class="keyword">if</span> (interpolated) {
        <span class="keyword">this</span>.token(<span class="string">')'</span>, <span class="string">')'</span>);
      }
      <span class="keyword">return</span> tokens;
    };

    Lexer.prototype.pair = <span class="keyword">function</span>(tag) {
      <span class="keyword">var</span> size, wanted;
      <span class="keyword">if</span> (tag !== (wanted = last(<span class="keyword">this</span>.ends))) {
        <span class="keyword">if</span> (<span class="string">'OUTDENT'</span> !== wanted) {
          <span class="keyword">this</span>.error(<span class="string">"unmatched "</span> + tag);
        }
        <span class="keyword">this</span>.indent -= size = last(<span class="keyword">this</span>.indents);
        <span class="keyword">this</span>.outdentToken(size, <span class="literal">true</span>);
        <span class="keyword">return</span> <span class="keyword">this</span>.pair(tag);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.ends.pop();
    };

    Lexer.prototype.token = <span class="keyword">function</span>(tag, value) {
      <span class="keyword">return</span> <span class="keyword">this</span>.tokens.push([tag, value, <span class="keyword">this</span>.line]);
    };

    Lexer.prototype.tag = <span class="keyword">function</span>(index, tag) {
      <span class="keyword">var</span> tok;
      <span class="keyword">return</span> (tok = last(<span class="keyword">this</span>.tokens, index)) &amp;&amp; (tag ? tok[<span class="number">0</span>] = tag : tok[<span class="number">0</span>]);
    };

    Lexer.prototype.value = <span class="keyword">function</span>(index, val) {
      <span class="keyword">var</span> tok;
      <span class="keyword">return</span> (tok = last(<span class="keyword">this</span>.tokens, index)) &amp;&amp; (val ? tok[<span class="number">1</span>] = val : tok[<span class="number">1</span>]);
    };

    Lexer.prototype.unfinished = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> LINE_CONTINUER.test(<span class="keyword">this</span>.chunk) || ((_ref2 = <span class="keyword">this</span>.tag()) === <span class="string">'\\'</span> || _ref2 === <span class="string">'.'</span> || _ref2 === <span class="string">'?.'</span> || _ref2 === <span class="string">'UNARY'</span> || _ref2 === <span class="string">'MATH'</span> || _ref2 === <span class="string">'+'</span> || _ref2 === <span class="string">'-'</span> || _ref2 === <span class="string">'SHIFT'</span> || _ref2 === <span class="string">'RELATION'</span> || _ref2 === <span class="string">'COMPARE'</span> || _ref2 === <span class="string">'LOGIC'</span> || _ref2 === <span class="string">'THROW'</span> || _ref2 === <span class="string">'EXTENDS'</span>);
    };

    Lexer.prototype.escapeLines = <span class="keyword">function</span>(str, heredoc) {
      <span class="keyword">return</span> str.replace(MULTILINER, heredoc ? <span class="string">'\\n'</span> : <span class="string">''</span>);
    };

    Lexer.prototype.makeString = <span class="keyword">function</span>(body, quote, heredoc) {
      <span class="keyword">if</span> (!body) {
        <span class="keyword">return</span> quote + quote;
      }
      body = body.replace(<span class="regexp">/\\([\s\S])/g</span>, <span class="keyword">function</span>(match, contents) {
        <span class="keyword">if</span> (contents === <span class="string">'\n'</span> || contents === quote) {
          <span class="keyword">return</span> contents;
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> match;
        }
      });
      body = body.replace(RegExp(<span class="string">""</span> + quote, <span class="string">"g"</span>), <span class="string">'\\$&amp;'</span>);
      <span class="keyword">return</span> quote + <span class="keyword">this</span>.escapeLines(body, heredoc) + quote;
    };

    Lexer.prototype.error = <span class="keyword">function</span>(message) {
      <span class="keyword">throw</span> SyntaxError(<span class="string">""</span> + message + <span class="string">" on line "</span> + (<span class="keyword">this</span>.line + <span class="number">1</span>));
    };

    <span class="keyword">return</span> Lexer;

  })();

  JS_KEYWORDS = [<span class="string">'true'</span>, <span class="string">'false'</span>, <span class="string">'null'</span>, <span class="string">'this'</span>, <span class="string">'new'</span>, <span class="string">'delete'</span>, <span class="string">'typeof'</span>, <span class="string">'in'</span>, <span class="string">'instanceof'</span>, <span class="string">'return'</span>, <span class="string">'throw'</span>, <span class="string">'break'</span>, <span class="string">'continue'</span>, <span class="string">'debugger'</span>, <span class="string">'if'</span>, <span class="string">'else'</span>, <span class="string">'switch'</span>, <span class="string">'for'</span>, <span class="string">'while'</span>, <span class="string">'do'</span>, <span class="string">'try'</span>, <span class="string">'catch'</span>, <span class="string">'finally'</span>, <span class="string">'class'</span>, <span class="string">'extends'</span>, <span class="string">'super'</span>];

  COFFEE_KEYWORDS = [<span class="string">'undefined'</span>, <span class="string">'then'</span>, <span class="string">'unless'</span>, <span class="string">'until'</span>, <span class="string">'loop'</span>, <span class="string">'of'</span>, <span class="string">'by'</span>, <span class="string">'when'</span>];

  COFFEE_ALIAS_MAP = {
    and: <span class="string">'&amp;&amp;'</span>,
    or: <span class="string">'||'</span>,
    is: <span class="string">'=='</span>,
    isnt: <span class="string">'!='</span>,
    not: <span class="string">'!'</span>,
    yes: <span class="string">'true'</span>,
    no: <span class="string">'false'</span>,
    on: <span class="string">'true'</span>,
    off: <span class="string">'false'</span>
  };

  COFFEE_ALIASES = (<span class="keyword">function</span>() {
    <span class="keyword">var</span> _results;
    _results = [];
    <span class="keyword">for</span> (key <span class="keyword">in</span> COFFEE_ALIAS_MAP) {
      _results.push(key);
    }
    <span class="keyword">return</span> _results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = [<span class="string">'case'</span>, <span class="string">'default'</span>, <span class="string">'function'</span>, <span class="string">'var'</span>, <span class="string">'void'</span>, <span class="string">'with'</span>, <span class="string">'const'</span>, <span class="string">'let'</span>, <span class="string">'enum'</span>, <span class="string">'export'</span>, <span class="string">'import'</span>, <span class="string">'native'</span>, <span class="string">'__hasProp'</span>, <span class="string">'__extends'</span>, <span class="string">'__slice'</span>, <span class="string">'__bind'</span>, <span class="string">'__indexOf'</span>, <span class="string">'implements'</span>, <span class="string">'interface'</span>, <span class="string">'package'</span>, <span class="string">'private'</span>, <span class="string">'protected'</span>, <span class="string">'public'</span>, <span class="string">'static'</span>, <span class="string">'yield'</span>];

  STRICT_PROSCRIBED = [<span class="string">'arguments'</span>, <span class="string">'eval'</span>];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  IDENTIFIER = <span class="regexp">/^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/</span>;

  NUMBER = <span class="regexp">/^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i</span>;

  HEREDOC = <span class="regexp">/^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/</span>;

  OPERATOR = <span class="regexp">/^(?:[-=]>|[-+*\/%&lt;>&amp;|^!?=]=|>>>=?|([-+:])\1|([&amp;|&lt;>])\2=?|\?\.|\.{2,3})/</span>;

  WHITESPACE = <span class="regexp">/^[^\n\S]+/</span>;

  COMMENT = <span class="regexp">/^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*#(?!##[^#]).*)+/</span>;

  CODE = <span class="regexp">/^[-=]>/</span>;

  MULTI_DENT = <span class="regexp">/^(?:\n[^\n\S]*)+/</span>;

  SIMPLESTR = <span class="regexp">/^'[^\\']*(?:\\.[^\\']*)*'/</span>;

  JSTOKEN = <span class="regexp">/^`[^\\`]*(?:\\.[^\\`]*)*`/</span>;

  REGEX = <span class="regexp">/^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/</span>;

  HEREGEX = <span class="regexp">/^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/</span>;

  HEREGEX_OMIT = <span class="regexp">/\s+(?:#.*)?/g</span>;

  MULTILINER = <span class="regexp">/\n/g</span>;

  HEREDOC_INDENT = <span class="regexp">/\n+([^\n\S]*)/g</span>;

  HEREDOC_ILLEGAL = <span class="regexp">/\*\//</span>;

  LINE_CONTINUER = <span class="regexp">/^\s*(?:,|\??\.(?![.\d])|::)/</span>;

  TRAILING_SPACES = <span class="regexp">/\s+$/</span>;

  COMPOUND_ASSIGN = [<span class="string">'-='</span>, <span class="string">'+='</span>, <span class="string">'/='</span>, <span class="string">'*='</span>, <span class="string">'%='</span>, <span class="string">'||='</span>, <span class="string">'&amp;&amp;='</span>, <span class="string">'?='</span>, <span class="string">'&lt;&lt;='</span>, <span class="string">'>>='</span>, <span class="string">'>>>='</span>, <span class="string">'&amp;='</span>, <span class="string">'^='</span>, <span class="string">'|='</span>];

  UNARY = [<span class="string">'!'</span>, <span class="string">'~'</span>, <span class="string">'NEW'</span>, <span class="string">'TYPEOF'</span>, <span class="string">'DELETE'</span>, <span class="string">'DO'</span>];

  LOGIC = [<span class="string">'&amp;&amp;'</span>, <span class="string">'||'</span>, <span class="string">'&amp;'</span>, <span class="string">'|'</span>, <span class="string">'^'</span>];

  SHIFT = [<span class="string">'&lt;&lt;'</span>, <span class="string">'>>'</span>, <span class="string">'>>>'</span>];

  COMPARE = [<span class="string">'=='</span>, <span class="string">'!='</span>, <span class="string">'&lt;'</span>, <span class="string">'>'</span>, <span class="string">'&lt;='</span>, <span class="string">'>='</span>];

  MATH = [<span class="string">'*'</span>, <span class="string">'/'</span>, <span class="string">'%'</span>];

  RELATION = [<span class="string">'IN'</span>, <span class="string">'OF'</span>, <span class="string">'INSTANCEOF'</span>];

  BOOL = [<span class="string">'TRUE'</span>, <span class="string">'FALSE'</span>];

  NOT_REGEX = [<span class="string">'NUMBER'</span>, <span class="string">'REGEX'</span>, <span class="string">'BOOL'</span>, <span class="string">'NULL'</span>, <span class="string">'UNDEFINED'</span>, <span class="string">'++'</span>, <span class="string">'--'</span>, <span class="string">']'</span>];

  NOT_SPACED_REGEX = NOT_REGEX.concat(<span class="string">')'</span>, <span class="string">'}'</span>, <span class="string">'THIS'</span>, <span class="string">'IDENTIFIER'</span>, <span class="string">'STRING'</span>);

  CALLABLE = [<span class="string">'IDENTIFIER'</span>, <span class="string">'STRING'</span>, <span class="string">'REGEX'</span>, <span class="string">')'</span>, <span class="string">']'</span>, <span class="string">'}'</span>, <span class="string">'?'</span>, <span class="string">'::'</span>, <span class="string">'@'</span>, <span class="string">'THIS'</span>, <span class="string">'SUPER'</span>];

  INDEXABLE = CALLABLE.concat(<span class="string">'NUMBER'</span>, <span class="string">'BOOL'</span>, <span class="string">'NULL'</span>, <span class="string">'UNDEFINED'</span>);

  LINE_BREAK = [<span class="string">'INDENT'</span>, <span class="string">'OUTDENT'</span>, <span class="string">'TERMINATOR'</span>];

}).call(<span class="keyword">this</span>);
</code></pre>