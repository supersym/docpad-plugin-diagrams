<h1>rewriter.js</h1>
<pre><code class="lang-js"><span class="comment">// Generated by CoffeeScript 1.4.0</span>
(<span class="keyword">function</span>() {
  <span class="keyword">var</span> BALANCED_PAIRS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_BLOCK, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || <span class="keyword">function</span>(item) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) { <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>[i] === item) <span class="keyword">return</span> i; } <span class="keyword">return</span> -<span class="number">1</span>; },
    __slice = [].slice;

  exports.Rewriter = (<span class="keyword">function</span>() {

    <span class="function"><span class="keyword">function</span> <span class="title">Rewriter</span><span class="params">()</span> {</span>}

    Rewriter.prototype.rewrite = <span class="keyword">function</span>(tokens) {
      <span class="keyword">this</span>.tokens = tokens;
      <span class="keyword">this</span>.removeLeadingNewlines();
      <span class="keyword">this</span>.removeMidExpressionNewlines();
      <span class="keyword">this</span>.closeOpenCalls();
      <span class="keyword">this</span>.closeOpenIndexes();
      <span class="keyword">this</span>.addImplicitIndentation();
      <span class="keyword">this</span>.tagPostfixConditionals();
      <span class="keyword">this</span>.addImplicitBraces();
      <span class="keyword">this</span>.addImplicitParentheses();
      <span class="keyword">return</span> <span class="keyword">this</span>.tokens;
    };

    Rewriter.prototype.scanTokens = <span class="keyword">function</span>(block) {
      <span class="keyword">var</span> i, token, tokens;
      tokens = <span class="keyword">this</span>.tokens;
      i = <span class="number">0</span>;
      <span class="keyword">while</span> (token = tokens[i]) {
        i += block.call(<span class="keyword">this</span>, token, i, tokens);
      }
      <span class="keyword">return</span> <span class="literal">true</span>;
    };

    Rewriter.prototype.detectEnd = <span class="keyword">function</span>(i, condition, action) {
      <span class="keyword">var</span> levels, token, tokens, _ref, _ref1;
      tokens = <span class="keyword">this</span>.tokens;
      levels = <span class="number">0</span>;
      <span class="keyword">while</span> (token = tokens[i]) {
        <span class="keyword">if</span> (levels === <span class="number">0</span> &amp;&amp; condition.call(<span class="keyword">this</span>, token, i)) {
          <span class="keyword">return</span> action.call(<span class="keyword">this</span>, token, i);
        }
        <span class="keyword">if</span> (!token || levels &lt; <span class="number">0</span>) {
          <span class="keyword">return</span> action.call(<span class="keyword">this</span>, token, i - <span class="number">1</span>);
        }
        <span class="keyword">if</span> (_ref = token[<span class="number">0</span>], __indexOf.call(EXPRESSION_START, _ref) >= <span class="number">0</span>) {
          levels += <span class="number">1</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (_ref1 = token[<span class="number">0</span>], __indexOf.call(EXPRESSION_END, _ref1) >= <span class="number">0</span>) {
          levels -= <span class="number">1</span>;
        }
        i += <span class="number">1</span>;
      }
      <span class="keyword">return</span> i - <span class="number">1</span>;
    };

    Rewriter.prototype.removeLeadingNewlines = <span class="keyword">function</span>() {
      <span class="keyword">var</span> i, tag, _i, _len, _ref;
      _ref = <span class="keyword">this</span>.tokens;
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; i = ++_i) {
        tag = _ref[i][<span class="number">0</span>];
        <span class="keyword">if</span> (tag !== <span class="string">'TERMINATOR'</span>) {
          <span class="keyword">break</span>;
        }
      }
      <span class="keyword">if</span> (i) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens.splice(<span class="number">0</span>, i);
      }
    };

    Rewriter.prototype.removeMidExpressionNewlines = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i, tokens) {
        <span class="keyword">var</span> _ref;
        <span class="keyword">if</span> (!(token[<span class="number">0</span>] === <span class="string">'TERMINATOR'</span> &amp;&amp; (_ref = <span class="keyword">this</span>.tag(i + <span class="number">1</span>), __indexOf.call(EXPRESSION_CLOSE, _ref) >= <span class="number">0</span>))) {
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        tokens.splice(i, <span class="number">1</span>);
        <span class="keyword">return</span> <span class="number">0</span>;
      });
    };

    Rewriter.prototype.closeOpenCalls = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> _ref;
        <span class="keyword">return</span> ((_ref = token[<span class="number">0</span>]) === <span class="string">')'</span> || _ref === <span class="string">'CALL_END'</span>) || token[<span class="number">0</span>] === <span class="string">'OUTDENT'</span> &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) === <span class="string">')'</span>;
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens[token[<span class="number">0</span>] === <span class="string">'OUTDENT'</span> ? i - <span class="number">1</span> : i][<span class="number">0</span>] = <span class="string">'CALL_END'</span>;
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i) {
        <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">'CALL_START'</span>) {
          <span class="keyword">this</span>.detectEnd(i + <span class="number">1</span>, condition, action);
        }
        <span class="keyword">return</span> <span class="number">1</span>;
      });
    };

    Rewriter.prototype.closeOpenIndexes = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> _ref;
        <span class="keyword">return</span> (_ref = token[<span class="number">0</span>]) === <span class="string">']'</span> || _ref === <span class="string">'INDEX_END'</span>;
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">return</span> token[<span class="number">0</span>] = <span class="string">'INDEX_END'</span>;
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i) {
        <span class="keyword">if</span> (token[<span class="number">0</span>] === <span class="string">'INDEX_START'</span>) {
          <span class="keyword">this</span>.detectEnd(i + <span class="number">1</span>, condition, action);
        }
        <span class="keyword">return</span> <span class="number">1</span>;
      });
    };

    Rewriter.prototype.addImplicitBraces = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition, sameLine, stack, start, startIndent, startIndex, startsLine;
      stack = [];
      start = <span class="literal">null</span>;
      startsLine = <span class="literal">null</span>;
      sameLine = <span class="literal">true</span>;
      startIndent = <span class="number">0</span>;
      startIndex = <span class="number">0</span>;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> one, tag, three, two, _ref, _ref1;
        _ref = <span class="keyword">this</span>.tokens.slice(i + <span class="number">1</span>, +(i + <span class="number">3</span>) + <span class="number">1</span> || <span class="number">9e9</span>), one = _ref[<span class="number">0</span>], two = _ref[<span class="number">1</span>], three = _ref[<span class="number">2</span>];
        <span class="keyword">if</span> (<span class="string">'HERECOMMENT'</span> === (one != <span class="literal">null</span> ? one[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>)) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        tag = token[<span class="number">0</span>];
        <span class="keyword">if</span> (__indexOf.call(LINEBREAKS, tag) >= <span class="number">0</span>) {
          sameLine = <span class="literal">false</span>;
        }
        <span class="keyword">return</span> (((tag === <span class="string">'TERMINATOR'</span> || tag === <span class="string">'OUTDENT'</span>) || (__indexOf.call(IMPLICIT_END, tag) >= <span class="number">0</span> &amp;&amp; sameLine &amp;&amp; !(i - startIndex === <span class="number">1</span>))) &amp;&amp; ((!startsLine &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) !== <span class="string">','</span>) || !((two != <span class="literal">null</span> ? two[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>) === <span class="string">':'</span> || (one != <span class="literal">null</span> ? one[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>) === <span class="string">'@'</span> &amp;&amp; (three != <span class="literal">null</span> ? three[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>) === <span class="string">':'</span>))) || (tag === <span class="string">','</span> &amp;&amp; one &amp;&amp; ((_ref1 = one[<span class="number">0</span>]) !== <span class="string">'IDENTIFIER'</span> &amp;&amp; _ref1 !== <span class="string">'NUMBER'</span> &amp;&amp; _ref1 !== <span class="string">'STRING'</span> &amp;&amp; _ref1 !== <span class="string">'@'</span> &amp;&amp; _ref1 !== <span class="string">'TERMINATOR'</span> &amp;&amp; _ref1 !== <span class="string">'OUTDENT'</span>));
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> tok;
        tok = <span class="keyword">this</span>.generate(<span class="string">'}'</span>, <span class="string">'}'</span>, token[<span class="number">2</span>]);
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens.splice(i, <span class="number">0</span>, tok);
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i, tokens) {
        <span class="keyword">var</span> ago, idx, prevTag, tag, tok, value, _ref, _ref1;
        <span class="keyword">if</span> (_ref = (tag = token[<span class="number">0</span>]), __indexOf.call(EXPRESSION_START, _ref) >= <span class="number">0</span>) {
          stack.push([(tag === <span class="string">'INDENT'</span> &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) === <span class="string">'{'</span> ? <span class="string">'{'</span> : tag), i]);
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span> (__indexOf.call(EXPRESSION_END, tag) >= <span class="number">0</span>) {
          start = stack.pop();
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span> (!(tag === <span class="string">':'</span> &amp;&amp; ((ago = <span class="keyword">this</span>.tag(i - <span class="number">2</span>)) === <span class="string">':'</span> || ((_ref1 = stack[stack.length - <span class="number">1</span>]) != <span class="literal">null</span> ? _ref1[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>) !== <span class="string">'{'</span>))) {
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        sameLine = <span class="literal">true</span>;
        startIndex = i + <span class="number">1</span>;
        stack.push([<span class="string">'{'</span>]);
        idx = ago === <span class="string">'@'</span> ? i - <span class="number">2</span> : i - <span class="number">1</span>;
        <span class="keyword">while</span> (<span class="keyword">this</span>.tag(idx - <span class="number">2</span>) === <span class="string">'HERECOMMENT'</span>) {
          idx -= <span class="number">2</span>;
        }
        prevTag = <span class="keyword">this</span>.tag(idx - <span class="number">1</span>);
        startsLine = !prevTag || (__indexOf.call(LINEBREAKS, prevTag) >= <span class="number">0</span>);
        value = <span class="keyword">new</span> String(<span class="string">'{'</span>);
        value.generated = <span class="literal">true</span>;
        tok = <span class="keyword">this</span>.generate(<span class="string">'{'</span>, value, token[<span class="number">2</span>]);
        tokens.splice(idx, <span class="number">0</span>, tok);
        <span class="keyword">this</span>.detectEnd(i + <span class="number">2</span>, condition, action);
        <span class="keyword">return</span> <span class="number">2</span>;
      });
    };

    Rewriter.prototype.addImplicitParentheses = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition, noCall, seenControl, seenSingle;
      noCall = seenSingle = seenControl = <span class="literal">false</span>;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> post, tag, _ref, _ref1;
        tag = token[<span class="number">0</span>];
        <span class="keyword">if</span> (!seenSingle &amp;&amp; token.fromThen) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">if</span> (tag === <span class="string">'IF'</span> || tag === <span class="string">'ELSE'</span> || tag === <span class="string">'CATCH'</span> || tag === <span class="string">'->'</span> || tag === <span class="string">'=>'</span> || tag === <span class="string">'CLASS'</span>) {
          seenSingle = <span class="literal">true</span>;
        }
        <span class="keyword">if</span> (tag === <span class="string">'IF'</span> || tag === <span class="string">'ELSE'</span> || tag === <span class="string">'SWITCH'</span> || tag === <span class="string">'TRY'</span> || tag === <span class="string">'='</span>) {
          seenControl = <span class="literal">true</span>;
        }
        <span class="keyword">if</span> ((tag === <span class="string">'.'</span> || tag === <span class="string">'?.'</span> || tag === <span class="string">'::'</span>) &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) === <span class="string">'OUTDENT'</span>) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
        <span class="keyword">return</span> !token.generated &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) !== <span class="string">','</span> &amp;&amp; (__indexOf.call(IMPLICIT_END, tag) >= <span class="number">0</span> || (tag === <span class="string">'INDENT'</span> &amp;&amp; !seenControl)) &amp;&amp; (tag !== <span class="string">'INDENT'</span> || (((_ref = <span class="keyword">this</span>.tag(i - <span class="number">2</span>)) !== <span class="string">'CLASS'</span> &amp;&amp; _ref !== <span class="string">'EXTENDS'</span>) &amp;&amp; (_ref1 = <span class="keyword">this</span>.tag(i - <span class="number">1</span>), __indexOf.call(IMPLICIT_BLOCK, _ref1) &lt; <span class="number">0</span>) &amp;&amp; !((post = <span class="keyword">this</span>.tokens[i + <span class="number">1</span>]) &amp;&amp; post.generated &amp;&amp; post[<span class="number">0</span>] === <span class="string">'{'</span>)));
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens.splice(i, <span class="number">0</span>, <span class="keyword">this</span>.generate(<span class="string">'CALL_END'</span>, <span class="string">')'</span>, token[<span class="number">2</span>]));
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i, tokens) {
        <span class="keyword">var</span> callObject, current, next, prev, tag, _ref, _ref1, _ref2;
        tag = token[<span class="number">0</span>];
        <span class="keyword">if</span> (tag === <span class="string">'CLASS'</span> || tag === <span class="string">'IF'</span> || tag === <span class="string">'FOR'</span> || tag === <span class="string">'WHILE'</span>) {
          noCall = <span class="literal">true</span>;
        }
        _ref = tokens.slice(i - <span class="number">1</span>, +(i + <span class="number">1</span>) + <span class="number">1</span> || <span class="number">9e9</span>), prev = _ref[<span class="number">0</span>], current = _ref[<span class="number">1</span>], next = _ref[<span class="number">2</span>];
        callObject = !noCall &amp;&amp; tag === <span class="string">'INDENT'</span> &amp;&amp; next &amp;&amp; next.generated &amp;&amp; next[<span class="number">0</span>] === <span class="string">'{'</span> &amp;&amp; prev &amp;&amp; (_ref1 = prev[<span class="number">0</span>], __indexOf.call(IMPLICIT_FUNC, _ref1) >= <span class="number">0</span>);
        seenSingle = <span class="literal">false</span>;
        seenControl = <span class="literal">false</span>;
        <span class="keyword">if</span> (__indexOf.call(LINEBREAKS, tag) >= <span class="number">0</span>) {
          noCall = <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (prev &amp;&amp; !prev.spaced &amp;&amp; tag === <span class="string">'?'</span>) {
          token.call = <span class="literal">true</span>;
        }
        <span class="keyword">if</span> (token.fromThen) {
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">if</span> (!(callObject || (prev != <span class="literal">null</span> ? prev.spaced : <span class="keyword">void</span> <span class="number">0</span>) &amp;&amp; (prev.call || (_ref2 = prev[<span class="number">0</span>], __indexOf.call(IMPLICIT_FUNC, _ref2) >= <span class="number">0</span>)) &amp;&amp; (__indexOf.call(IMPLICIT_CALL, tag) >= <span class="number">0</span> || !(token.spaced || token.newLine) &amp;&amp; __indexOf.call(IMPLICIT_UNSPACED_CALL, tag) >= <span class="number">0</span>))) {
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        tokens.splice(i, <span class="number">0</span>, <span class="keyword">this</span>.generate(<span class="string">'CALL_START'</span>, <span class="string">'('</span>, token[<span class="number">2</span>]));
        <span class="keyword">this</span>.detectEnd(i + <span class="number">1</span>, condition, action);
        <span class="keyword">if</span> (prev[<span class="number">0</span>] === <span class="string">'?'</span>) {
          prev[<span class="number">0</span>] = <span class="string">'FUNC_EXIST'</span>;
        }
        <span class="keyword">return</span> <span class="number">2</span>;
      });
    };

    Rewriter.prototype.addImplicitIndentation = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition, indent, outdent, starter;
      starter = indent = outdent = <span class="literal">null</span>;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> _ref;
        <span class="keyword">return</span> token[<span class="number">1</span>] !== <span class="string">';'</span> &amp;&amp; (_ref = token[<span class="number">0</span>], __indexOf.call(SINGLE_CLOSERS, _ref) >= <span class="number">0</span>) &amp;&amp; !(token[<span class="number">0</span>] === <span class="string">'ELSE'</span> &amp;&amp; (starter !== <span class="string">'IF'</span> &amp;&amp; starter !== <span class="string">'THEN'</span>));
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tokens.splice((<span class="keyword">this</span>.tag(i - <span class="number">1</span>) === <span class="string">','</span> ? i - <span class="number">1</span> : i), <span class="number">0</span>, outdent);
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i, tokens) {
        <span class="keyword">var</span> tag, _ref, _ref1;
        tag = token[<span class="number">0</span>];
        <span class="keyword">if</span> (tag === <span class="string">'TERMINATOR'</span> &amp;&amp; <span class="keyword">this</span>.tag(i + <span class="number">1</span>) === <span class="string">'THEN'</span>) {
          tokens.splice(i, <span class="number">1</span>);
          <span class="keyword">return</span> <span class="number">0</span>;
        }
        <span class="keyword">if</span> (tag === <span class="string">'ELSE'</span> &amp;&amp; <span class="keyword">this</span>.tag(i - <span class="number">1</span>) !== <span class="string">'OUTDENT'</span>) {
          tokens.splice.apply(tokens, [i, <span class="number">0</span>].concat(__slice.call(<span class="keyword">this</span>.indentation(token))));
          <span class="keyword">return</span> <span class="number">2</span>;
        }
        <span class="keyword">if</span> (tag === <span class="string">'CATCH'</span> &amp;&amp; ((_ref = <span class="keyword">this</span>.tag(i + <span class="number">2</span>)) === <span class="string">'OUTDENT'</span> || _ref === <span class="string">'TERMINATOR'</span> || _ref === <span class="string">'FINALLY'</span>)) {
          tokens.splice.apply(tokens, [i + <span class="number">2</span>, <span class="number">0</span>].concat(__slice.call(<span class="keyword">this</span>.indentation(token))));
          <span class="keyword">return</span> <span class="number">4</span>;
        }
        <span class="keyword">if</span> (__indexOf.call(SINGLE_LINERS, tag) >= <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.tag(i + <span class="number">1</span>) !== <span class="string">'INDENT'</span> &amp;&amp; !(tag === <span class="string">'ELSE'</span> &amp;&amp; <span class="keyword">this</span>.tag(i + <span class="number">1</span>) === <span class="string">'IF'</span>)) {
          starter = tag;
          _ref1 = <span class="keyword">this</span>.indentation(token, <span class="literal">true</span>), indent = _ref1[<span class="number">0</span>], outdent = _ref1[<span class="number">1</span>];
          <span class="keyword">if</span> (starter === <span class="string">'THEN'</span>) {
            indent.fromThen = <span class="literal">true</span>;
          }
          tokens.splice(i + <span class="number">1</span>, <span class="number">0</span>, indent);
          <span class="keyword">this</span>.detectEnd(i + <span class="number">2</span>, condition, action);
          <span class="keyword">if</span> (tag === <span class="string">'THEN'</span>) {
            tokens.splice(i, <span class="number">1</span>);
          }
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        <span class="keyword">return</span> <span class="number">1</span>;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = <span class="keyword">function</span>() {
      <span class="keyword">var</span> action, condition, original;
      original = <span class="literal">null</span>;
      condition = <span class="keyword">function</span>(token, i) {
        <span class="keyword">var</span> _ref;
        <span class="keyword">return</span> (_ref = token[<span class="number">0</span>]) === <span class="string">'TERMINATOR'</span> || _ref === <span class="string">'INDENT'</span>;
      };
      action = <span class="keyword">function</span>(token, i) {
        <span class="keyword">if</span> (token[<span class="number">0</span>] !== <span class="string">'INDENT'</span> || (token.generated &amp;&amp; !token.fromThen)) {
          <span class="keyword">return</span> original[<span class="number">0</span>] = <span class="string">'POST_'</span> + original[<span class="number">0</span>];
        }
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.scanTokens(<span class="keyword">function</span>(token, i) {
        <span class="keyword">if</span> (token[<span class="number">0</span>] !== <span class="string">'IF'</span>) {
          <span class="keyword">return</span> <span class="number">1</span>;
        }
        original = token;
        <span class="keyword">this</span>.detectEnd(i + <span class="number">1</span>, condition, action);
        <span class="keyword">return</span> <span class="number">1</span>;
      });
    };

    Rewriter.prototype.indentation = <span class="keyword">function</span>(token, implicit) {
      <span class="keyword">var</span> indent, outdent;
      <span class="keyword">if</span> (implicit == <span class="literal">null</span>) {
        implicit = <span class="literal">false</span>;
      }
      indent = [<span class="string">'INDENT'</span>, <span class="number">2</span>, token[<span class="number">2</span>]];
      outdent = [<span class="string">'OUTDENT'</span>, <span class="number">2</span>, token[<span class="number">2</span>]];
      <span class="keyword">if</span> (implicit) {
        indent.generated = outdent.generated = <span class="literal">true</span>;
      }
      <span class="keyword">return</span> [indent, outdent];
    };

    Rewriter.prototype.generate = <span class="keyword">function</span>(tag, value, line) {
      <span class="keyword">var</span> tok;
      tok = [tag, value, line];
      tok.generated = <span class="literal">true</span>;
      <span class="keyword">return</span> tok;
    };

    Rewriter.prototype.tag = <span class="keyword">function</span>(i) {
      <span class="keyword">var</span> _ref;
      <span class="keyword">return</span> (_ref = <span class="keyword">this</span>.tokens[i]) != <span class="literal">null</span> ? _ref[<span class="number">0</span>] : <span class="keyword">void</span> <span class="number">0</span>;
    };

    <span class="keyword">return</span> Rewriter;

  })();

  BALANCED_PAIRS = [[<span class="string">'('</span>, <span class="string">')'</span>], [<span class="string">'['</span>, <span class="string">']'</span>], [<span class="string">'{'</span>, <span class="string">'}'</span>], [<span class="string">'INDENT'</span>, <span class="string">'OUTDENT'</span>], [<span class="string">'CALL_START'</span>, <span class="string">'CALL_END'</span>], [<span class="string">'PARAM_START'</span>, <span class="string">'PARAM_END'</span>], [<span class="string">'INDEX_START'</span>, <span class="string">'INDEX_END'</span>]];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = BALANCED_PAIRS.length; _i &lt; _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[<span class="number">0</span>], rite = _ref[<span class="number">1</span>];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = [<span class="string">'CATCH'</span>, <span class="string">'WHEN'</span>, <span class="string">'ELSE'</span>, <span class="string">'FINALLY'</span>].concat(EXPRESSION_END);

  IMPLICIT_FUNC = [<span class="string">'IDENTIFIER'</span>, <span class="string">'SUPER'</span>, <span class="string">')'</span>, <span class="string">'CALL_END'</span>, <span class="string">']'</span>, <span class="string">'INDEX_END'</span>, <span class="string">'@'</span>, <span class="string">'THIS'</span>];

  IMPLICIT_CALL = [<span class="string">'IDENTIFIER'</span>, <span class="string">'NUMBER'</span>, <span class="string">'STRING'</span>, <span class="string">'JS'</span>, <span class="string">'REGEX'</span>, <span class="string">'NEW'</span>, <span class="string">'PARAM_START'</span>, <span class="string">'CLASS'</span>, <span class="string">'IF'</span>, <span class="string">'TRY'</span>, <span class="string">'SWITCH'</span>, <span class="string">'THIS'</span>, <span class="string">'BOOL'</span>, <span class="string">'NULL'</span>, <span class="string">'UNDEFINED'</span>, <span class="string">'UNARY'</span>, <span class="string">'SUPER'</span>, <span class="string">'@'</span>, <span class="string">'->'</span>, <span class="string">'=>'</span>, <span class="string">'['</span>, <span class="string">'('</span>, <span class="string">'{'</span>, <span class="string">'--'</span>, <span class="string">'++'</span>];

  IMPLICIT_UNSPACED_CALL = [<span class="string">'+'</span>, <span class="string">'-'</span>];

  IMPLICIT_BLOCK = [<span class="string">'->'</span>, <span class="string">'=>'</span>, <span class="string">'{'</span>, <span class="string">'['</span>, <span class="string">','</span>];

  IMPLICIT_END = [<span class="string">'POST_IF'</span>, <span class="string">'FOR'</span>, <span class="string">'WHILE'</span>, <span class="string">'UNTIL'</span>, <span class="string">'WHEN'</span>, <span class="string">'BY'</span>, <span class="string">'LOOP'</span>, <span class="string">'TERMINATOR'</span>];

  SINGLE_LINERS = [<span class="string">'ELSE'</span>, <span class="string">'->'</span>, <span class="string">'=>'</span>, <span class="string">'TRY'</span>, <span class="string">'FINALLY'</span>, <span class="string">'THEN'</span>];

  SINGLE_CLOSERS = [<span class="string">'TERMINATOR'</span>, <span class="string">'CATCH'</span>, <span class="string">'FINALLY'</span>, <span class="string">'ELSE'</span>, <span class="string">'OUTDENT'</span>, <span class="string">'LEADING_WHEN'</span>];

  LINEBREAKS = [<span class="string">'TERMINATOR'</span>, <span class="string">'INDENT'</span>, <span class="string">'OUTDENT'</span>];

}).call(<span class="keyword">this</span>);
</code></pre>