<h1>nodes.js</h1>
<pre><code class="lang-js"><span class="comment">// Generated by CoffeeScript 1.4.0</span>
(<span class="keyword">function</span>() {
  <span class="keyword">var</span> Access, Arr, Assign, Base, Block, Call, Class, Closure, Code, Comment, Existence, Extends, For, IDENTIFIER, IDENTIFIER_STR, IS_STRING, If, In, Index, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, METHOD_DEF, NEGATE, NO, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, compact, del, ends, extend, flatten, last, merge, multident, some, starts, unfoldSoak, utility, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = <span class="keyword">function</span>(child, parent) { <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> parent) { <span class="keyword">if</span> (__hasProp.call(parent, key)) child[key] = parent[key]; } <span class="function"><span class="keyword">function</span> <span class="title">ctor</span><span class="params">()</span> {</span> <span class="keyword">this</span>.constructor = child; } ctor.prototype = parent.prototype; child.prototype = <span class="keyword">new</span> ctor(); child.__super__ = parent.prototype; <span class="keyword">return</span> child; },
    __indexOf = [].indexOf || <span class="keyword">function</span>(item) { <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.length; i &lt; l; i++) { <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>[i] === item) <span class="keyword">return</span> i; } <span class="keyword">return</span> -<span class="number">1</span>; };

  Scope = require(<span class="string">'./scope'</span>).Scope;

  _ref = require(<span class="string">'./lexer'</span>), RESERVED = _ref.RESERVED, STRICT_PROSCRIBED = _ref.STRICT_PROSCRIBED;

  _ref1 = require(<span class="string">'./helpers'</span>), compact = _ref1.compact, flatten = _ref1.flatten, extend = _ref1.extend, merge = _ref1.merge, del = _ref1.del, starts = _ref1.starts, ends = _ref1.ends, last = _ref1.last, some = _ref1.some;

  exports.extend = extend;

  YES = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="literal">true</span>;
  };

  NO = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="literal">false</span>;
  };

  THIS = <span class="keyword">function</span>() {
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };

  NEGATE = <span class="keyword">function</span>() {
    <span class="keyword">this</span>.negated = !<span class="keyword">this</span>.negated;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };

  exports.Base = Base = (<span class="keyword">function</span>() {

    <span class="function"><span class="keyword">function</span> <span class="title">Base</span><span class="params">()</span> {</span>}

    Base.prototype.compile = <span class="keyword">function</span>(o, lvl) {
      <span class="keyword">var</span> node;
      o = extend({}, o);
      <span class="keyword">if</span> (lvl) {
        o.level = lvl;
      }
      node = <span class="keyword">this</span>.unfoldSoak(o) || <span class="keyword">this</span>;
      node.tab = o.indent;
      <span class="keyword">if</span> (o.level === LEVEL_TOP || !node.isStatement(o)) {
        <span class="keyword">return</span> node.compileNode(o);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> node.compileClosure(o);
      }
    };

    Base.prototype.compileClosure = <span class="keyword">function</span>(o) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.jumps()) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'cannot use a pure statement in an expression.'</span>);
      }
      o.sharedScope = <span class="literal">true</span>;
      <span class="keyword">return</span> Closure.wrap(<span class="keyword">this</span>).compileNode(o);
    };

    Base.prototype.cache = <span class="keyword">function</span>(o, level, reused) {
      <span class="keyword">var</span> ref, sub;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.isComplex()) {
        ref = level ? <span class="keyword">this</span>.compile(o, level) : <span class="keyword">this</span>;
        <span class="keyword">return</span> [ref, ref];
      } <span class="keyword">else</span> {
        ref = <span class="keyword">new</span> Literal(reused || o.scope.freeVariable(<span class="string">'ref'</span>));
        sub = <span class="keyword">new</span> Assign(ref, <span class="keyword">this</span>);
        <span class="keyword">if</span> (level) {
          <span class="keyword">return</span> [sub.compile(o, level), ref.value];
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> [sub, ref];
        }
      }
    };

    Base.prototype.compileLoopReference = <span class="keyword">function</span>(o, name) {
      <span class="keyword">var</span> src, tmp;
      src = tmp = <span class="keyword">this</span>.compile(o, LEVEL_LIST);
      <span class="keyword">if</span> (!((-<span class="literal">Infinity</span> &lt; +src &amp;&amp; +src &lt; <span class="literal">Infinity</span>) || IDENTIFIER.test(src) &amp;&amp; o.scope.check(src, <span class="literal">true</span>))) {
        src = <span class="string">""</span> + (tmp = o.scope.freeVariable(name)) + <span class="string">" = "</span> + src;
      }
      <span class="keyword">return</span> [src, tmp];
    };

    Base.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">var</span> me;
      me = <span class="keyword">this</span>.unwrapAll();
      <span class="keyword">if</span> (res) {
        <span class="keyword">return</span> <span class="keyword">new</span> Call(<span class="keyword">new</span> Literal(<span class="string">""</span> + res + <span class="string">".push"</span>), [me]);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">new</span> Return(me);
      }
    };

    Base.prototype.contains = <span class="keyword">function</span>(pred) {
      <span class="keyword">var</span> contains;
      contains = <span class="literal">false</span>;
      <span class="keyword">this</span>.traverseChildren(<span class="literal">false</span>, <span class="keyword">function</span>(node) {
        <span class="keyword">if</span> (pred(node)) {
          contains = <span class="literal">true</span>;
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
      });
      <span class="keyword">return</span> contains;
    };

    Base.prototype.containsType = <span class="keyword">function</span>(type) {
      <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> type || <span class="keyword">this</span>.contains(<span class="keyword">function</span>(node) {
        <span class="keyword">return</span> node <span class="keyword">instanceof</span> type;
      });
    };

    Base.prototype.lastNonComment = <span class="keyword">function</span>(list) {
      <span class="keyword">var</span> i;
      i = list.length;
      <span class="keyword">while</span> (i--) {
        <span class="keyword">if</span> (!(list[i] <span class="keyword">instanceof</span> Comment)) {
          <span class="keyword">return</span> list[i];
        }
      }
      <span class="keyword">return</span> <span class="literal">null</span>;
    };

    Base.prototype.toString = <span class="keyword">function</span>(idt, name) {
      <span class="keyword">var</span> tree;
      <span class="keyword">if</span> (idt == <span class="literal">null</span>) {
        idt = <span class="string">''</span>;
      }
      <span class="keyword">if</span> (name == <span class="literal">null</span>) {
        name = <span class="keyword">this</span>.constructor.name;
      }
      tree = <span class="string">'\n'</span> + idt + name;
      <span class="keyword">if</span> (<span class="keyword">this</span>.soak) {
        tree += <span class="string">'?'</span>;
      }
      <span class="keyword">this</span>.eachChild(<span class="keyword">function</span>(node) {
        <span class="keyword">return</span> tree += node.toString(idt + TAB);
      });
      <span class="keyword">return</span> tree;
    };

    Base.prototype.eachChild = <span class="keyword">function</span>(func) {
      <span class="keyword">var</span> attr, child, _i, _j, _len, _len1, _ref2, _ref3;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.children) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      _ref2 = <span class="keyword">this</span>.children;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        attr = _ref2[_i];
        <span class="keyword">if</span> (<span class="keyword">this</span>[attr]) {
          _ref3 = flatten([<span class="keyword">this</span>[attr]]);
          <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref3.length; _j &lt; _len1; _j++) {
            child = _ref3[_j];
            <span class="keyword">if</span> (func(child) === <span class="literal">false</span>) {
              <span class="keyword">return</span> <span class="keyword">this</span>;
            }
          }
        }
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Base.prototype.traverseChildren = <span class="keyword">function</span>(crossScope, func) {
      <span class="keyword">return</span> <span class="keyword">this</span>.eachChild(<span class="keyword">function</span>(child) {
        <span class="keyword">if</span> (func(child) === <span class="literal">false</span>) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">return</span> child.traverseChildren(crossScope, func);
      });
    };

    Base.prototype.invert = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">new</span> Op(<span class="string">'!'</span>, <span class="keyword">this</span>);
    };

    Base.prototype.unwrapAll = <span class="keyword">function</span>() {
      <span class="keyword">var</span> node;
      node = <span class="keyword">this</span>;
      <span class="keyword">while</span> (node !== (node = node.unwrap())) {
        <span class="keyword">continue</span>;
      }
      <span class="keyword">return</span> node;
    };

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    <span class="keyword">return</span> Base;

  })();

  exports.Block = Block = (<span class="keyword">function</span>(_super) {

    __extends(Block, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Block</span><span class="params">(nodes)</span> {</span>
      <span class="keyword">this</span>.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = [<span class="string">'expressions'</span>];

    Block.prototype.push = <span class="keyword">function</span>(node) {
      <span class="keyword">this</span>.expressions.push(node);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Block.prototype.pop = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.expressions.pop();
    };

    Block.prototype.unshift = <span class="keyword">function</span>(node) {
      <span class="keyword">this</span>.expressions.unshift(node);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Block.prototype.unwrap = <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.expressions.length === <span class="number">1</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.expressions[<span class="number">0</span>];
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
    };

    Block.prototype.isEmpty = <span class="keyword">function</span>() {
      <span class="keyword">return</span> !<span class="keyword">this</span>.expressions.length;
    };

    Block.prototype.isStatement = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> exp, _i, _len, _ref2;
      _ref2 = <span class="keyword">this</span>.expressions;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        exp = _ref2[_i];
        <span class="keyword">if</span> (exp.isStatement(o)) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    };

    Block.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> exp, _i, _len, _ref2;
      _ref2 = <span class="keyword">this</span>.expressions;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        exp = _ref2[_i];
        <span class="keyword">if</span> (exp.jumps(o)) {
          <span class="keyword">return</span> exp;
        }
      }
    };

    Block.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">var</span> expr, len;
      len = <span class="keyword">this</span>.expressions.length;
      <span class="keyword">while</span> (len--) {
        expr = <span class="keyword">this</span>.expressions[len];
        <span class="keyword">if</span> (!(expr <span class="keyword">instanceof</span> Comment)) {
          <span class="keyword">this</span>.expressions[len] = expr.makeReturn(res);
          <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Return &amp;&amp; !expr.expression) {
            <span class="keyword">this</span>.expressions.splice(len, <span class="number">1</span>);
          }
          <span class="keyword">break</span>;
        }
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Block.prototype.compile = <span class="keyword">function</span>(o, level) {
      <span class="keyword">if</span> (o == <span class="literal">null</span>) {
        o = {};
      }
      <span class="keyword">if</span> (o.scope) {
        <span class="keyword">return</span> Block.__super__.compile.call(<span class="keyword">this</span>, o, level);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileRoot(o);
      }
    };

    Block.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, codes, node, top, _i, _len, _ref2;
      <span class="keyword">this</span>.tab = o.indent;
      top = o.level === LEVEL_TOP;
      codes = [];
      _ref2 = <span class="keyword">this</span>.expressions;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        node = _ref2[_i];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Block) {
          codes.push(node.compileNode(o));
        } <span class="keyword">else</span> <span class="keyword">if</span> (top) {
          node.front = <span class="literal">true</span>;
          code = node.compile(o);
          <span class="keyword">if</span> (!node.isStatement(o)) {
            code = <span class="string">""</span> + <span class="keyword">this</span>.tab + code + <span class="string">";"</span>;
            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Literal) {
              code = <span class="string">""</span> + code + <span class="string">"\n"</span>;
            }
          }
          codes.push(code);
        } <span class="keyword">else</span> {
          codes.push(node.compile(o, LEVEL_LIST));
        }
      }
      <span class="keyword">if</span> (top) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.spaced) {
          <span class="keyword">return</span> <span class="string">"\n"</span> + (codes.join(<span class="string">'\n\n'</span>)) + <span class="string">"\n"</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> codes.join(<span class="string">'\n'</span>);
        }
      }
      code = codes.join(<span class="string">', '</span>) || <span class="string">'void 0'</span>;
      <span class="keyword">if</span> (codes.length > <span class="number">1</span> &amp;&amp; o.level >= LEVEL_LIST) {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> code;
      }
    };

    Block.prototype.compileRoot = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, exp, i, prelude, preludeExps, rest;
      o.indent = o.bare ? <span class="string">''</span> : TAB;
      o.scope = <span class="keyword">new</span> Scope(<span class="literal">null</span>, <span class="keyword">this</span>, <span class="literal">null</span>);
      o.level = LEVEL_TOP;
      <span class="keyword">this</span>.spaced = <span class="literal">true</span>;
      prelude = <span class="string">""</span>;
      <span class="keyword">if</span> (!o.bare) {
        preludeExps = (<span class="keyword">function</span>() {
          <span class="keyword">var</span> _i, _len, _ref2, _results;
          _ref2 = <span class="keyword">this</span>.expressions;
          _results = [];
          <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; i = ++_i) {
            exp = _ref2[i];
            <span class="keyword">if</span> (!(exp.unwrap() <span class="keyword">instanceof</span> Comment)) {
              <span class="keyword">break</span>;
            }
            _results.push(exp);
          }
          <span class="keyword">return</span> _results;
        }).call(<span class="keyword">this</span>);
        rest = <span class="keyword">this</span>.expressions.slice(preludeExps.length);
        <span class="keyword">this</span>.expressions = preludeExps;
        <span class="keyword">if</span> (preludeExps.length) {
          prelude = <span class="string">""</span> + (<span class="keyword">this</span>.compileNode(merge(o, {
            indent: <span class="string">''</span>
          }))) + <span class="string">"\n"</span>;
        }
        <span class="keyword">this</span>.expressions = rest;
      }
      code = <span class="keyword">this</span>.compileWithDeclarations(o);
      <span class="keyword">if</span> (o.bare) {
        <span class="keyword">return</span> code;
      }
      <span class="keyword">return</span> <span class="string">""</span> + prelude + <span class="string">"(function() {\n"</span> + code + <span class="string">"\n}).call(this);\n"</span>;
    };

    Block.prototype.compileWithDeclarations = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> assigns, code, declars, exp, i, post, rest, scope, spaced, _i, _len, _ref2, _ref3, _ref4;
      code = post = <span class="string">''</span>;
      _ref2 = <span class="keyword">this</span>.expressions;
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; i = ++_i) {
        exp = _ref2[i];
        exp = exp.unwrap();
        <span class="keyword">if</span> (!(exp <span class="keyword">instanceof</span> Comment || exp <span class="keyword">instanceof</span> Literal)) {
          <span class="keyword">break</span>;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      <span class="keyword">if</span> (i) {
        rest = <span class="keyword">this</span>.expressions.splice(i, <span class="number">9e9</span>);
        _ref3 = [<span class="keyword">this</span>.spaced, <span class="literal">false</span>], spaced = _ref3[<span class="number">0</span>], <span class="keyword">this</span>.spaced = _ref3[<span class="number">1</span>];
        _ref4 = [<span class="keyword">this</span>.compileNode(o), spaced], code = _ref4[<span class="number">0</span>], <span class="keyword">this</span>.spaced = _ref4[<span class="number">1</span>];
        <span class="keyword">this</span>.expressions = rest;
      }
      post = <span class="keyword">this</span>.compileNode(o);
      scope = o.scope;
      <span class="keyword">if</span> (scope.expressions === <span class="keyword">this</span>) {
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        <span class="keyword">if</span> (declars || assigns) {
          <span class="keyword">if</span> (i) {
            code += <span class="string">'\n'</span>;
          }
          code += <span class="string">""</span> + <span class="keyword">this</span>.tab + <span class="string">"var "</span>;
          <span class="keyword">if</span> (declars) {
            code += scope.declaredVariables().join(<span class="string">', '</span>);
          }
          <span class="keyword">if</span> (assigns) {
            <span class="keyword">if</span> (declars) {
              code += <span class="string">",\n"</span> + (<span class="keyword">this</span>.tab + TAB);
            }
            code += scope.assignedVariables().join(<span class="string">",\n"</span> + (<span class="keyword">this</span>.tab + TAB));
          }
          code += <span class="string">';\n'</span>;
        }
      }
      <span class="keyword">return</span> code + post;
    };

    Block.wrap = <span class="keyword">function</span>(nodes) {
      <span class="keyword">if</span> (nodes.length === <span class="number">1</span> &amp;&amp; nodes[<span class="number">0</span>] <span class="keyword">instanceof</span> Block) {
        <span class="keyword">return</span> nodes[<span class="number">0</span>];
      }
      <span class="keyword">return</span> <span class="keyword">new</span> Block(nodes);
    };

    <span class="keyword">return</span> Block;

  })(Base);

  exports.Literal = Literal = (<span class="keyword">function</span>(_super) {

    __extends(Literal, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Literal</span><span class="params">(value)</span> {</span>
      <span class="keyword">this</span>.value = value;
    }

    Literal.prototype.makeReturn = <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.isStatement()) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> Literal.__super__.makeReturn.apply(<span class="keyword">this</span>, arguments);
      }
    };

    Literal.prototype.isAssignable = <span class="keyword">function</span>() {
      <span class="keyword">return</span> IDENTIFIER.test(<span class="keyword">this</span>.value);
    };

    Literal.prototype.isStatement = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> (_ref2 = <span class="keyword">this</span>.value) === <span class="string">'break'</span> || _ref2 === <span class="string">'continue'</span> || _ref2 === <span class="string">'debugger'</span>;
    };

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> name === <span class="keyword">this</span>.value;
    };

    Literal.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.value === <span class="string">'break'</span> &amp;&amp; !((o != <span class="literal">null</span> ? o.loop : <span class="keyword">void</span> <span class="number">0</span>) || (o != <span class="literal">null</span> ? o.block : <span class="keyword">void</span> <span class="number">0</span>))) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.value === <span class="string">'continue'</span> &amp;&amp; !(o != <span class="literal">null</span> ? o.loop : <span class="keyword">void</span> <span class="number">0</span>)) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
    };

    Literal.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, _ref2;
      code = <span class="keyword">this</span>.value === <span class="string">'this'</span> ? ((_ref2 = o.scope.method) != <span class="literal">null</span> ? _ref2.bound : <span class="keyword">void</span> <span class="number">0</span>) ? o.scope.method.context : <span class="keyword">this</span>.value : <span class="keyword">this</span>.value.reserved ? <span class="string">"\""</span> + <span class="keyword">this</span>.value + <span class="string">"\""</span> : <span class="keyword">this</span>.value;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isStatement()) {
        <span class="keyword">return</span> <span class="string">""</span> + <span class="keyword">this</span>.tab + code + <span class="string">";"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> code;
      }
    };

    Literal.prototype.toString = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">' "'</span> + <span class="keyword">this</span>.value + <span class="string">'"'</span>;
    };

    <span class="keyword">return</span> Literal;

  })(Base);

  exports.Undefined = (<span class="keyword">function</span>(_super) {

    __extends(Undefined, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Undefined</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> Undefined.__super__.constructor.apply(<span class="keyword">this</span>, arguments);
    }

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">if</span> (o.level >= LEVEL_ACCESS) {
        <span class="keyword">return</span> <span class="string">'(void 0)'</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">'void 0'</span>;
      }
    };

    <span class="keyword">return</span> Undefined;

  })(Base);

  exports.Null = (<span class="keyword">function</span>(_super) {

    __extends(Null, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Null</span><span class="params">()</span> {</span>
      <span class="keyword">return</span> Null.__super__.constructor.apply(<span class="keyword">this</span>, arguments);
    }

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">"null"</span>;
    };

    <span class="keyword">return</span> Null;

  })(Base);

  exports.Bool = (<span class="keyword">function</span>(_super) {

    __extends(Bool, _super);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.val;
    };

    <span class="function"><span class="keyword">function</span> <span class="title">Bool</span><span class="params">(val)</span> {</span>
      <span class="keyword">this</span>.val = val;
    }

    <span class="keyword">return</span> Bool;

  })(Base);

  exports.Return = Return = (<span class="keyword">function</span>(_super) {

    __extends(Return, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Return</span><span class="params">(expr)</span> {</span>
      <span class="keyword">if</span> (expr &amp;&amp; !expr.unwrap().isUndefined) {
        <span class="keyword">this</span>.expression = expr;
      }
    }

    Return.prototype.children = [<span class="string">'expression'</span>];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compile = <span class="keyword">function</span>(o, level) {
      <span class="keyword">var</span> expr, _ref2;
      expr = (_ref2 = <span class="keyword">this</span>.expression) != <span class="literal">null</span> ? _ref2.makeReturn() : <span class="keyword">void</span> <span class="number">0</span>;
      <span class="keyword">if</span> (expr &amp;&amp; !(expr <span class="keyword">instanceof</span> Return)) {
        <span class="keyword">return</span> expr.compile(o, level);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> Return.__super__.compile.call(<span class="keyword">this</span>, o, level);
      }
    };

    Return.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> <span class="keyword">this</span>.tab + (<span class="string">"return"</span> + [<span class="keyword">this</span>.expression ? <span class="string">" "</span> + (<span class="keyword">this</span>.expression.compile(o, LEVEL_PAREN)) : <span class="keyword">void</span> <span class="number">0</span>] + <span class="string">";"</span>);
    };

    <span class="keyword">return</span> Return;

  })(Base);

  exports.Value = Value = (<span class="keyword">function</span>(_super) {

    __extends(Value, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Value</span><span class="params">(base, props, tag)</span> {</span>
      <span class="keyword">if</span> (!props &amp;&amp; base <span class="keyword">instanceof</span> Value) {
        <span class="keyword">return</span> base;
      }
      <span class="keyword">this</span>.base = base;
      <span class="keyword">this</span>.properties = props || [];
      <span class="keyword">if</span> (tag) {
        <span class="keyword">this</span>[tag] = <span class="literal">true</span>;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    Value.prototype.children = [<span class="string">'base'</span>, <span class="string">'properties'</span>];

    Value.prototype.add = <span class="keyword">function</span>(props) {
      <span class="keyword">this</span>.properties = <span class="keyword">this</span>.properties.concat(props);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Value.prototype.hasProperties = <span class="keyword">function</span>() {
      <span class="keyword">return</span> !!<span class="keyword">this</span>.properties.length;
    };

    Value.prototype.isArray = <span class="keyword">function</span>() {
      <span class="keyword">return</span> !<span class="keyword">this</span>.properties.length &amp;&amp; <span class="keyword">this</span>.base <span class="keyword">instanceof</span> Arr;
    };

    Value.prototype.isComplex = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.hasProperties() || <span class="keyword">this</span>.base.isComplex();
    };

    Value.prototype.isAssignable = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.hasProperties() || <span class="keyword">this</span>.base.isAssignable();
    };

    Value.prototype.isSimpleNumber = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.base <span class="keyword">instanceof</span> Literal &amp;&amp; SIMPLENUM.test(<span class="keyword">this</span>.base.value);
    };

    Value.prototype.isString = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.base <span class="keyword">instanceof</span> Literal &amp;&amp; IS_STRING.test(<span class="keyword">this</span>.base.value);
    };

    Value.prototype.isAtomic = <span class="keyword">function</span>() {
      <span class="keyword">var</span> node, _i, _len, _ref2;
      _ref2 = <span class="keyword">this</span>.properties.concat(<span class="keyword">this</span>.base);
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        node = _ref2[_i];
        <span class="keyword">if</span> (node.soak || node <span class="keyword">instanceof</span> Call) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
      }
      <span class="keyword">return</span> <span class="literal">true</span>;
    };

    Value.prototype.isStatement = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> !<span class="keyword">this</span>.properties.length &amp;&amp; <span class="keyword">this</span>.base.isStatement(o);
    };

    Value.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> !<span class="keyword">this</span>.properties.length &amp;&amp; <span class="keyword">this</span>.base.assigns(name);
    };

    Value.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> !<span class="keyword">this</span>.properties.length &amp;&amp; <span class="keyword">this</span>.base.jumps(o);
    };

    Value.prototype.isObject = <span class="keyword">function</span>(onlyGenerated) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.properties.length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      <span class="keyword">return</span> (<span class="keyword">this</span>.base <span class="keyword">instanceof</span> Obj) &amp;&amp; (!onlyGenerated || <span class="keyword">this</span>.base.generated);
    };

    Value.prototype.isSplice = <span class="keyword">function</span>() {
      <span class="keyword">return</span> last(<span class="keyword">this</span>.properties) <span class="keyword">instanceof</span> Slice;
    };

    Value.prototype.unwrap = <span class="keyword">function</span>() {
      <span class="keyword">if</span> (<span class="keyword">this</span>.properties.length) {
        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.base;
      }
    };

    Value.prototype.cacheReference = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> base, bref, name, nref;
      name = last(<span class="keyword">this</span>.properties);
      <span class="keyword">if</span> (<span class="keyword">this</span>.properties.length &lt; <span class="number">2</span> &amp;&amp; !<span class="keyword">this</span>.base.isComplex() &amp;&amp; !(name != <span class="literal">null</span> ? name.isComplex() : <span class="keyword">void</span> <span class="number">0</span>)) {
        <span class="keyword">return</span> [<span class="keyword">this</span>, <span class="keyword">this</span>];
      }
      base = <span class="keyword">new</span> Value(<span class="keyword">this</span>.base, <span class="keyword">this</span>.properties.slice(<span class="number">0</span>, -<span class="number">1</span>));
      <span class="keyword">if</span> (base.isComplex()) {
        bref = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'base'</span>));
        base = <span class="keyword">new</span> Value(<span class="keyword">new</span> Parens(<span class="keyword">new</span> Assign(bref, base)));
      }
      <span class="keyword">if</span> (!name) {
        <span class="keyword">return</span> [base, bref];
      }
      <span class="keyword">if</span> (name.isComplex()) {
        nref = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'name'</span>));
        name = <span class="keyword">new</span> Index(<span class="keyword">new</span> Assign(nref, name.index));
        nref = <span class="keyword">new</span> Index(nref);
      }
      <span class="keyword">return</span> [base.add(name), <span class="keyword">new</span> Value(bref || base.base, [nref || name])];
    };

    Value.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, prop, props, _i, _len;
      <span class="keyword">this</span>.base.front = <span class="keyword">this</span>.front;
      props = <span class="keyword">this</span>.properties;
      code = <span class="keyword">this</span>.base.compile(o, props.length ? LEVEL_ACCESS : <span class="literal">null</span>);
      <span class="keyword">if</span> ((<span class="keyword">this</span>.base <span class="keyword">instanceof</span> Parens || props.length) &amp;&amp; SIMPLENUM.test(code)) {
        code = <span class="string">""</span> + code + <span class="string">"."</span>;
      }
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = props.length; _i &lt; _len; _i++) {
        prop = props[_i];
        code += prop.compile(o);
      }
      <span class="keyword">return</span> code;
    };

    Value.prototype.unfoldSoak = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> result,
        _<span class="keyword">this</span> = <span class="keyword">this</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.unfoldedSoak != <span class="literal">null</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.unfoldedSoak;
      }
      result = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> fst, i, ifn, prop, ref, snd, _i, _len, _ref2;
        <span class="keyword">if</span> (ifn = _<span class="keyword">this</span>.base.unfoldSoak(o)) {
          Array.prototype.push.apply(ifn.body.properties, _<span class="keyword">this</span>.properties);
          <span class="keyword">return</span> ifn;
        }
        _ref2 = _<span class="keyword">this</span>.properties;
        <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; i = ++_i) {
          prop = _ref2[i];
          <span class="keyword">if</span> (!prop.soak) {
            <span class="keyword">continue</span>;
          }
          prop.soak = <span class="literal">false</span>;
          fst = <span class="keyword">new</span> Value(_<span class="keyword">this</span>.base, _<span class="keyword">this</span>.properties.slice(<span class="number">0</span>, i));
          snd = <span class="keyword">new</span> Value(_<span class="keyword">this</span>.base, _<span class="keyword">this</span>.properties.slice(i));
          <span class="keyword">if</span> (fst.isComplex()) {
            ref = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'ref'</span>));
            fst = <span class="keyword">new</span> Parens(<span class="keyword">new</span> Assign(ref, fst));
            snd.base = ref;
          }
          <span class="keyword">return</span> <span class="keyword">new</span> If(<span class="keyword">new</span> Existence(fst), snd, {
            soak: <span class="literal">true</span>
          });
        }
        <span class="keyword">return</span> <span class="literal">null</span>;
      })();
      <span class="keyword">return</span> <span class="keyword">this</span>.unfoldedSoak = result || <span class="literal">false</span>;
    };

    <span class="keyword">return</span> Value;

  })(Base);

  exports.Comment = Comment = (<span class="keyword">function</span>(_super) {

    __extends(Comment, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Comment</span><span class="params">(comment)</span> {</span>
      <span class="keyword">this</span>.comment = comment;
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = <span class="keyword">function</span>(o, level) {
      <span class="keyword">var</span> code;
      code = <span class="string">'/*'</span> + multident(<span class="keyword">this</span>.comment, <span class="keyword">this</span>.tab) + (<span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"*/\n"</span>);
      <span class="keyword">if</span> ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      <span class="keyword">return</span> code;
    };

    <span class="keyword">return</span> Comment;

  })(Base);

  exports.Call = Call = (<span class="keyword">function</span>(_super) {

    __extends(Call, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Call</span><span class="params">(variable, args, soak)</span> {</span>
      <span class="keyword">this</span>.args = args != <span class="literal">null</span> ? args : [];
      <span class="keyword">this</span>.soak = soak;
      <span class="keyword">this</span>.isNew = <span class="literal">false</span>;
      <span class="keyword">this</span>.isSuper = variable === <span class="string">'super'</span>;
      <span class="keyword">this</span>.variable = <span class="keyword">this</span>.isSuper ? <span class="literal">null</span> : variable;
    }

    Call.prototype.children = [<span class="string">'variable'</span>, <span class="string">'args'</span>];

    Call.prototype.newInstance = <span class="keyword">function</span>() {
      <span class="keyword">var</span> base, _ref2;
      base = ((_ref2 = <span class="keyword">this</span>.variable) != <span class="literal">null</span> ? _ref2.base : <span class="keyword">void</span> <span class="number">0</span>) || <span class="keyword">this</span>.variable;
      <span class="keyword">if</span> (base <span class="keyword">instanceof</span> Call &amp;&amp; !base.isNew) {
        base.newInstance();
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.isNew = <span class="literal">true</span>;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Call.prototype.superReference = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> accesses, method, name;
      method = o.scope.namedMethod();
      <span class="keyword">if</span> (!method) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'cannot call super outside of a function.'</span>);
      }
      name = method.name;
      <span class="keyword">if</span> (name == <span class="literal">null</span>) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'cannot call super on an anonymous function.'</span>);
      }
      <span class="keyword">if</span> (method.klass) {
        accesses = [<span class="keyword">new</span> Access(<span class="keyword">new</span> Literal(<span class="string">'__super__'</span>))];
        <span class="keyword">if</span> (method[<span class="string">"static"</span>]) {
          accesses.push(<span class="keyword">new</span> Access(<span class="keyword">new</span> Literal(<span class="string">'constructor'</span>)));
        }
        accesses.push(<span class="keyword">new</span> Access(<span class="keyword">new</span> Literal(name)));
        <span class="keyword">return</span> (<span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(method.klass), accesses)).compile(o);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">""</span> + name + <span class="string">".__super__.constructor"</span>;
      }
    };

    Call.prototype.superThis = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> method;
      method = o.scope.method;
      <span class="keyword">return</span> (method &amp;&amp; !method.klass &amp;&amp; method.context) || <span class="string">"this"</span>;
    };

    Call.prototype.unfoldSoak = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> call, ifn, left, list, rite, _i, _len, _ref2, _ref3;
      <span class="keyword">if</span> (<span class="keyword">this</span>.soak) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.variable) {
          <span class="keyword">if</span> (ifn = unfoldSoak(o, <span class="keyword">this</span>, <span class="string">'variable'</span>)) {
            <span class="keyword">return</span> ifn;
          }
          _ref2 = <span class="keyword">new</span> Value(<span class="keyword">this</span>.variable).cacheReference(o), left = _ref2[<span class="number">0</span>], rite = _ref2[<span class="number">1</span>];
        } <span class="keyword">else</span> {
          left = <span class="keyword">new</span> Literal(<span class="keyword">this</span>.superReference(o));
          rite = <span class="keyword">new</span> Value(left);
        }
        rite = <span class="keyword">new</span> Call(rite, <span class="keyword">this</span>.args);
        rite.isNew = <span class="keyword">this</span>.isNew;
        left = <span class="keyword">new</span> Literal(<span class="string">"typeof "</span> + (left.compile(o)) + <span class="string">" === \"function\""</span>);
        <span class="keyword">return</span> <span class="keyword">new</span> If(left, <span class="keyword">new</span> Value(rite), {
          soak: <span class="literal">true</span>
        });
      }
      call = <span class="keyword">this</span>;
      list = [];
      <span class="keyword">while</span> (<span class="literal">true</span>) {
        <span class="keyword">if</span> (call.variable <span class="keyword">instanceof</span> Call) {
          list.push(call);
          call = call.variable;
          <span class="keyword">continue</span>;
        }
        <span class="keyword">if</span> (!(call.variable <span class="keyword">instanceof</span> Value)) {
          <span class="keyword">break</span>;
        }
        list.push(call);
        <span class="keyword">if</span> (!((call = call.variable.base) <span class="keyword">instanceof</span> Call)) {
          <span class="keyword">break</span>;
        }
      }
      _ref3 = list.reverse();
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref3.length; _i &lt; _len; _i++) {
        call = _ref3[_i];
        <span class="keyword">if</span> (ifn) {
          <span class="keyword">if</span> (call.variable <span class="keyword">instanceof</span> Call) {
            call.variable = ifn;
          } <span class="keyword">else</span> {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, <span class="string">'variable'</span>);
      }
      <span class="keyword">return</span> ifn;
    };

    Call.prototype.filterImplicitObjects = <span class="keyword">function</span>(list) {
      <span class="keyword">var</span> node, nodes, obj, prop, properties, _i, _j, _len, _len1, _ref2;
      nodes = [];
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = list.length; _i &lt; _len; _i++) {
        node = list[_i];
        <span class="keyword">if</span> (!((<span class="keyword">typeof</span> node.isObject === <span class="string">"function"</span> ? node.isObject() : <span class="keyword">void</span> <span class="number">0</span>) &amp;&amp; node.base.generated)) {
          nodes.push(node);
          <span class="keyword">continue</span>;
        }
        obj = <span class="literal">null</span>;
        _ref2 = node.base.properties;
        <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.length; _j &lt; _len1; _j++) {
          prop = _ref2[_j];
          <span class="keyword">if</span> (prop <span class="keyword">instanceof</span> Assign || prop <span class="keyword">instanceof</span> Comment) {
            <span class="keyword">if</span> (!obj) {
              nodes.push(obj = <span class="keyword">new</span> Obj(properties = [], <span class="literal">true</span>));
            }
            properties.push(prop);
          } <span class="keyword">else</span> {
            nodes.push(prop);
            obj = <span class="literal">null</span>;
          }
        }
      }
      <span class="keyword">return</span> nodes;
    };

    Call.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> arg, args, code, _ref2;
      <span class="keyword">if</span> ((_ref2 = <span class="keyword">this</span>.variable) != <span class="literal">null</span>) {
        _ref2.front = <span class="keyword">this</span>.front;
      }
      <span class="keyword">if</span> (code = Splat.compileSplattedArray(o, <span class="keyword">this</span>.args, <span class="literal">true</span>)) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileSplat(o, code);
      }
      args = <span class="keyword">this</span>.filterImplicitObjects(<span class="keyword">this</span>.args);
      args = ((<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _results;
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = args.length; _i &lt; _len; _i++) {
          arg = args[_i];
          _results.push(arg.compile(o, LEVEL_LIST));
        }
        <span class="keyword">return</span> _results;
      })()).join(<span class="string">', '</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.isSuper) {
        <span class="keyword">return</span> <span class="keyword">this</span>.superReference(o) + (<span class="string">".call("</span> + (<span class="keyword">this</span>.superThis(o)) + (args &amp;&amp; <span class="string">', '</span> + args) + <span class="string">")"</span>);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> (<span class="keyword">this</span>.isNew ? <span class="string">'new '</span> : <span class="string">''</span>) + <span class="keyword">this</span>.variable.compile(o, LEVEL_ACCESS) + (<span class="string">"("</span> + args + <span class="string">")"</span>);
      }
    };

    Call.prototype.compileSuper = <span class="keyword">function</span>(args, o) {
      <span class="keyword">return</span> <span class="string">""</span> + (<span class="keyword">this</span>.superReference(o)) + <span class="string">".call("</span> + (<span class="keyword">this</span>.superThis(o)) + (args.length ? <span class="string">', '</span> : <span class="string">''</span>) + args + <span class="string">")"</span>;
    };

    Call.prototype.compileSplat = <span class="keyword">function</span>(o, splatArgs) {
      <span class="keyword">var</span> base, fun, idt, name, ref;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isSuper) {
        <span class="keyword">return</span> <span class="string">""</span> + (<span class="keyword">this</span>.superReference(o)) + <span class="string">".apply("</span> + (<span class="keyword">this</span>.superThis(o)) + <span class="string">", "</span> + splatArgs + <span class="string">")"</span>;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.isNew) {
        idt = <span class="keyword">this</span>.tab + TAB;
        <span class="keyword">return</span> <span class="string">"(function(func, args, ctor) {\n"</span> + idt + <span class="string">"ctor.prototype = func.prototype;\n"</span> + idt + <span class="string">"var child = new ctor, result = func.apply(child, args);\n"</span> + idt + <span class="string">"return Object(result) === result ? result : child;\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"})("</span> + (<span class="keyword">this</span>.variable.compile(o, LEVEL_LIST)) + <span class="string">", "</span> + splatArgs + <span class="string">", function(){})"</span>;
      }
      base = <span class="keyword">new</span> Value(<span class="keyword">this</span>.variable);
      <span class="keyword">if</span> ((name = base.properties.pop()) &amp;&amp; base.isComplex()) {
        ref = o.scope.freeVariable(<span class="string">'ref'</span>);
        fun = <span class="string">"("</span> + ref + <span class="string">" = "</span> + (base.compile(o, LEVEL_LIST)) + <span class="string">")"</span> + (name.compile(o));
      } <span class="keyword">else</span> {
        fun = base.compile(o, LEVEL_ACCESS);
        <span class="keyword">if</span> (SIMPLENUM.test(fun)) {
          fun = <span class="string">"("</span> + fun + <span class="string">")"</span>;
        }
        <span class="keyword">if</span> (name) {
          ref = fun;
          fun += name.compile(o);
        } <span class="keyword">else</span> {
          ref = <span class="string">'null'</span>;
        }
      }
      <span class="keyword">return</span> <span class="string">""</span> + fun + <span class="string">".apply("</span> + ref + <span class="string">", "</span> + splatArgs + <span class="string">")"</span>;
    };

    <span class="keyword">return</span> Call;

  })(Base);

  exports.Extends = Extends = (<span class="keyword">function</span>(_super) {

    __extends(Extends, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Extends</span><span class="params">(child, parent)</span> {</span>
      <span class="keyword">this</span>.child = child;
      <span class="keyword">this</span>.parent = parent;
    }

    Extends.prototype.children = [<span class="string">'child'</span>, <span class="string">'parent'</span>];

    Extends.prototype.compile = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> <span class="keyword">new</span> Call(<span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(utility(<span class="string">'extends'</span>))), [<span class="keyword">this</span>.child, <span class="keyword">this</span>.parent]).compile(o);
    };

    <span class="keyword">return</span> Extends;

  })(Base);

  exports.Access = Access = (<span class="keyword">function</span>(_super) {

    __extends(Access, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Access</span><span class="params">(name, tag)</span> {</span>
      <span class="keyword">this</span>.name = name;
      <span class="keyword">this</span>.name.asKey = <span class="literal">true</span>;
      <span class="keyword">this</span>.soak = tag === <span class="string">'soak'</span>;
    }

    Access.prototype.children = [<span class="string">'name'</span>];

    Access.prototype.compile = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> name;
      name = <span class="keyword">this</span>.name.compile(o);
      <span class="keyword">if</span> (IDENTIFIER.test(name)) {
        <span class="keyword">return</span> <span class="string">"."</span> + name;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"["</span> + name + <span class="string">"]"</span>;
      }
    };

    Access.prototype.isComplex = NO;

    <span class="keyword">return</span> Access;

  })(Base);

  exports.Index = Index = (<span class="keyword">function</span>(_super) {

    __extends(Index, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Index</span><span class="params">(index)</span> {</span>
      <span class="keyword">this</span>.index = index;
    }

    Index.prototype.children = [<span class="string">'index'</span>];

    Index.prototype.compile = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> <span class="string">"["</span> + (<span class="keyword">this</span>.index.compile(o, LEVEL_PAREN)) + <span class="string">"]"</span>;
    };

    Index.prototype.isComplex = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.index.isComplex();
    };

    <span class="keyword">return</span> Index;

  })(Base);

  exports.Range = Range = (<span class="keyword">function</span>(_super) {

    __extends(Range, _super);

    Range.prototype.children = [<span class="string">'from'</span>, <span class="string">'to'</span>];

    <span class="function"><span class="keyword">function</span> <span class="title">Range</span><span class="params">(from, to, tag)</span> {</span>
      <span class="keyword">this</span>.from = from;
      <span class="keyword">this</span>.to = to;
      <span class="keyword">this</span>.exclusive = tag === <span class="string">'exclusive'</span>;
      <span class="keyword">this</span>.equals = <span class="keyword">this</span>.exclusive ? <span class="string">''</span> : <span class="string">'='</span>;
    }

    Range.prototype.compileVariables = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> step, _ref2, _ref3, _ref4, _ref5;
      o = merge(o, {
        top: <span class="literal">true</span>
      });
      _ref2 = <span class="keyword">this</span>.from.cache(o, LEVEL_LIST), <span class="keyword">this</span>.fromC = _ref2[<span class="number">0</span>], <span class="keyword">this</span>.fromVar = _ref2[<span class="number">1</span>];
      _ref3 = <span class="keyword">this</span>.to.cache(o, LEVEL_LIST), <span class="keyword">this</span>.toC = _ref3[<span class="number">0</span>], <span class="keyword">this</span>.toVar = _ref3[<span class="number">1</span>];
      <span class="keyword">if</span> (step = del(o, <span class="string">'step'</span>)) {
        _ref4 = step.cache(o, LEVEL_LIST), <span class="keyword">this</span>.step = _ref4[<span class="number">0</span>], <span class="keyword">this</span>.stepVar = _ref4[<span class="number">1</span>];
      }
      _ref5 = [<span class="keyword">this</span>.fromVar.match(SIMPLENUM), <span class="keyword">this</span>.toVar.match(SIMPLENUM)], <span class="keyword">this</span>.fromNum = _ref5[<span class="number">0</span>], <span class="keyword">this</span>.toNum = _ref5[<span class="number">1</span>];
      <span class="keyword">if</span> (<span class="keyword">this</span>.stepVar) {
        <span class="keyword">return</span> <span class="keyword">this</span>.stepNum = <span class="keyword">this</span>.stepVar.match(SIMPLENUM);
      }
    };

    Range.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, stepPart, to, varPart, _ref2, _ref3;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.fromVar) {
        <span class="keyword">this</span>.compileVariables(o);
      }
      <span class="keyword">if</span> (!o.index) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileArray(o);
      }
      known = <span class="keyword">this</span>.fromNum &amp;&amp; <span class="keyword">this</span>.toNum;
      idx = del(o, <span class="string">'index'</span>);
      idxName = del(o, <span class="string">'name'</span>);
      namedIndex = idxName &amp;&amp; idxName !== idx;
      varPart = <span class="string">""</span> + idx + <span class="string">" = "</span> + <span class="keyword">this</span>.fromC;
      <span class="keyword">if</span> (<span class="keyword">this</span>.toC !== <span class="keyword">this</span>.toVar) {
        varPart += <span class="string">", "</span> + <span class="keyword">this</span>.toC;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.step !== <span class="keyword">this</span>.stepVar) {
        varPart += <span class="string">", "</span> + <span class="keyword">this</span>.step;
      }
      _ref2 = [<span class="string">""</span> + idx + <span class="string">" &lt;"</span> + <span class="keyword">this</span>.equals, <span class="string">""</span> + idx + <span class="string">" >"</span> + <span class="keyword">this</span>.equals], lt = _ref2[<span class="number">0</span>], gt = _ref2[<span class="number">1</span>];
      condPart = <span class="keyword">this</span>.stepNum ? +<span class="keyword">this</span>.stepNum > <span class="number">0</span> ? <span class="string">""</span> + lt + <span class="string">" "</span> + <span class="keyword">this</span>.toVar : <span class="string">""</span> + gt + <span class="string">" "</span> + <span class="keyword">this</span>.toVar : known ? ((_ref3 = [+<span class="keyword">this</span>.fromNum, +<span class="keyword">this</span>.toNum], from = _ref3[<span class="number">0</span>], to = _ref3[<span class="number">1</span>], _ref3), from &lt;= to ? <span class="string">""</span> + lt + <span class="string">" "</span> + to : <span class="string">""</span> + gt + <span class="string">" "</span> + to) : (cond = <span class="string">""</span> + <span class="keyword">this</span>.fromVar + <span class="string">" &lt;= "</span> + <span class="keyword">this</span>.toVar, <span class="string">""</span> + cond + <span class="string">" ? "</span> + lt + <span class="string">" "</span> + <span class="keyword">this</span>.toVar + <span class="string">" : "</span> + gt + <span class="string">" "</span> + <span class="keyword">this</span>.toVar);
      stepPart = <span class="keyword">this</span>.stepVar ? <span class="string">""</span> + idx + <span class="string">" += "</span> + <span class="keyword">this</span>.stepVar : known ? namedIndex ? from &lt;= to ? <span class="string">"++"</span> + idx : <span class="string">"--"</span> + idx : from &lt;= to ? <span class="string">""</span> + idx + <span class="string">"++"</span> : <span class="string">""</span> + idx + <span class="string">"--"</span> : namedIndex ? <span class="string">""</span> + cond + <span class="string">" ? ++"</span> + idx + <span class="string">" : --"</span> + idx : <span class="string">""</span> + cond + <span class="string">" ? "</span> + idx + <span class="string">"++ : "</span> + idx + <span class="string">"--"</span>;
      <span class="keyword">if</span> (namedIndex) {
        varPart = <span class="string">""</span> + idxName + <span class="string">" = "</span> + varPart;
      }
      <span class="keyword">if</span> (namedIndex) {
        stepPart = <span class="string">""</span> + idxName + <span class="string">" = "</span> + stepPart;
      }
      <span class="keyword">return</span> <span class="string">""</span> + varPart + <span class="string">"; "</span> + condPart + <span class="string">"; "</span> + stepPart;
    };

    Range.prototype.compileArray = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> args, body, cond, hasArgs, i, idt, post, pre, range, result, vars, _i, _ref2, _ref3, _results;
      <span class="keyword">if</span> (<span class="keyword">this</span>.fromNum &amp;&amp; <span class="keyword">this</span>.toNum &amp;&amp; Math.abs(<span class="keyword">this</span>.fromNum - <span class="keyword">this</span>.toNum) &lt;= <span class="number">20</span>) {
        range = (<span class="keyword">function</span>() {
          _results = [];
          <span class="keyword">for</span> (<span class="keyword">var</span> _i = _ref2 = +<span class="keyword">this</span>.fromNum, _ref3 = +<span class="keyword">this</span>.toNum; _ref2 &lt;= _ref3 ? _i &lt;= _ref3 : _i >= _ref3; _ref2 &lt;= _ref3 ? _i++ : _i--){ _results.push(_i); }
          <span class="keyword">return</span> _results;
        }).apply(<span class="keyword">this</span>);
        <span class="keyword">if</span> (<span class="keyword">this</span>.exclusive) {
          range.pop();
        }
        <span class="keyword">return</span> <span class="string">"["</span> + (range.join(<span class="string">', '</span>)) + <span class="string">"]"</span>;
      }
      idt = <span class="keyword">this</span>.tab + TAB;
      i = o.scope.freeVariable(<span class="string">'i'</span>);
      result = o.scope.freeVariable(<span class="string">'results'</span>);
      pre = <span class="string">"\n"</span> + idt + result + <span class="string">" = [];"</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.fromNum &amp;&amp; <span class="keyword">this</span>.toNum) {
        o.index = i;
        body = <span class="keyword">this</span>.compileNode(o);
      } <span class="keyword">else</span> {
        vars = (<span class="string">""</span> + i + <span class="string">" = "</span> + <span class="keyword">this</span>.fromC) + (<span class="keyword">this</span>.toC !== <span class="keyword">this</span>.toVar ? <span class="string">", "</span> + <span class="keyword">this</span>.toC : <span class="string">''</span>);
        cond = <span class="string">""</span> + <span class="keyword">this</span>.fromVar + <span class="string">" &lt;= "</span> + <span class="keyword">this</span>.toVar;
        body = <span class="string">"var "</span> + vars + <span class="string">"; "</span> + cond + <span class="string">" ? "</span> + i + <span class="string">" &lt;"</span> + <span class="keyword">this</span>.equals + <span class="string">" "</span> + <span class="keyword">this</span>.toVar + <span class="string">" : "</span> + i + <span class="string">" >"</span> + <span class="keyword">this</span>.equals + <span class="string">" "</span> + <span class="keyword">this</span>.toVar + <span class="string">"; "</span> + cond + <span class="string">" ? "</span> + i + <span class="string">"++ : "</span> + i + <span class="string">"--"</span>;
      }
      post = <span class="string">"{ "</span> + result + <span class="string">".push("</span> + i + <span class="string">"); }\n"</span> + idt + <span class="string">"return "</span> + result + <span class="string">";\n"</span> + o.indent;
      hasArgs = <span class="keyword">function</span>(node) {
        <span class="keyword">return</span> node != <span class="literal">null</span> ? node.contains(<span class="keyword">function</span>(n) {
          <span class="keyword">return</span> n <span class="keyword">instanceof</span> Literal &amp;&amp; n.value === <span class="string">'arguments'</span> &amp;&amp; !n.asKey;
        }) : <span class="keyword">void</span> <span class="number">0</span>;
      };
      <span class="keyword">if</span> (hasArgs(<span class="keyword">this</span>.from) || hasArgs(<span class="keyword">this</span>.to)) {
        args = <span class="string">', arguments'</span>;
      }
      <span class="keyword">return</span> <span class="string">"(function() {"</span> + pre + <span class="string">"\n"</span> + idt + <span class="string">"for ("</span> + body + <span class="string">")"</span> + post + <span class="string">"}).apply(this"</span> + (args != <span class="literal">null</span> ? args : <span class="string">''</span>) + <span class="string">")"</span>;
    };

    <span class="keyword">return</span> Range;

  })(Base);

  exports.Slice = Slice = (<span class="keyword">function</span>(_super) {

    __extends(Slice, _super);

    Slice.prototype.children = [<span class="string">'range'</span>];

    <span class="function"><span class="keyword">function</span> <span class="title">Slice</span><span class="params">(range)</span> {</span>
      <span class="keyword">this</span>.range = range;
      Slice.__super__.constructor.call(<span class="keyword">this</span>);
    }

    Slice.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> compiled, from, fromStr, to, toStr, _ref2;
      _ref2 = <span class="keyword">this</span>.range, to = _ref2.to, from = _ref2.from;
      fromStr = from &amp;&amp; from.compile(o, LEVEL_PAREN) || <span class="string">'0'</span>;
      compiled = to &amp;&amp; to.compile(o, LEVEL_PAREN);
      <span class="keyword">if</span> (to &amp;&amp; !(!<span class="keyword">this</span>.range.exclusive &amp;&amp; +compiled === -<span class="number">1</span>)) {
        toStr = <span class="string">', '</span> + (<span class="keyword">this</span>.range.exclusive ? compiled : SIMPLENUM.test(compiled) ? <span class="string">""</span> + (+compiled + <span class="number">1</span>) : (compiled = to.compile(o, LEVEL_ACCESS), <span class="string">"+"</span> + compiled + <span class="string">" + 1 || 9e9"</span>));
      }
      <span class="keyword">return</span> <span class="string">".slice("</span> + fromStr + (toStr || <span class="string">''</span>) + <span class="string">")"</span>;
    };

    <span class="keyword">return</span> Slice;

  })(Base);

  exports.Obj = Obj = (<span class="keyword">function</span>(_super) {

    __extends(Obj, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">(props, generated)</span> {</span>
      <span class="keyword">this</span>.generated = generated != <span class="literal">null</span> ? generated : <span class="literal">false</span>;
      <span class="keyword">this</span>.objects = <span class="keyword">this</span>.properties = props || [];
    }

    Obj.prototype.children = [<span class="string">'properties'</span>];

    Obj.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> i, idt, indent, join, lastNoncom, node, obj, prop, props, _i, _len;
      props = <span class="keyword">this</span>.properties;
      <span class="keyword">if</span> (!props.length) {
        <span class="keyword">return</span> (<span class="keyword">this</span>.front ? <span class="string">'({})'</span> : <span class="string">'{}'</span>);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.generated) {
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = props.length; _i &lt; _len; _i++) {
          node = props[_i];
          <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Value) {
            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'cannot have an implicit value in an implicit object'</span>);
          }
        }
      }
      idt = o.indent += TAB;
      lastNoncom = <span class="keyword">this</span>.lastNonComment(<span class="keyword">this</span>.properties);
      props = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _j, _len1, _results;
        _results = [];
        <span class="keyword">for</span> (i = _j = <span class="number">0</span>, _len1 = props.length; _j &lt; _len1; i = ++_j) {
          prop = props[i];
          join = i === props.length - <span class="number">1</span> ? <span class="string">''</span> : prop === lastNoncom || prop <span class="keyword">instanceof</span> Comment ? <span class="string">'\n'</span> : <span class="string">',\n'</span>;
          indent = prop <span class="keyword">instanceof</span> Comment ? <span class="string">''</span> : idt;
          <span class="keyword">if</span> (prop <span class="keyword">instanceof</span> Value &amp;&amp; prop[<span class="string">"this"</span>]) {
            prop = <span class="keyword">new</span> Assign(prop.properties[<span class="number">0</span>].name, prop, <span class="string">'object'</span>);
          }
          <span class="keyword">if</span> (!(prop <span class="keyword">instanceof</span> Comment)) {
            <span class="keyword">if</span> (!(prop <span class="keyword">instanceof</span> Assign)) {
              prop = <span class="keyword">new</span> Assign(prop, prop, <span class="string">'object'</span>);
            }
            (prop.variable.base || prop.variable).asKey = <span class="literal">true</span>;
          }
          _results.push(indent + prop.compile(o, LEVEL_TOP) + join);
        }
        <span class="keyword">return</span> _results;
      })();
      props = props.join(<span class="string">''</span>);
      obj = <span class="string">"{"</span> + (props &amp;&amp; <span class="string">'\n'</span> + props + <span class="string">'\n'</span> + <span class="keyword">this</span>.tab) + <span class="string">"}"</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.front) {
        <span class="keyword">return</span> <span class="string">"("</span> + obj + <span class="string">")"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> obj;
      }
    };

    Obj.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">var</span> prop, _i, _len, _ref2;
      _ref2 = <span class="keyword">this</span>.properties;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        prop = _ref2[_i];
        <span class="keyword">if</span> (prop.assigns(name)) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    };

    <span class="keyword">return</span> Obj;

  })(Base);

  exports.Arr = Arr = (<span class="keyword">function</span>(_super) {

    __extends(Arr, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Arr</span><span class="params">(objs)</span> {</span>
      <span class="keyword">this</span>.objects = objs || [];
    }

    Arr.prototype.children = [<span class="string">'objects'</span>];

    Arr.prototype.filterImplicitObjects = Call.prototype.filterImplicitObjects;

    Arr.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, obj, objs;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.objects.length) {
        <span class="keyword">return</span> <span class="string">'[]'</span>;
      }
      o.indent += TAB;
      objs = <span class="keyword">this</span>.filterImplicitObjects(<span class="keyword">this</span>.objects);
      <span class="keyword">if</span> (code = Splat.compileSplattedArray(o, objs)) {
        <span class="keyword">return</span> code;
      }
      code = ((<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _results;
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = objs.length; _i &lt; _len; _i++) {
          obj = objs[_i];
          _results.push(obj.compile(o, LEVEL_LIST));
        }
        <span class="keyword">return</span> _results;
      })()).join(<span class="string">', '</span>);
      <span class="keyword">if</span> (code.indexOf(<span class="string">'\n'</span>) >= <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="string">"[\n"</span> + o.indent + code + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"]"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"["</span> + code + <span class="string">"]"</span>;
      }
    };

    Arr.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">var</span> obj, _i, _len, _ref2;
      _ref2 = <span class="keyword">this</span>.objects;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        obj = _ref2[_i];
        <span class="keyword">if</span> (obj.assigns(name)) {
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    };

    <span class="keyword">return</span> Arr;

  })(Base);

  exports.Class = Class = (<span class="keyword">function</span>(_super) {

    __extends(Class, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">(variable, parent, body)</span> {</span>
      <span class="keyword">this</span>.variable = variable;
      <span class="keyword">this</span>.parent = parent;
      <span class="keyword">this</span>.body = body != <span class="literal">null</span> ? body : <span class="keyword">new</span> Block;
      <span class="keyword">this</span>.boundFuncs = [];
      <span class="keyword">this</span>.body.classBody = <span class="literal">true</span>;
    }

    Class.prototype.children = [<span class="string">'variable'</span>, <span class="string">'parent'</span>, <span class="string">'body'</span>];

    Class.prototype.determineName = <span class="keyword">function</span>() {
      <span class="keyword">var</span> decl, tail;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.variable) {
        <span class="keyword">return</span> <span class="literal">null</span>;
      }
      decl = (tail = last(<span class="keyword">this</span>.variable.properties)) ? tail <span class="keyword">instanceof</span> Access &amp;&amp; tail.name.value : <span class="keyword">this</span>.variable.base.value;
      <span class="keyword">if</span> (__indexOf.call(STRICT_PROSCRIBED, decl) >= <span class="number">0</span>) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">"variable name may not be "</span> + decl);
      }
      <span class="keyword">return</span> decl &amp;&amp; (decl = IDENTIFIER.test(decl) &amp;&amp; decl);
    };

    Class.prototype.setContext = <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> <span class="keyword">this</span>.body.traverseChildren(<span class="literal">false</span>, <span class="keyword">function</span>(node) {
        <span class="keyword">if</span> (node.classBody) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Literal &amp;&amp; node.value === <span class="string">'this'</span>) {
          <span class="keyword">return</span> node.value = name;
        } <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Code) {
          node.klass = name;
          <span class="keyword">if</span> (node.bound) {
            <span class="keyword">return</span> node.context = name;
          }
        }
      });
    };

    Class.prototype.addBoundFunctions = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> bvar, lhs, _i, _len, _ref2, _results;
      <span class="keyword">if</span> (<span class="keyword">this</span>.boundFuncs.length) {
        _ref2 = <span class="keyword">this</span>.boundFuncs;
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
          bvar = _ref2[_i];
          lhs = (<span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(<span class="string">"this"</span>), [<span class="keyword">new</span> Access(bvar)])).compile(o);
          _results.push(<span class="keyword">this</span>.ctor.body.unshift(<span class="keyword">new</span> Literal(<span class="string">""</span> + lhs + <span class="string">" = "</span> + (utility(<span class="string">'bind'</span>)) + <span class="string">"("</span> + lhs + <span class="string">", this)"</span>)));
        }
        <span class="keyword">return</span> _results;
      }
    };

    Class.prototype.addProperties = <span class="keyword">function</span>(node, name, o) {
      <span class="keyword">var</span> assign, base, exprs, func, props;
      props = node.base.properties.slice(<span class="number">0</span>);
      exprs = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _results;
        _results = [];
        <span class="keyword">while</span> (assign = props.shift()) {
          <span class="keyword">if</span> (assign <span class="keyword">instanceof</span> Assign) {
            base = assign.variable.base;
            <span class="keyword">delete</span> assign.context;
            func = assign.value;
            <span class="keyword">if</span> (base.value === <span class="string">'constructor'</span>) {
              <span class="keyword">if</span> (<span class="keyword">this</span>.ctor) {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'cannot define more than one constructor in a class'</span>);
              }
              <span class="keyword">if</span> (func.bound) {
                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'cannot define a constructor as a bound function'</span>);
              }
              <span class="keyword">if</span> (func <span class="keyword">instanceof</span> Code) {
                assign = <span class="keyword">this</span>.ctor = func;
              } <span class="keyword">else</span> {
                <span class="keyword">this</span>.externalCtor = o.scope.freeVariable(<span class="string">'class'</span>);
                assign = <span class="keyword">new</span> Assign(<span class="keyword">new</span> Literal(<span class="keyword">this</span>.externalCtor), func);
              }
            } <span class="keyword">else</span> {
              <span class="keyword">if</span> (assign.variable[<span class="string">"this"</span>]) {
                func[<span class="string">"static"</span>] = <span class="literal">true</span>;
                <span class="keyword">if</span> (func.bound) {
                  func.context = name;
                }
              } <span class="keyword">else</span> {
                assign.variable = <span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(name), [<span class="keyword">new</span> Access(<span class="keyword">new</span> Literal(<span class="string">'prototype'</span>)), <span class="keyword">new</span> Access(base)]);
                <span class="keyword">if</span> (func <span class="keyword">instanceof</span> Code &amp;&amp; func.bound) {
                  <span class="keyword">this</span>.boundFuncs.push(base);
                  func.bound = <span class="literal">false</span>;
                }
              }
            }
          }
          _results.push(assign);
        }
        <span class="keyword">return</span> _results;
      }).call(<span class="keyword">this</span>);
      <span class="keyword">return</span> compact(exprs);
    };

    Class.prototype.walkBody = <span class="keyword">function</span>(name, o) {
      <span class="keyword">var</span> _<span class="keyword">this</span> = <span class="keyword">this</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>.traverseChildren(<span class="literal">false</span>, <span class="keyword">function</span>(child) {
        <span class="keyword">var</span> exps, i, node, _i, _len, _ref2;
        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Class) {
          <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Block) {
          _ref2 = exps = child.expressions;
          <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; i = ++_i) {
            node = _ref2[i];
            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Value &amp;&amp; node.isObject(<span class="literal">true</span>)) {
              exps[i] = _<span class="keyword">this</span>.addProperties(node, name, o);
            }
          }
          <span class="keyword">return</span> child.expressions = exps = flatten(exps);
        }
      });
    };

    Class.prototype.hoistDirectivePrologue = <span class="keyword">function</span>() {
      <span class="keyword">var</span> expressions, index, node;
      index = <span class="number">0</span>;
      expressions = <span class="keyword">this</span>.body.expressions;
      <span class="keyword">while</span> ((node = expressions[index]) &amp;&amp; node <span class="keyword">instanceof</span> Comment || node <span class="keyword">instanceof</span> Value &amp;&amp; node.isString()) {
        ++index;
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.directives = expressions.splice(<span class="number">0</span>, index);
    };

    Class.prototype.ensureConstructor = <span class="keyword">function</span>(name) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.ctor) {
        <span class="keyword">this</span>.ctor = <span class="keyword">new</span> Code;
        <span class="keyword">if</span> (<span class="keyword">this</span>.parent) {
          <span class="keyword">this</span>.ctor.body.push(<span class="keyword">new</span> Literal(<span class="string">""</span> + name + <span class="string">".__super__.constructor.apply(this, arguments)"</span>));
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.externalCtor) {
          <span class="keyword">this</span>.ctor.body.push(<span class="keyword">new</span> Literal(<span class="string">""</span> + <span class="keyword">this</span>.externalCtor + <span class="string">".apply(this, arguments)"</span>));
        }
        <span class="keyword">this</span>.ctor.body.makeReturn();
        <span class="keyword">this</span>.body.expressions.unshift(<span class="keyword">this</span>.ctor);
      }
      <span class="keyword">this</span>.ctor.ctor = <span class="keyword">this</span>.ctor.name = name;
      <span class="keyword">this</span>.ctor.klass = <span class="literal">null</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>.ctor.noReturn = <span class="literal">true</span>;
    };

    Class.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> call, decl, klass, lname, name, params, _ref2;
      decl = <span class="keyword">this</span>.determineName();
      name = decl || <span class="string">'_Class'</span>;
      <span class="keyword">if</span> (name.reserved) {
        name = <span class="string">"_"</span> + name;
      }
      lname = <span class="keyword">new</span> Literal(name);
      <span class="keyword">this</span>.hoistDirectivePrologue();
      <span class="keyword">this</span>.setContext(name);
      <span class="keyword">this</span>.walkBody(name, o);
      <span class="keyword">this</span>.ensureConstructor(name);
      <span class="keyword">this</span>.body.spaced = <span class="literal">true</span>;
      <span class="keyword">if</span> (!(<span class="keyword">this</span>.ctor <span class="keyword">instanceof</span> Code)) {
        <span class="keyword">this</span>.body.expressions.unshift(<span class="keyword">this</span>.ctor);
      }
      <span class="keyword">this</span>.body.expressions.push(lname);
      (_ref2 = <span class="keyword">this</span>.body.expressions).unshift.apply(_ref2, <span class="keyword">this</span>.directives);
      <span class="keyword">this</span>.addBoundFunctions(o);
      call = Closure.wrap(<span class="keyword">this</span>.body);
      <span class="keyword">if</span> (<span class="keyword">this</span>.parent) {
        <span class="keyword">this</span>.superClass = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'super'</span>, <span class="literal">false</span>));
        <span class="keyword">this</span>.body.expressions.unshift(<span class="keyword">new</span> Extends(lname, <span class="keyword">this</span>.superClass));
        call.args.push(<span class="keyword">this</span>.parent);
        params = call.variable.params || call.variable.base.params;
        params.push(<span class="keyword">new</span> Param(<span class="keyword">this</span>.superClass));
      }
      klass = <span class="keyword">new</span> Parens(call, <span class="literal">true</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.variable) {
        klass = <span class="keyword">new</span> Assign(<span class="keyword">this</span>.variable, klass);
      }
      <span class="keyword">return</span> klass.compile(o);
    };

    <span class="keyword">return</span> Class;

  })(Base);

  exports.Assign = Assign = (<span class="keyword">function</span>(_super) {

    __extends(Assign, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Assign</span><span class="params">(variable, value, context, options)</span> {</span>
      <span class="keyword">var</span> forbidden, name, _ref2;
      <span class="keyword">this</span>.variable = variable;
      <span class="keyword">this</span>.value = value;
      <span class="keyword">this</span>.context = context;
      <span class="keyword">this</span>.param = options &amp;&amp; options.param;
      <span class="keyword">this</span>.subpattern = options &amp;&amp; options.subpattern;
      forbidden = (_ref2 = (name = <span class="keyword">this</span>.variable.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= <span class="number">0</span>);
      <span class="keyword">if</span> (forbidden &amp;&amp; <span class="keyword">this</span>.context !== <span class="string">'object'</span>) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">"variable name may not be \""</span> + name + <span class="string">"\""</span>);
      }
    }

    Assign.prototype.children = [<span class="string">'variable'</span>, <span class="string">'value'</span>];

    Assign.prototype.isStatement = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> (o != <span class="literal">null</span> ? o.level : <span class="keyword">void</span> <span class="number">0</span>) === LEVEL_TOP &amp;&amp; (<span class="keyword">this</span>.context != <span class="literal">null</span>) &amp;&amp; __indexOf.call(<span class="keyword">this</span>.context, <span class="string">"?"</span>) >= <span class="number">0</span>;
    };

    Assign.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> <span class="keyword">this</span>[<span class="keyword">this</span>.context === <span class="string">'object'</span> ? <span class="string">'value'</span> : <span class="string">'variable'</span>].assigns(name);
    };

    Assign.prototype.unfoldSoak = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> unfoldSoak(o, <span class="keyword">this</span>, <span class="string">'variable'</span>);
    };

    Assign.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> isValue, match, name, val, varBase, _ref2, _ref3, _ref4, _ref5;
      <span class="keyword">if</span> (isValue = <span class="keyword">this</span>.variable <span class="keyword">instanceof</span> Value) {
        <span class="keyword">if</span> (<span class="keyword">this</span>.variable.isArray() || <span class="keyword">this</span>.variable.isObject()) {
          <span class="keyword">return</span> <span class="keyword">this</span>.compilePatternMatch(o);
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.variable.isSplice()) {
          <span class="keyword">return</span> <span class="keyword">this</span>.compileSplice(o);
        }
        <span class="keyword">if</span> ((_ref2 = <span class="keyword">this</span>.context) === <span class="string">'||='</span> || _ref2 === <span class="string">'&amp;&amp;='</span> || _ref2 === <span class="string">'?='</span>) {
          <span class="keyword">return</span> <span class="keyword">this</span>.compileConditional(o);
        }
      }
      name = <span class="keyword">this</span>.variable.compile(o, LEVEL_LIST);
      <span class="keyword">if</span> (!<span class="keyword">this</span>.context) {
        <span class="keyword">if</span> (!(varBase = <span class="keyword">this</span>.variable.unwrapAll()).isAssignable()) {
          <span class="keyword">throw</span> SyntaxError(<span class="string">"\""</span> + (<span class="keyword">this</span>.variable.compile(o)) + <span class="string">"\" cannot be assigned."</span>);
        }
        <span class="keyword">if</span> (!(<span class="keyword">typeof</span> varBase.hasProperties === <span class="string">"function"</span> ? varBase.hasProperties() : <span class="keyword">void</span> <span class="number">0</span>)) {
          <span class="keyword">if</span> (<span class="keyword">this</span>.param) {
            o.scope.add(name, <span class="string">'var'</span>);
          } <span class="keyword">else</span> {
            o.scope.find(name);
          }
        }
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.value <span class="keyword">instanceof</span> Code &amp;&amp; (match = METHOD_DEF.exec(name))) {
        <span class="keyword">if</span> (match[<span class="number">1</span>]) {
          <span class="keyword">this</span>.value.klass = match[<span class="number">1</span>];
        }
        <span class="keyword">this</span>.value.name = (_ref3 = (_ref4 = (_ref5 = match[<span class="number">2</span>]) != <span class="literal">null</span> ? _ref5 : match[<span class="number">3</span>]) != <span class="literal">null</span> ? _ref4 : match[<span class="number">4</span>]) != <span class="literal">null</span> ? _ref3 : match[<span class="number">5</span>];
      }
      val = <span class="keyword">this</span>.value.compile(o, LEVEL_LIST);
      <span class="keyword">if</span> (<span class="keyword">this</span>.context === <span class="string">'object'</span>) {
        <span class="keyword">return</span> <span class="string">""</span> + name + <span class="string">": "</span> + val;
      }
      val = name + (<span class="string">" "</span> + (<span class="keyword">this</span>.context || <span class="string">'='</span>) + <span class="string">" "</span>) + val;
      <span class="keyword">if</span> (o.level &lt;= LEVEL_LIST) {
        <span class="keyword">return</span> val;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + val + <span class="string">")"</span>;
      }
    };

    Assign.prototype.compilePatternMatch = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> acc, assigns, code, i, idx, isObject, ivar, name, obj, objects, olen, ref, rest, splat, top, val, value, vvar, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      top = o.level === LEVEL_TOP;
      value = <span class="keyword">this</span>.value;
      objects = <span class="keyword">this</span>.variable.base.objects;
      <span class="keyword">if</span> (!(olen = objects.length)) {
        code = value.compile(o);
        <span class="keyword">if</span> (o.level >= LEVEL_OP) {
          <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> code;
        }
      }
      isObject = <span class="keyword">this</span>.variable.isObject();
      <span class="keyword">if</span> (top &amp;&amp; olen === <span class="number">1</span> &amp;&amp; !((obj = objects[<span class="number">0</span>]) <span class="keyword">instanceof</span> Splat)) {
        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Assign) {
          _ref2 = obj, (_ref3 = _ref2.variable, idx = _ref3.base), obj = _ref2.value;
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (obj.base <span class="keyword">instanceof</span> Parens) {
            _ref4 = <span class="keyword">new</span> Value(obj.unwrapAll()).cacheReference(o), obj = _ref4[<span class="number">0</span>], idx = _ref4[<span class="number">1</span>];
          } <span class="keyword">else</span> {
            idx = isObject ? obj[<span class="string">"this"</span>] ? obj.properties[<span class="number">0</span>].name : obj : <span class="keyword">new</span> Literal(<span class="number">0</span>);
          }
        }
        acc = IDENTIFIER.test(idx.unwrap().value || <span class="number">0</span>);
        value = <span class="keyword">new</span> Value(value);
        value.properties.push(<span class="keyword">new</span> (acc ? Access : Index)(idx));
        <span class="keyword">if</span> (_ref5 = obj.unwrap().value, __indexOf.call(RESERVED, _ref5) >= <span class="number">0</span>) {
          <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"assignment to a reserved word: "</span> + (obj.compile(o)) + <span class="string">" = "</span> + (value.compile(o)));
        }
        <span class="keyword">return</span> <span class="keyword">new</span> Assign(obj, value, <span class="literal">null</span>, {
          param: <span class="keyword">this</span>.param
        }).compile(o, LEVEL_TOP);
      }
      vvar = value.compile(o, LEVEL_LIST);
      assigns = [];
      splat = <span class="literal">false</span>;
      <span class="keyword">if</span> (!IDENTIFIER.test(vvar) || <span class="keyword">this</span>.variable.assigns(vvar)) {
        assigns.push(<span class="string">""</span> + (ref = o.scope.freeVariable(<span class="string">'ref'</span>)) + <span class="string">" = "</span> + vvar);
        vvar = ref;
      }
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = objects.length; _i &lt; _len; i = ++_i) {
        obj = objects[i];
        idx = i;
        <span class="keyword">if</span> (isObject) {
          <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Assign) {
            _ref6 = obj, (_ref7 = _ref6.variable, idx = _ref7.base), obj = _ref6.value;
          } <span class="keyword">else</span> {
            <span class="keyword">if</span> (obj.base <span class="keyword">instanceof</span> Parens) {
              _ref8 = <span class="keyword">new</span> Value(obj.unwrapAll()).cacheReference(o), obj = _ref8[<span class="number">0</span>], idx = _ref8[<span class="number">1</span>];
            } <span class="keyword">else</span> {
              idx = obj[<span class="string">"this"</span>] ? obj.properties[<span class="number">0</span>].name : obj;
            }
          }
        }
        <span class="keyword">if</span> (!splat &amp;&amp; obj <span class="keyword">instanceof</span> Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = <span class="string">""</span> + olen + <span class="string">" &lt;= "</span> + vvar + <span class="string">".length ? "</span> + (utility(<span class="string">'slice'</span>)) + <span class="string">".call("</span> + vvar + <span class="string">", "</span> + i;
          <span class="keyword">if</span> (rest = olen - i - <span class="number">1</span>) {
            ivar = o.scope.freeVariable(<span class="string">'i'</span>);
            val += <span class="string">", "</span> + ivar + <span class="string">" = "</span> + vvar + <span class="string">".length - "</span> + rest + <span class="string">") : ("</span> + ivar + <span class="string">" = "</span> + i + <span class="string">", [])"</span>;
          } <span class="keyword">else</span> {
            val += <span class="string">") : []"</span>;
          }
          val = <span class="keyword">new</span> Literal(val);
          splat = <span class="string">""</span> + ivar + <span class="string">"++"</span>;
        } <span class="keyword">else</span> {
          name = obj.unwrap().value;
          <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Splat) {
            obj = obj.name.compile(o);
            <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"multiple splats are disallowed in an assignment: "</span> + obj + <span class="string">"..."</span>);
          }
          <span class="keyword">if</span> (<span class="keyword">typeof</span> idx === <span class="string">'number'</span>) {
            idx = <span class="keyword">new</span> Literal(splat || idx);
            acc = <span class="literal">false</span>;
          } <span class="keyword">else</span> {
            acc = isObject &amp;&amp; IDENTIFIER.test(idx.unwrap().value || <span class="number">0</span>);
          }
          val = <span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(vvar), [<span class="keyword">new</span> (acc ? Access : Index)(idx)]);
        }
        <span class="keyword">if</span> ((name != <span class="literal">null</span>) &amp;&amp; __indexOf.call(RESERVED, name) >= <span class="number">0</span>) {
          <span class="keyword">throw</span> <span class="keyword">new</span> SyntaxError(<span class="string">"assignment to a reserved word: "</span> + (obj.compile(o)) + <span class="string">" = "</span> + (val.compile(o)));
        }
        assigns.push(<span class="keyword">new</span> Assign(obj, val, <span class="literal">null</span>, {
          param: <span class="keyword">this</span>.param,
          subpattern: <span class="literal">true</span>
        }).compile(o, LEVEL_LIST));
      }
      <span class="keyword">if</span> (!(top || <span class="keyword">this</span>.subpattern)) {
        assigns.push(vvar);
      }
      code = assigns.join(<span class="string">', '</span>);
      <span class="keyword">if</span> (o.level &lt; LEVEL_LIST) {
        <span class="keyword">return</span> code;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      }
    };

    Assign.prototype.compileConditional = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> left, right, _ref2;
      _ref2 = <span class="keyword">this</span>.variable.cacheReference(o), left = _ref2[<span class="number">0</span>], right = _ref2[<span class="number">1</span>];
      <span class="keyword">if</span> (!left.properties.length &amp;&amp; left.base <span class="keyword">instanceof</span> Literal &amp;&amp; left.base.value !== <span class="string">"this"</span> &amp;&amp; !o.scope.check(left.base.value)) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"the variable \""</span> + left.base.value + <span class="string">"\" can't be assigned with "</span> + <span class="keyword">this</span>.context + <span class="string">" because it has not been defined."</span>);
      }
      <span class="keyword">if</span> (__indexOf.call(<span class="keyword">this</span>.context, <span class="string">"?"</span>) >= <span class="number">0</span>) {
        o.isExistentialEquals = <span class="literal">true</span>;
      }
      <span class="keyword">return</span> <span class="keyword">new</span> Op(<span class="keyword">this</span>.context.slice(<span class="number">0</span>, -<span class="number">1</span>), left, <span class="keyword">new</span> Assign(right, <span class="keyword">this</span>.value, <span class="string">'='</span>)).compile(o);
    };

    Assign.prototype.compileSplice = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, exclusive, from, fromDecl, fromRef, name, to, valDef, valRef, _ref2, _ref3, _ref4;
      _ref2 = <span class="keyword">this</span>.variable.properties.pop().range, from = _ref2.from, to = _ref2.to, exclusive = _ref2.exclusive;
      name = <span class="keyword">this</span>.variable.compile(o);
      _ref3 = (from != <span class="literal">null</span> ? from.cache(o, LEVEL_OP) : <span class="keyword">void</span> <span class="number">0</span>) || [<span class="string">'0'</span>, <span class="string">'0'</span>], fromDecl = _ref3[<span class="number">0</span>], fromRef = _ref3[<span class="number">1</span>];
      <span class="keyword">if</span> (to) {
        <span class="keyword">if</span> ((from != <span class="literal">null</span> ? from.isSimpleNumber() : <span class="keyword">void</span> <span class="number">0</span>) &amp;&amp; to.isSimpleNumber()) {
          to = +to.compile(o) - +fromRef;
          <span class="keyword">if</span> (!exclusive) {
            to += <span class="number">1</span>;
          }
        } <span class="keyword">else</span> {
          to = to.compile(o, LEVEL_ACCESS) + <span class="string">' - '</span> + fromRef;
          <span class="keyword">if</span> (!exclusive) {
            to += <span class="string">' + 1'</span>;
          }
        }
      } <span class="keyword">else</span> {
        to = <span class="string">"9e9"</span>;
      }
      _ref4 = <span class="keyword">this</span>.value.cache(o, LEVEL_LIST), valDef = _ref4[<span class="number">0</span>], valRef = _ref4[<span class="number">1</span>];
      code = <span class="string">"[].splice.apply("</span> + name + <span class="string">", ["</span> + fromDecl + <span class="string">", "</span> + to + <span class="string">"].concat("</span> + valDef + <span class="string">")), "</span> + valRef;
      <span class="keyword">if</span> (o.level > LEVEL_TOP) {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> code;
      }
    };

    <span class="keyword">return</span> Assign;

  })(Base);

  exports.Code = Code = (<span class="keyword">function</span>(_super) {

    __extends(Code, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Code</span><span class="params">(params, body, tag)</span> {</span>
      <span class="keyword">this</span>.params = params || [];
      <span class="keyword">this</span>.body = body || <span class="keyword">new</span> Block;
      <span class="keyword">this</span>.bound = tag === <span class="string">'boundfunc'</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.bound) {
        <span class="keyword">this</span>.context = <span class="string">'_this'</span>;
      }
    }

    Code.prototype.children = [<span class="string">'params'</span>, <span class="string">'body'</span>];

    Code.prototype.isStatement = <span class="keyword">function</span>() {
      <span class="keyword">return</span> !!<span class="keyword">this</span>.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, exprs, i, idt, lit, name, p, param, params, ref, splats, uniqs, val, wasEmpty, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      o.scope = <span class="keyword">new</span> Scope(o.scope, <span class="keyword">this</span>.body, <span class="keyword">this</span>);
      o.scope.shared = del(o, <span class="string">'sharedScope'</span>);
      o.indent += TAB;
      <span class="keyword">delete</span> o.bare;
      <span class="keyword">delete</span> o.isExistentialEquals;
      params = [];
      exprs = [];
      _ref2 = <span class="keyword">this</span>.paramNames();
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        name = _ref2[_i];
        <span class="keyword">if</span> (!o.scope.check(name)) {
          o.scope.parameter(name);
        }
      }
      _ref3 = <span class="keyword">this</span>.params;
      <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref3.length; _j &lt; _len1; _j++) {
        param = _ref3[_j];
        <span class="keyword">if</span> (!param.splat) {
          <span class="keyword">continue</span>;
        }
        _ref4 = <span class="keyword">this</span>.params;
        <span class="keyword">for</span> (_k = <span class="number">0</span>, _len2 = _ref4.length; _k &lt; _len2; _k++) {
          p = _ref4[_k].name;
          <span class="keyword">if</span> (p[<span class="string">"this"</span>]) {
            p = p.properties[<span class="number">0</span>].name;
          }
          <span class="keyword">if</span> (p.value) {
            o.scope.add(p.value, <span class="string">'var'</span>, <span class="literal">true</span>);
          }
        }
        splats = <span class="keyword">new</span> Assign(<span class="keyword">new</span> Value(<span class="keyword">new</span> Arr((<span class="keyword">function</span>() {
          <span class="keyword">var</span> _l, _len3, _ref5, _results;
          _ref5 = <span class="keyword">this</span>.params;
          _results = [];
          <span class="keyword">for</span> (_l = <span class="number">0</span>, _len3 = _ref5.length; _l &lt; _len3; _l++) {
            p = _ref5[_l];
            _results.push(p.asReference(o));
          }
          <span class="keyword">return</span> _results;
        }).call(<span class="keyword">this</span>))), <span class="keyword">new</span> Value(<span class="keyword">new</span> Literal(<span class="string">'arguments'</span>)));
        <span class="keyword">break</span>;
      }
      _ref5 = <span class="keyword">this</span>.params;
      <span class="keyword">for</span> (_l = <span class="number">0</span>, _len3 = _ref5.length; _l &lt; _len3; _l++) {
        param = _ref5[_l];
        <span class="keyword">if</span> (param.isComplex()) {
          val = ref = param.asReference(o);
          <span class="keyword">if</span> (param.value) {
            val = <span class="keyword">new</span> Op(<span class="string">'?'</span>, ref, param.value);
          }
          exprs.push(<span class="keyword">new</span> Assign(<span class="keyword">new</span> Value(param.name), val, <span class="string">'='</span>, {
            param: <span class="literal">true</span>
          }));
        } <span class="keyword">else</span> {
          ref = param;
          <span class="keyword">if</span> (param.value) {
            lit = <span class="keyword">new</span> Literal(ref.name.value + <span class="string">' == null'</span>);
            val = <span class="keyword">new</span> Assign(<span class="keyword">new</span> Value(param.name), param.value, <span class="string">'='</span>);
            exprs.push(<span class="keyword">new</span> If(lit, val));
          }
        }
        <span class="keyword">if</span> (!splats) {
          params.push(ref);
        }
      }
      wasEmpty = <span class="keyword">this</span>.body.isEmpty();
      <span class="keyword">if</span> (splats) {
        exprs.unshift(splats);
      }
      <span class="keyword">if</span> (exprs.length) {
        (_ref6 = <span class="keyword">this</span>.body.expressions).unshift.apply(_ref6, exprs);
      }
      <span class="keyword">for</span> (i = _m = <span class="number">0</span>, _len4 = params.length; _m &lt; _len4; i = ++_m) {
        p = params[i];
        o.scope.parameter(params[i] = p.compile(o));
      }
      uniqs = [];
      _ref7 = <span class="keyword">this</span>.paramNames();
      <span class="keyword">for</span> (_n = <span class="number">0</span>, _len5 = _ref7.length; _n &lt; _len5; _n++) {
        name = _ref7[_n];
        <span class="keyword">if</span> (__indexOf.call(uniqs, name) >= <span class="number">0</span>) {
          <span class="keyword">throw</span> SyntaxError(<span class="string">"multiple parameters named '"</span> + name + <span class="string">"'"</span>);
        }
        uniqs.push(name);
      }
      <span class="keyword">if</span> (!(wasEmpty || <span class="keyword">this</span>.noReturn)) {
        <span class="keyword">this</span>.body.makeReturn();
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.bound) {
        <span class="keyword">if</span> ((_ref8 = o.scope.parent.method) != <span class="literal">null</span> ? _ref8.bound : <span class="keyword">void</span> <span class="number">0</span>) {
          <span class="keyword">this</span>.bound = <span class="keyword">this</span>.context = o.scope.parent.method.context;
        } <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>[<span class="string">"static"</span>]) {
          o.scope.parent.assign(<span class="string">'_this'</span>, <span class="string">'this'</span>);
        }
      }
      idt = o.indent;
      code = <span class="string">'function'</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.ctor) {
        code += <span class="string">' '</span> + <span class="keyword">this</span>.name;
      }
      code += <span class="string">'('</span> + params.join(<span class="string">', '</span>) + <span class="string">') {'</span>;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.body.isEmpty()) {
        code += <span class="string">"\n"</span> + (<span class="keyword">this</span>.body.compileWithDeclarations(o)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab;
      }
      code += <span class="string">'}'</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.ctor) {
        <span class="keyword">return</span> <span class="keyword">this</span>.tab + code;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.front || (o.level >= LEVEL_ACCESS)) {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> code;
      }
    };

    Code.prototype.paramNames = <span class="keyword">function</span>() {
      <span class="keyword">var</span> names, param, _i, _len, _ref2;
      names = [];
      _ref2 = <span class="keyword">this</span>.params;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        param = _ref2[_i];
        names.push.apply(names, param.names());
      }
      <span class="keyword">return</span> names;
    };

    Code.prototype.traverseChildren = <span class="keyword">function</span>(crossScope, func) {
      <span class="keyword">if</span> (crossScope) {
        <span class="keyword">return</span> Code.__super__.traverseChildren.call(<span class="keyword">this</span>, crossScope, func);
      }
    };

    <span class="keyword">return</span> Code;

  })(Base);

  exports.Param = Param = (<span class="keyword">function</span>(_super) {

    __extends(Param, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Param</span><span class="params">(name, value, splat)</span> {</span>
      <span class="keyword">var</span> _ref2;
      <span class="keyword">this</span>.name = name;
      <span class="keyword">this</span>.value = value;
      <span class="keyword">this</span>.splat = splat;
      <span class="keyword">if</span> (_ref2 = (name = <span class="keyword">this</span>.name.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= <span class="number">0</span>) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">"parameter name \""</span> + name + <span class="string">"\" is not allowed"</span>);
      }
    }

    Param.prototype.children = [<span class="string">'name'</span>, <span class="string">'value'</span>];

    Param.prototype.compile = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> <span class="keyword">this</span>.name.compile(o, LEVEL_LIST);
    };

    Param.prototype.asReference = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> node;
      <span class="keyword">if</span> (<span class="keyword">this</span>.reference) {
        <span class="keyword">return</span> <span class="keyword">this</span>.reference;
      }
      node = <span class="keyword">this</span>.name;
      <span class="keyword">if</span> (node[<span class="string">"this"</span>]) {
        node = node.properties[<span class="number">0</span>].name;
        <span class="keyword">if</span> (node.value.reserved) {
          node = <span class="keyword">new</span> Literal(o.scope.freeVariable(node.value));
        }
      } <span class="keyword">else</span> <span class="keyword">if</span> (node.isComplex()) {
        node = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'arg'</span>));
      }
      node = <span class="keyword">new</span> Value(node);
      <span class="keyword">if</span> (<span class="keyword">this</span>.splat) {
        node = <span class="keyword">new</span> Splat(node);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.reference = node;
    };

    Param.prototype.isComplex = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.name.isComplex();
    };

    Param.prototype.names = <span class="keyword">function</span>(name) {
      <span class="keyword">var</span> atParam, names, obj, _i, _len, _ref2;
      <span class="keyword">if</span> (name == <span class="literal">null</span>) {
        name = <span class="keyword">this</span>.name;
      }
      atParam = <span class="keyword">function</span>(obj) {
        <span class="keyword">var</span> value;
        value = obj.properties[<span class="number">0</span>].name.value;
        <span class="keyword">if</span> (value.reserved) {
          <span class="keyword">return</span> [];
        } <span class="keyword">else</span> {
          <span class="keyword">return</span> [value];
        }
      };
      <span class="keyword">if</span> (name <span class="keyword">instanceof</span> Literal) {
        <span class="keyword">return</span> [name.value];
      }
      <span class="keyword">if</span> (name <span class="keyword">instanceof</span> Value) {
        <span class="keyword">return</span> atParam(name);
      }
      names = [];
      _ref2 = name.objects;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        obj = _ref2[_i];
        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Assign) {
          names.push(obj.value.unwrap().value);
        } <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Splat) {
          names.push(obj.name.unwrap().value);
        } <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Value) {
          <span class="keyword">if</span> (obj.isArray() || obj.isObject()) {
            names.push.apply(names, <span class="keyword">this</span>.names(obj.base));
          } <span class="keyword">else</span> <span class="keyword">if</span> (obj[<span class="string">"this"</span>]) {
            names.push.apply(names, atParam(obj));
          } <span class="keyword">else</span> {
            names.push(obj.base.value);
          }
        } <span class="keyword">else</span> {
          <span class="keyword">throw</span> SyntaxError(<span class="string">"illegal parameter "</span> + (obj.compile()));
        }
      }
      <span class="keyword">return</span> names;
    };

    <span class="keyword">return</span> Param;

  })(Base);

  exports.Splat = Splat = (<span class="keyword">function</span>(_super) {

    __extends(Splat, _super);

    Splat.prototype.children = [<span class="string">'name'</span>];

    Splat.prototype.isAssignable = YES;

    <span class="function"><span class="keyword">function</span> <span class="title">Splat</span><span class="params">(name)</span> {</span>
      <span class="keyword">this</span>.name = name.compile ? name : <span class="keyword">new</span> Literal(name);
    }

    Splat.prototype.assigns = <span class="keyword">function</span>(name) {
      <span class="keyword">return</span> <span class="keyword">this</span>.name.assigns(name);
    };

    Splat.prototype.compile = <span class="keyword">function</span>(o) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.index != <span class="literal">null</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileParam(o);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.name.compile(o);
      }
    };

    Splat.prototype.unwrap = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.name;
    };

    Splat.compileSplattedArray = <span class="keyword">function</span>(o, list, apply) {
      <span class="keyword">var</span> args, base, code, i, index, node, _i, _len;
      index = -<span class="number">1</span>;
      <span class="keyword">while</span> ((node = list[++index]) &amp;&amp; !(node <span class="keyword">instanceof</span> Splat)) {
        <span class="keyword">continue</span>;
      }
      <span class="keyword">if</span> (index >= list.length) {
        <span class="keyword">return</span> <span class="string">''</span>;
      }
      <span class="keyword">if</span> (list.length === <span class="number">1</span>) {
        code = list[<span class="number">0</span>].compile(o, LEVEL_LIST);
        <span class="keyword">if</span> (apply) {
          <span class="keyword">return</span> code;
        }
        <span class="keyword">return</span> <span class="string">""</span> + (utility(<span class="string">'slice'</span>)) + <span class="string">".call("</span> + code + <span class="string">")"</span>;
      }
      args = list.slice(index);
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = args.length; _i &lt; _len; i = ++_i) {
        node = args[i];
        code = node.compile(o, LEVEL_LIST);
        args[i] = node <span class="keyword">instanceof</span> Splat ? <span class="string">""</span> + (utility(<span class="string">'slice'</span>)) + <span class="string">".call("</span> + code + <span class="string">")"</span> : <span class="string">"["</span> + code + <span class="string">"]"</span>;
      }
      <span class="keyword">if</span> (index === <span class="number">0</span>) {
        <span class="keyword">return</span> args[<span class="number">0</span>] + (<span class="string">".concat("</span> + (args.slice(<span class="number">1</span>).join(<span class="string">', '</span>)) + <span class="string">")"</span>);
      }
      base = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _j, _len1, _ref2, _results;
        _ref2 = list.slice(<span class="number">0</span>, index);
        _results = [];
        <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref2.length; _j &lt; _len1; _j++) {
          node = _ref2[_j];
          _results.push(node.compile(o, LEVEL_LIST));
        }
        <span class="keyword">return</span> _results;
      })();
      <span class="keyword">return</span> <span class="string">"["</span> + (base.join(<span class="string">', '</span>)) + <span class="string">"].concat("</span> + (args.join(<span class="string">', '</span>)) + <span class="string">")"</span>;
    };

    <span class="keyword">return</span> Splat;

  })(Base);

  exports.While = While = (<span class="keyword">function</span>(_super) {

    __extends(While, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">While</span><span class="params">(condition, options)</span> {</span>
      <span class="keyword">this</span>.condition = (options != <span class="literal">null</span> ? options.invert : <span class="keyword">void</span> <span class="number">0</span>) ? condition.invert() : condition;
      <span class="keyword">this</span>.guard = options != <span class="literal">null</span> ? options.guard : <span class="keyword">void</span> <span class="number">0</span>;
    }

    While.prototype.children = [<span class="string">'condition'</span>, <span class="string">'guard'</span>, <span class="string">'body'</span>];

    While.prototype.isStatement = YES;

    While.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">if</span> (res) {
        <span class="keyword">return</span> While.__super__.makeReturn.apply(<span class="keyword">this</span>, arguments);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.returns = !<span class="keyword">this</span>.jumps({
          loop: <span class="literal">true</span>
        });
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }
    };

    While.prototype.addBody = <span class="keyword">function</span>(body) {
      <span class="keyword">this</span>.body = body;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    While.prototype.jumps = <span class="keyword">function</span>() {
      <span class="keyword">var</span> expressions, node, _i, _len;
      expressions = <span class="keyword">this</span>.body.expressions;
      <span class="keyword">if</span> (!expressions.length) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = expressions.length; _i &lt; _len; _i++) {
        node = expressions[_i];
        <span class="keyword">if</span> (node.jumps({
          loop: <span class="literal">true</span>
        })) {
          <span class="keyword">return</span> node;
        }
      }
      <span class="keyword">return</span> <span class="literal">false</span>;
    };

    While.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> body, code, rvar, set;
      o.indent += TAB;
      set = <span class="string">''</span>;
      body = <span class="keyword">this</span>.body;
      <span class="keyword">if</span> (body.isEmpty()) {
        body = <span class="string">''</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">if</span> (<span class="keyword">this</span>.returns) {
          body.makeReturn(rvar = o.scope.freeVariable(<span class="string">'results'</span>));
          set = <span class="string">""</span> + <span class="keyword">this</span>.tab + rvar + <span class="string">" = [];\n"</span>;
        }
        <span class="keyword">if</span> (<span class="keyword">this</span>.guard) {
          <span class="keyword">if</span> (body.expressions.length > <span class="number">1</span>) {
            body.expressions.unshift(<span class="keyword">new</span> If((<span class="keyword">new</span> Parens(<span class="keyword">this</span>.guard)).invert(), <span class="keyword">new</span> Literal(<span class="string">"continue"</span>)));
          } <span class="keyword">else</span> {
            <span class="keyword">if</span> (<span class="keyword">this</span>.guard) {
              body = Block.wrap([<span class="keyword">new</span> If(<span class="keyword">this</span>.guard, body)]);
            }
          }
        }
        body = <span class="string">"\n"</span> + (body.compile(o, LEVEL_TOP)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab;
      }
      code = set + <span class="keyword">this</span>.tab + (<span class="string">"while ("</span> + (<span class="keyword">this</span>.condition.compile(o, LEVEL_PAREN)) + <span class="string">") {"</span> + body + <span class="string">"}"</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.returns) {
        code += <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"return "</span> + rvar + <span class="string">";"</span>;
      }
      <span class="keyword">return</span> code;
    };

    <span class="keyword">return</span> While;

  })(Base);

  exports.Op = Op = (<span class="keyword">function</span>(_super) {
    <span class="keyword">var</span> CONVERSIONS, INVERSIONS;

    __extends(Op, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Op</span><span class="params">(op, first, second, flip)</span> {</span>
      <span class="keyword">if</span> (op === <span class="string">'in'</span>) {
        <span class="keyword">return</span> <span class="keyword">new</span> In(first, second);
      }
      <span class="keyword">if</span> (op === <span class="string">'do'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.generateDo(first);
      }
      <span class="keyword">if</span> (op === <span class="string">'new'</span>) {
        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> Call &amp;&amp; !first[<span class="string">"do"</span>] &amp;&amp; !first.isNew) {
          <span class="keyword">return</span> first.newInstance();
        }
        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> Code &amp;&amp; first.bound || first[<span class="string">"do"</span>]) {
          first = <span class="keyword">new</span> Parens(first);
        }
      }
      <span class="keyword">this</span>.operator = CONVERSIONS[op] || op;
      <span class="keyword">this</span>.first = first;
      <span class="keyword">this</span>.second = second;
      <span class="keyword">this</span>.flip = !!flip;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }

    CONVERSIONS = {
      <span class="string">'=='</span>: <span class="string">'==='</span>,
      <span class="string">'!='</span>: <span class="string">'!=='</span>,
      <span class="string">'of'</span>: <span class="string">'in'</span>
    };

    INVERSIONS = {
      <span class="string">'!=='</span>: <span class="string">'==='</span>,
      <span class="string">'==='</span>: <span class="string">'!=='</span>
    };

    Op.prototype.children = [<span class="string">'first'</span>, <span class="string">'second'</span>];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isUnary = <span class="keyword">function</span>() {
      <span class="keyword">return</span> !<span class="keyword">this</span>.second;
    };

    Op.prototype.isComplex = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> !(<span class="keyword">this</span>.isUnary() &amp;&amp; ((_ref2 = <span class="keyword">this</span>.operator) === <span class="string">'+'</span> || _ref2 === <span class="string">'-'</span>)) || <span class="keyword">this</span>.first.isComplex();
    };

    Op.prototype.isChainable = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> (_ref2 = <span class="keyword">this</span>.operator) === <span class="string">'&lt;'</span> || _ref2 === <span class="string">'>'</span> || _ref2 === <span class="string">'>='</span> || _ref2 === <span class="string">'&lt;='</span> || _ref2 === <span class="string">'==='</span> || _ref2 === <span class="string">'!=='</span>;
    };

    Op.prototype.invert = <span class="keyword">function</span>() {
      <span class="keyword">var</span> allInvertable, curr, fst, op, _ref2;
      <span class="keyword">if</span> (<span class="keyword">this</span>.isChainable() &amp;&amp; <span class="keyword">this</span>.first.isChainable()) {
        allInvertable = <span class="literal">true</span>;
        curr = <span class="keyword">this</span>;
        <span class="keyword">while</span> (curr &amp;&amp; curr.operator) {
          allInvertable &amp;&amp; (allInvertable = curr.operator <span class="keyword">in</span> INVERSIONS);
          curr = curr.first;
        }
        <span class="keyword">if</span> (!allInvertable) {
          <span class="keyword">return</span> <span class="keyword">new</span> Parens(<span class="keyword">this</span>).invert();
        }
        curr = <span class="keyword">this</span>;
        <span class="keyword">while</span> (curr &amp;&amp; curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (op = INVERSIONS[<span class="keyword">this</span>.operator]) {
        <span class="keyword">this</span>.operator = op;
        <span class="keyword">if</span> (<span class="keyword">this</span>.first.unwrap() <span class="keyword">instanceof</span> Op) {
          <span class="keyword">this</span>.first.invert();
        }
        <span class="keyword">return</span> <span class="keyword">this</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.second) {
        <span class="keyword">return</span> <span class="keyword">new</span> Parens(<span class="keyword">this</span>).invert();
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.operator === <span class="string">'!'</span> &amp;&amp; (fst = <span class="keyword">this</span>.first.unwrap()) <span class="keyword">instanceof</span> Op &amp;&amp; ((_ref2 = fst.operator) === <span class="string">'!'</span> || _ref2 === <span class="string">'in'</span> || _ref2 === <span class="string">'instanceof'</span>)) {
        <span class="keyword">return</span> fst;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">new</span> Op(<span class="string">'!'</span>, <span class="keyword">this</span>);
      }
    };

    Op.prototype.unfoldSoak = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> ((_ref2 = <span class="keyword">this</span>.operator) === <span class="string">'++'</span> || _ref2 === <span class="string">'--'</span> || _ref2 === <span class="string">'delete'</span>) &amp;&amp; unfoldSoak(o, <span class="keyword">this</span>, <span class="string">'first'</span>);
    };

    Op.prototype.generateDo = <span class="keyword">function</span>(exp) {
      <span class="keyword">var</span> call, func, param, passedParams, ref, _i, _len, _ref2;
      passedParams = [];
      func = exp <span class="keyword">instanceof</span> Assign &amp;&amp; (ref = exp.value.unwrap()) <span class="keyword">instanceof</span> Code ? ref : exp;
      _ref2 = func.params || [];
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        param = _ref2[_i];
        <span class="keyword">if</span> (param.value) {
          passedParams.push(param.value);
          <span class="keyword">delete</span> param.value;
        } <span class="keyword">else</span> {
          passedParams.push(param);
        }
      }
      call = <span class="keyword">new</span> Call(exp, passedParams);
      call[<span class="string">"do"</span>] = <span class="literal">true</span>;
      <span class="keyword">return</span> call;
    };

    Op.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, isChain, _ref2, _ref3;
      isChain = <span class="keyword">this</span>.isChainable() &amp;&amp; <span class="keyword">this</span>.first.isChainable();
      <span class="keyword">if</span> (!isChain) {
        <span class="keyword">this</span>.first.front = <span class="keyword">this</span>.front;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.operator === <span class="string">'delete'</span> &amp;&amp; o.scope.check(<span class="keyword">this</span>.first.unwrapAll().value)) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'delete operand may not be argument or var'</span>);
      }
      <span class="keyword">if</span> (((_ref2 = <span class="keyword">this</span>.operator) === <span class="string">'--'</span> || _ref2 === <span class="string">'++'</span>) &amp;&amp; (_ref3 = <span class="keyword">this</span>.first.unwrapAll().value, __indexOf.call(STRICT_PROSCRIBED, _ref3) >= <span class="number">0</span>)) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'prefix increment/decrement may not have eval or arguments operand'</span>);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.isUnary()) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileUnary(o);
      }
      <span class="keyword">if</span> (isChain) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileChain(o);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.operator === <span class="string">'?'</span>) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileExistence(o);
      }
      code = <span class="keyword">this</span>.first.compile(o, LEVEL_OP) + <span class="string">' '</span> + <span class="keyword">this</span>.operator + <span class="string">' '</span> + <span class="keyword">this</span>.second.compile(o, LEVEL_OP);
      <span class="keyword">if</span> (o.level &lt;= LEVEL_OP) {
        <span class="keyword">return</span> code;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      }
    };

    Op.prototype.compileChain = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, fst, shared, _ref2;
      _ref2 = <span class="keyword">this</span>.first.second.cache(o), <span class="keyword">this</span>.first.second = _ref2[<span class="number">0</span>], shared = _ref2[<span class="number">1</span>];
      fst = <span class="keyword">this</span>.first.compile(o, LEVEL_OP);
      code = <span class="string">""</span> + fst + <span class="string">" "</span> + (<span class="keyword">this</span>.invert ? <span class="string">'&amp;&amp;'</span> : <span class="string">'||'</span>) + <span class="string">" "</span> + (shared.compile(o)) + <span class="string">" "</span> + <span class="keyword">this</span>.operator + <span class="string">" "</span> + (<span class="keyword">this</span>.second.compile(o, LEVEL_OP));
      <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
    };

    Op.prototype.compileExistence = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> fst, ref;
      <span class="keyword">if</span> (<span class="keyword">this</span>.first.isComplex()) {
        ref = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'ref'</span>));
        fst = <span class="keyword">new</span> Parens(<span class="keyword">new</span> Assign(ref, <span class="keyword">this</span>.first));
      } <span class="keyword">else</span> {
        fst = <span class="keyword">this</span>.first;
        ref = fst;
      }
      <span class="keyword">return</span> <span class="keyword">new</span> If(<span class="keyword">new</span> Existence(fst), ref, {
        type: <span class="string">'if'</span>
      }).addElse(<span class="keyword">this</span>.second).compile(o);
    };

    Op.prototype.compileUnary = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> op, parts, plusMinus;
      <span class="keyword">if</span> (o.level >= LEVEL_ACCESS) {
        <span class="keyword">return</span> (<span class="keyword">new</span> Parens(<span class="keyword">this</span>)).compile(o);
      }
      parts = [op = <span class="keyword">this</span>.operator];
      plusMinus = op === <span class="string">'+'</span> || op === <span class="string">'-'</span>;
      <span class="keyword">if</span> ((op === <span class="string">'new'</span> || op === <span class="string">'typeof'</span> || op === <span class="string">'delete'</span>) || plusMinus &amp;&amp; <span class="keyword">this</span>.first <span class="keyword">instanceof</span> Op &amp;&amp; <span class="keyword">this</span>.first.operator === op) {
        parts.push(<span class="string">' '</span>);
      }
      <span class="keyword">if</span> ((plusMinus &amp;&amp; <span class="keyword">this</span>.first <span class="keyword">instanceof</span> Op) || (op === <span class="string">'new'</span> &amp;&amp; <span class="keyword">this</span>.first.isStatement(o))) {
        <span class="keyword">this</span>.first = <span class="keyword">new</span> Parens(<span class="keyword">this</span>.first);
      }
      parts.push(<span class="keyword">this</span>.first.compile(o, LEVEL_OP));
      <span class="keyword">if</span> (<span class="keyword">this</span>.flip) {
        parts.reverse();
      }
      <span class="keyword">return</span> parts.join(<span class="string">''</span>);
    };

    Op.prototype.toString = <span class="keyword">function</span>(idt) {
      <span class="keyword">return</span> Op.__super__.toString.call(<span class="keyword">this</span>, idt, <span class="keyword">this</span>.constructor.name + <span class="string">' '</span> + <span class="keyword">this</span>.operator);
    };

    <span class="keyword">return</span> Op;

  })(Base);

  exports.In = In = (<span class="keyword">function</span>(_super) {

    __extends(In, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">In</span><span class="params">(object, array)</span> {</span>
      <span class="keyword">this</span>.object = object;
      <span class="keyword">this</span>.array = array;
    }

    In.prototype.children = [<span class="string">'object'</span>, <span class="string">'array'</span>];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> hasSplat, obj, _i, _len, _ref2;
      <span class="keyword">if</span> (<span class="keyword">this</span>.array <span class="keyword">instanceof</span> Value &amp;&amp; <span class="keyword">this</span>.array.isArray()) {
        _ref2 = <span class="keyword">this</span>.array.base.objects;
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
          obj = _ref2[_i];
          <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Splat)) {
            <span class="keyword">continue</span>;
          }
          hasSplat = <span class="literal">true</span>;
          <span class="keyword">break</span>;
        }
        <span class="keyword">if</span> (!hasSplat) {
          <span class="keyword">return</span> <span class="keyword">this</span>.compileOrTest(o);
        }
      }
      <span class="keyword">return</span> <span class="keyword">this</span>.compileLoopTest(o);
    };

    In.prototype.compileOrTest = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> cmp, cnj, i, item, ref, sub, tests, _ref2, _ref3;
      <span class="keyword">if</span> (<span class="keyword">this</span>.array.base.objects.length === <span class="number">0</span>) {
        <span class="keyword">return</span> <span class="string">""</span> + (!!<span class="keyword">this</span>.negated);
      }
      _ref2 = <span class="keyword">this</span>.object.cache(o, LEVEL_OP), sub = _ref2[<span class="number">0</span>], ref = _ref2[<span class="number">1</span>];
      _ref3 = <span class="keyword">this</span>.negated ? [<span class="string">' !== '</span>, <span class="string">' &amp;&amp; '</span>] : [<span class="string">' === '</span>, <span class="string">' || '</span>], cmp = _ref3[<span class="number">0</span>], cnj = _ref3[<span class="number">1</span>];
      tests = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _ref4, _results;
        _ref4 = <span class="keyword">this</span>.array.base.objects;
        _results = [];
        <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref4.length; _i &lt; _len; i = ++_i) {
          item = _ref4[i];
          _results.push((i ? ref : sub) + cmp + item.compile(o, LEVEL_ACCESS));
        }
        <span class="keyword">return</span> _results;
      }).call(<span class="keyword">this</span>);
      tests = tests.join(cnj);
      <span class="keyword">if</span> (o.level &lt; LEVEL_OP) {
        <span class="keyword">return</span> tests;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + tests + <span class="string">")"</span>;
      }
    };

    In.prototype.compileLoopTest = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> code, ref, sub, _ref2;
      _ref2 = <span class="keyword">this</span>.object.cache(o, LEVEL_LIST), sub = _ref2[<span class="number">0</span>], ref = _ref2[<span class="number">1</span>];
      code = utility(<span class="string">'indexOf'</span>) + (<span class="string">".call("</span> + (<span class="keyword">this</span>.array.compile(o, LEVEL_LIST)) + <span class="string">", "</span> + ref + <span class="string">") "</span>) + (<span class="keyword">this</span>.negated ? <span class="string">'&lt; 0'</span> : <span class="string">'>= 0'</span>);
      <span class="keyword">if</span> (sub === ref) {
        <span class="keyword">return</span> code;
      }
      code = sub + <span class="string">', '</span> + code;
      <span class="keyword">if</span> (o.level &lt; LEVEL_LIST) {
        <span class="keyword">return</span> code;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      }
    };

    In.prototype.toString = <span class="keyword">function</span>(idt) {
      <span class="keyword">return</span> In.__super__.toString.call(<span class="keyword">this</span>, idt, <span class="keyword">this</span>.constructor.name + (<span class="keyword">this</span>.negated ? <span class="string">'!'</span> : <span class="string">''</span>));
    };

    <span class="keyword">return</span> In;

  })(Base);

  exports.Try = Try = (<span class="keyword">function</span>(_super) {

    __extends(Try, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Try</span><span class="params">(attempt, error, recovery, ensure)</span> {</span>
      <span class="keyword">this</span>.attempt = attempt;
      <span class="keyword">this</span>.error = error;
      <span class="keyword">this</span>.recovery = recovery;
      <span class="keyword">this</span>.ensure = ensure;
    }

    Try.prototype.children = [<span class="string">'attempt'</span>, <span class="string">'recovery'</span>, <span class="string">'ensure'</span>];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> <span class="keyword">this</span>.attempt.jumps(o) || ((_ref2 = <span class="keyword">this</span>.recovery) != <span class="literal">null</span> ? _ref2.jumps(o) : <span class="keyword">void</span> <span class="number">0</span>);
    };

    Try.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.attempt) {
        <span class="keyword">this</span>.attempt = <span class="keyword">this</span>.attempt.makeReturn(res);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.recovery) {
        <span class="keyword">this</span>.recovery = <span class="keyword">this</span>.recovery.makeReturn(res);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Try.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> catchPart, ensurePart, errorPart, tryPart;
      o.indent += TAB;
      errorPart = <span class="keyword">this</span>.error ? <span class="string">" ("</span> + (<span class="keyword">this</span>.error.compile(o)) + <span class="string">") "</span> : <span class="string">' '</span>;
      tryPart = <span class="keyword">this</span>.attempt.compile(o, LEVEL_TOP);
      catchPart = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _ref2;
        <span class="keyword">if</span> (<span class="keyword">this</span>.recovery) {
          <span class="keyword">if</span> (_ref2 = <span class="keyword">this</span>.error.value, __indexOf.call(STRICT_PROSCRIBED, _ref2) >= <span class="number">0</span>) {
            <span class="keyword">throw</span> SyntaxError(<span class="string">"catch variable may not be \""</span> + <span class="keyword">this</span>.error.value + <span class="string">"\""</span>);
          }
          <span class="keyword">if</span> (!o.scope.check(<span class="keyword">this</span>.error.value)) {
            o.scope.add(<span class="keyword">this</span>.error.value, <span class="string">'param'</span>);
          }
          <span class="keyword">return</span> <span class="string">" catch"</span> + errorPart + <span class="string">"{\n"</span> + (<span class="keyword">this</span>.recovery.compile(o, LEVEL_TOP)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"}"</span>;
        } <span class="keyword">else</span> <span class="keyword">if</span> (!(<span class="keyword">this</span>.ensure || <span class="keyword">this</span>.recovery)) {
          <span class="keyword">return</span> <span class="string">' catch (_error) {}'</span>;
        }
      }).call(<span class="keyword">this</span>);
      ensurePart = <span class="keyword">this</span>.ensure ? <span class="string">" finally {\n"</span> + (<span class="keyword">this</span>.ensure.compile(o, LEVEL_TOP)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"}"</span> : <span class="string">''</span>;
      <span class="keyword">return</span> <span class="string">""</span> + <span class="keyword">this</span>.tab + <span class="string">"try {\n"</span> + tryPart + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"}"</span> + (catchPart || <span class="string">''</span>) + ensurePart;
    };

    <span class="keyword">return</span> Try;

  })(Base);

  exports.Throw = Throw = (<span class="keyword">function</span>(_super) {

    __extends(Throw, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Throw</span><span class="params">(expression)</span> {</span>
      <span class="keyword">this</span>.expression = expression;
    }

    Throw.prototype.children = [<span class="string">'expression'</span>];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">return</span> <span class="keyword">this</span>.tab + (<span class="string">"throw "</span> + (<span class="keyword">this</span>.expression.compile(o)) + <span class="string">";"</span>);
    };

    <span class="keyword">return</span> Throw;

  })(Base);

  exports.Existence = Existence = (<span class="keyword">function</span>(_super) {

    __extends(Existence, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Existence</span><span class="params">(expression)</span> {</span>
      <span class="keyword">this</span>.expression = expression;
    }

    Existence.prototype.children = [<span class="string">'expression'</span>];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> cmp, cnj, code, _ref2;
      <span class="keyword">this</span>.expression.front = <span class="keyword">this</span>.front;
      code = <span class="keyword">this</span>.expression.compile(o, LEVEL_OP);
      <span class="keyword">if</span> (IDENTIFIER.test(code) &amp;&amp; !o.scope.check(code)) {
        _ref2 = <span class="keyword">this</span>.negated ? [<span class="string">'==='</span>, <span class="string">'||'</span>] : [<span class="string">'!=='</span>, <span class="string">'&amp;&amp;'</span>], cmp = _ref2[<span class="number">0</span>], cnj = _ref2[<span class="number">1</span>];
        code = <span class="string">"typeof "</span> + code + <span class="string">" "</span> + cmp + <span class="string">" \"undefined\" "</span> + cnj + <span class="string">" "</span> + code + <span class="string">" "</span> + cmp + <span class="string">" null"</span>;
      } <span class="keyword">else</span> {
        code = <span class="string">""</span> + code + <span class="string">" "</span> + (<span class="keyword">this</span>.negated ? <span class="string">'=='</span> : <span class="string">'!='</span>) + <span class="string">" null"</span>;
      }
      <span class="keyword">if</span> (o.level &lt;= LEVEL_COND) {
        <span class="keyword">return</span> code;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      }
    };

    <span class="keyword">return</span> Existence;

  })(Base);

  exports.Parens = Parens = (<span class="keyword">function</span>(_super) {

    __extends(Parens, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Parens</span><span class="params">(body)</span> {</span>
      <span class="keyword">this</span>.body = body;
    }

    Parens.prototype.children = [<span class="string">'body'</span>];

    Parens.prototype.unwrap = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.body;
    };

    Parens.prototype.isComplex = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.body.isComplex();
    };

    Parens.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> bare, code, expr;
      expr = <span class="keyword">this</span>.body.unwrap();
      <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Value &amp;&amp; expr.isAtomic()) {
        expr.front = <span class="keyword">this</span>.front;
        <span class="keyword">return</span> expr.compile(o);
      }
      code = expr.compile(o, LEVEL_PAREN);
      bare = o.level &lt; LEVEL_OP &amp;&amp; (expr <span class="keyword">instanceof</span> Op || expr <span class="keyword">instanceof</span> Call || (expr <span class="keyword">instanceof</span> For &amp;&amp; expr.returns));
      <span class="keyword">if</span> (bare) {
        <span class="keyword">return</span> code;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      }
    };

    <span class="keyword">return</span> Parens;

  })(Base);

  exports.For = For = (<span class="keyword">function</span>(_super) {

    __extends(For, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">For</span><span class="params">(body, source)</span> {</span>
      <span class="keyword">var</span> _ref2;
      <span class="keyword">this</span>.source = source.source, <span class="keyword">this</span>.guard = source.guard, <span class="keyword">this</span>.step = source.step, <span class="keyword">this</span>.name = source.name, <span class="keyword">this</span>.index = source.index;
      <span class="keyword">this</span>.body = Block.wrap([body]);
      <span class="keyword">this</span>.own = !!source.own;
      <span class="keyword">this</span>.object = !!source.object;
      <span class="keyword">if</span> (<span class="keyword">this</span>.object) {
        _ref2 = [<span class="keyword">this</span>.index, <span class="keyword">this</span>.name], <span class="keyword">this</span>.name = _ref2[<span class="number">0</span>], <span class="keyword">this</span>.index = _ref2[<span class="number">1</span>];
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.index <span class="keyword">instanceof</span> Value) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'index cannot be a pattern matching expression'</span>);
      }
      <span class="keyword">this</span>.range = <span class="keyword">this</span>.source <span class="keyword">instanceof</span> Value &amp;&amp; <span class="keyword">this</span>.source.base <span class="keyword">instanceof</span> Range &amp;&amp; !<span class="keyword">this</span>.source.properties.length;
      <span class="keyword">this</span>.pattern = <span class="keyword">this</span>.name <span class="keyword">instanceof</span> Value;
      <span class="keyword">if</span> (<span class="keyword">this</span>.range &amp;&amp; <span class="keyword">this</span>.index) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'indexes do not apply to range loops'</span>);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.range &amp;&amp; <span class="keyword">this</span>.pattern) {
        <span class="keyword">throw</span> SyntaxError(<span class="string">'cannot pattern match over range loops'</span>);
      }
      <span class="keyword">this</span>.returns = <span class="literal">false</span>;
    }

    For.prototype.children = [<span class="string">'body'</span>, <span class="string">'source'</span>, <span class="string">'guard'</span>, <span class="string">'step'</span>];

    For.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> body, defPart, forPart, forVarPart, guardPart, idt1, index, ivar, kvar, kvarAssign, lastJumps, lvar, name, namePart, ref, resultPart, returnResult, rvar, scope, source, stepPart, stepvar, svar, varPart, _ref2;
      body = Block.wrap([<span class="keyword">this</span>.body]);
      lastJumps = (_ref2 = last(body.expressions)) != <span class="literal">null</span> ? _ref2.jumps() : <span class="keyword">void</span> <span class="number">0</span>;
      <span class="keyword">if</span> (lastJumps &amp;&amp; lastJumps <span class="keyword">instanceof</span> Return) {
        <span class="keyword">this</span>.returns = <span class="literal">false</span>;
      }
      source = <span class="keyword">this</span>.range ? <span class="keyword">this</span>.source.base : <span class="keyword">this</span>.source;
      scope = o.scope;
      name = <span class="keyword">this</span>.name &amp;&amp; <span class="keyword">this</span>.name.compile(o, LEVEL_LIST);
      index = <span class="keyword">this</span>.index &amp;&amp; <span class="keyword">this</span>.index.compile(o, LEVEL_LIST);
      <span class="keyword">if</span> (name &amp;&amp; !<span class="keyword">this</span>.pattern) {
        scope.find(name);
      }
      <span class="keyword">if</span> (index) {
        scope.find(index);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.returns) {
        rvar = scope.freeVariable(<span class="string">'results'</span>);
      }
      ivar = (<span class="keyword">this</span>.object &amp;&amp; index) || scope.freeVariable(<span class="string">'i'</span>);
      kvar = (<span class="keyword">this</span>.range &amp;&amp; name) || index || ivar;
      kvarAssign = kvar !== ivar ? <span class="string">""</span> + kvar + <span class="string">" = "</span> : <span class="string">""</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.step &amp;&amp; !<span class="keyword">this</span>.range) {
        stepvar = scope.freeVariable(<span class="string">"step"</span>);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.pattern) {
        name = ivar;
      }
      varPart = <span class="string">''</span>;
      guardPart = <span class="string">''</span>;
      defPart = <span class="string">''</span>;
      idt1 = <span class="keyword">this</span>.tab + TAB;
      <span class="keyword">if</span> (<span class="keyword">this</span>.range) {
        forPart = source.compile(merge(o, {
          index: ivar,
          name: name,
          step: <span class="keyword">this</span>.step
        }));
      } <span class="keyword">else</span> {
        svar = <span class="keyword">this</span>.source.compile(o, LEVEL_LIST);
        <span class="keyword">if</span> ((name || <span class="keyword">this</span>.own) &amp;&amp; !IDENTIFIER.test(svar)) {
          defPart = <span class="string">""</span> + <span class="keyword">this</span>.tab + (ref = scope.freeVariable(<span class="string">'ref'</span>)) + <span class="string">" = "</span> + svar + <span class="string">";\n"</span>;
          svar = ref;
        }
        <span class="keyword">if</span> (name &amp;&amp; !<span class="keyword">this</span>.pattern) {
          namePart = <span class="string">""</span> + name + <span class="string">" = "</span> + svar + <span class="string">"["</span> + kvar + <span class="string">"]"</span>;
        }
        <span class="keyword">if</span> (!<span class="keyword">this</span>.object) {
          lvar = scope.freeVariable(<span class="string">'len'</span>);
          forVarPart = <span class="string">""</span> + kvarAssign + ivar + <span class="string">" = 0, "</span> + lvar + <span class="string">" = "</span> + svar + <span class="string">".length"</span>;
          <span class="keyword">if</span> (<span class="keyword">this</span>.step) {
            forVarPart += <span class="string">", "</span> + stepvar + <span class="string">" = "</span> + (<span class="keyword">this</span>.step.compile(o, LEVEL_OP));
          }
          stepPart = <span class="string">""</span> + kvarAssign + (<span class="keyword">this</span>.step ? <span class="string">""</span> + ivar + <span class="string">" += "</span> + stepvar : (kvar !== ivar ? <span class="string">"++"</span> + ivar : <span class="string">""</span> + ivar + <span class="string">"++"</span>));
          forPart = <span class="string">""</span> + forVarPart + <span class="string">"; "</span> + ivar + <span class="string">" &lt; "</span> + lvar + <span class="string">"; "</span> + stepPart;
        }
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.returns) {
        resultPart = <span class="string">""</span> + <span class="keyword">this</span>.tab + rvar + <span class="string">" = [];\n"</span>;
        returnResult = <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"return "</span> + rvar + <span class="string">";"</span>;
        body.makeReturn(rvar);
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.guard) {
        <span class="keyword">if</span> (body.expressions.length > <span class="number">1</span>) {
          body.expressions.unshift(<span class="keyword">new</span> If((<span class="keyword">new</span> Parens(<span class="keyword">this</span>.guard)).invert(), <span class="keyword">new</span> Literal(<span class="string">"continue"</span>)));
        } <span class="keyword">else</span> {
          <span class="keyword">if</span> (<span class="keyword">this</span>.guard) {
            body = Block.wrap([<span class="keyword">new</span> If(<span class="keyword">this</span>.guard, body)]);
          }
        }
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.pattern) {
        body.expressions.unshift(<span class="keyword">new</span> Assign(<span class="keyword">this</span>.name, <span class="keyword">new</span> Literal(<span class="string">""</span> + svar + <span class="string">"["</span> + kvar + <span class="string">"]"</span>)));
      }
      defPart += <span class="keyword">this</span>.pluckDirectCall(o, body);
      <span class="keyword">if</span> (namePart) {
        varPart = <span class="string">"\n"</span> + idt1 + namePart + <span class="string">";"</span>;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.object) {
        forPart = <span class="string">""</span> + kvar + <span class="string">" in "</span> + svar;
        <span class="keyword">if</span> (<span class="keyword">this</span>.own) {
          guardPart = <span class="string">"\n"</span> + idt1 + <span class="string">"if (!"</span> + (utility(<span class="string">'hasProp'</span>)) + <span class="string">".call("</span> + svar + <span class="string">", "</span> + kvar + <span class="string">")) continue;"</span>;
        }
      }
      body = body.compile(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      <span class="keyword">if</span> (body) {
        body = <span class="string">'\n'</span> + body + <span class="string">'\n'</span>;
      }
      <span class="keyword">return</span> <span class="string">""</span> + defPart + (resultPart || <span class="string">''</span>) + <span class="keyword">this</span>.tab + <span class="string">"for ("</span> + forPart + <span class="string">") {"</span> + guardPart + varPart + body + <span class="keyword">this</span>.tab + <span class="string">"}"</span> + (returnResult || <span class="string">''</span>);
    };

    For.prototype.pluckDirectCall = <span class="keyword">function</span>(o, body) {
      <span class="keyword">var</span> base, defs, expr, fn, idx, ref, val, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      defs = <span class="string">''</span>;
      _ref2 = body.expressions;
      <span class="keyword">for</span> (idx = _i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; idx = ++_i) {
        expr = _ref2[idx];
        expr = expr.unwrapAll();
        <span class="keyword">if</span> (!(expr <span class="keyword">instanceof</span> Call)) {
          <span class="keyword">continue</span>;
        }
        val = expr.variable.unwrapAll();
        <span class="keyword">if</span> (!((val <span class="keyword">instanceof</span> Code) || (val <span class="keyword">instanceof</span> Value &amp;&amp; ((_ref3 = val.base) != <span class="literal">null</span> ? _ref3.unwrapAll() : <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">instanceof</span> Code &amp;&amp; val.properties.length === <span class="number">1</span> &amp;&amp; ((_ref4 = (_ref5 = val.properties[<span class="number">0</span>].name) != <span class="literal">null</span> ? _ref5.value : <span class="keyword">void</span> <span class="number">0</span>) === <span class="string">'call'</span> || _ref4 === <span class="string">'apply'</span>)))) {
          <span class="keyword">continue</span>;
        }
        fn = ((_ref6 = val.base) != <span class="literal">null</span> ? _ref6.unwrapAll() : <span class="keyword">void</span> <span class="number">0</span>) || val;
        ref = <span class="keyword">new</span> Literal(o.scope.freeVariable(<span class="string">'fn'</span>));
        base = <span class="keyword">new</span> Value(ref);
        <span class="keyword">if</span> (val.base) {
          _ref7 = [base, val], val.base = _ref7[<span class="number">0</span>], base = _ref7[<span class="number">1</span>];
        }
        body.expressions[idx] = <span class="keyword">new</span> Call(base, expr.args);
        defs += <span class="keyword">this</span>.tab + <span class="keyword">new</span> Assign(ref, fn).compile(o, LEVEL_TOP) + <span class="string">';\n'</span>;
      }
      <span class="keyword">return</span> defs;
    };

    <span class="keyword">return</span> For;

  })(While);

  exports.Switch = Switch = (<span class="keyword">function</span>(_super) {

    __extends(Switch, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">Switch</span><span class="params">(subject, cases, otherwise)</span> {</span>
      <span class="keyword">this</span>.subject = subject;
      <span class="keyword">this</span>.cases = cases;
      <span class="keyword">this</span>.otherwise = otherwise;
    }

    Switch.prototype.children = [<span class="string">'subject'</span>, <span class="string">'cases'</span>, <span class="string">'otherwise'</span>];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> block, conds, _i, _len, _ref2, _ref3, _ref4;
      <span class="keyword">if</span> (o == <span class="literal">null</span>) {
        o = {
          block: <span class="literal">true</span>
        };
      }
      _ref2 = <span class="keyword">this</span>.cases;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        _ref3 = _ref2[_i], conds = _ref3[<span class="number">0</span>], block = _ref3[<span class="number">1</span>];
        <span class="keyword">if</span> (block.jumps(o)) {
          <span class="keyword">return</span> block;
        }
      }
      <span class="keyword">return</span> (_ref4 = <span class="keyword">this</span>.otherwise) != <span class="literal">null</span> ? _ref4.jumps(o) : <span class="keyword">void</span> <span class="number">0</span>;
    };

    Switch.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">var</span> pair, _i, _len, _ref2, _ref3;
      _ref2 = <span class="keyword">this</span>.cases;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref2.length; _i &lt; _len; _i++) {
        pair = _ref2[_i];
        pair[<span class="number">1</span>].makeReturn(res);
      }
      <span class="keyword">if</span> (res) {
        <span class="keyword">this</span>.otherwise || (<span class="keyword">this</span>.otherwise = <span class="keyword">new</span> Block([<span class="keyword">new</span> Literal(<span class="string">'void 0'</span>)]));
      }
      <span class="keyword">if</span> ((_ref3 = <span class="keyword">this</span>.otherwise) != <span class="literal">null</span>) {
        _ref3.makeReturn(res);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    Switch.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> block, body, code, cond, conditions, expr, i, idt1, idt2, _i, _j, _len, _len1, _ref2, _ref3, _ref4, _ref5;
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      code = <span class="keyword">this</span>.tab + (<span class="string">"switch ("</span> + (((_ref2 = <span class="keyword">this</span>.subject) != <span class="literal">null</span> ? _ref2.compile(o, LEVEL_PAREN) : <span class="keyword">void</span> <span class="number">0</span>) || <span class="literal">false</span>) + <span class="string">") {\n"</span>);
      _ref3 = <span class="keyword">this</span>.cases;
      <span class="keyword">for</span> (i = _i = <span class="number">0</span>, _len = _ref3.length; _i &lt; _len; i = ++_i) {
        _ref4 = _ref3[i], conditions = _ref4[<span class="number">0</span>], block = _ref4[<span class="number">1</span>];
        _ref5 = flatten([conditions]);
        <span class="keyword">for</span> (_j = <span class="number">0</span>, _len1 = _ref5.length; _j &lt; _len1; _j++) {
          cond = _ref5[_j];
          <span class="keyword">if</span> (!<span class="keyword">this</span>.subject) {
            cond = cond.invert();
          }
          code += idt1 + (<span class="string">"case "</span> + (cond.compile(o, LEVEL_PAREN)) + <span class="string">":\n"</span>);
        }
        <span class="keyword">if</span> (body = block.compile(o, LEVEL_TOP)) {
          code += body + <span class="string">'\n'</span>;
        }
        <span class="keyword">if</span> (i === <span class="keyword">this</span>.cases.length - <span class="number">1</span> &amp;&amp; !<span class="keyword">this</span>.otherwise) {
          <span class="keyword">break</span>;
        }
        expr = <span class="keyword">this</span>.lastNonComment(block.expressions);
        <span class="keyword">if</span> (expr <span class="keyword">instanceof</span> Return || (expr <span class="keyword">instanceof</span> Literal &amp;&amp; expr.jumps() &amp;&amp; expr.value !== <span class="string">'debugger'</span>)) {
          <span class="keyword">continue</span>;
        }
        code += idt2 + <span class="string">'break;\n'</span>;
      }
      <span class="keyword">if</span> (<span class="keyword">this</span>.otherwise &amp;&amp; <span class="keyword">this</span>.otherwise.expressions.length) {
        code += idt1 + (<span class="string">"default:\n"</span> + (<span class="keyword">this</span>.otherwise.compile(o, LEVEL_TOP)) + <span class="string">"\n"</span>);
      }
      <span class="keyword">return</span> code + <span class="keyword">this</span>.tab + <span class="string">'}'</span>;
    };

    <span class="keyword">return</span> Switch;

  })(Base);

  exports.If = If = (<span class="keyword">function</span>(_super) {

    __extends(If, _super);

    <span class="function"><span class="keyword">function</span> <span class="title">If</span><span class="params">(condition, body, options)</span> {</span>
      <span class="keyword">this</span>.body = body;
      <span class="keyword">if</span> (options == <span class="literal">null</span>) {
        options = {};
      }
      <span class="keyword">this</span>.condition = options.type === <span class="string">'unless'</span> ? condition.invert() : condition;
      <span class="keyword">this</span>.elseBody = <span class="literal">null</span>;
      <span class="keyword">this</span>.isChain = <span class="literal">false</span>;
      <span class="keyword">this</span>.soak = options.soak;
    }

    If.prototype.children = [<span class="string">'condition'</span>, <span class="string">'body'</span>, <span class="string">'elseBody'</span>];

    If.prototype.bodyNode = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> (_ref2 = <span class="keyword">this</span>.body) != <span class="literal">null</span> ? _ref2.unwrap() : <span class="keyword">void</span> <span class="number">0</span>;
    };

    If.prototype.elseBodyNode = <span class="keyword">function</span>() {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> (_ref2 = <span class="keyword">this</span>.elseBody) != <span class="literal">null</span> ? _ref2.unwrap() : <span class="keyword">void</span> <span class="number">0</span>;
    };

    If.prototype.addElse = <span class="keyword">function</span>(elseBody) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.isChain) {
        <span class="keyword">this</span>.elseBodyNode().addElse(elseBody);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.isChain = elseBody <span class="keyword">instanceof</span> If;
        <span class="keyword">this</span>.elseBody = <span class="keyword">this</span>.ensureBlock(elseBody);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    If.prototype.isStatement = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> (o != <span class="literal">null</span> ? o.level : <span class="keyword">void</span> <span class="number">0</span>) === LEVEL_TOP || <span class="keyword">this</span>.bodyNode().isStatement(o) || ((_ref2 = <span class="keyword">this</span>.elseBodyNode()) != <span class="literal">null</span> ? _ref2.isStatement(o) : <span class="keyword">void</span> <span class="number">0</span>);
    };

    If.prototype.jumps = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> _ref2;
      <span class="keyword">return</span> <span class="keyword">this</span>.body.jumps(o) || ((_ref2 = <span class="keyword">this</span>.elseBody) != <span class="literal">null</span> ? _ref2.jumps(o) : <span class="keyword">void</span> <span class="number">0</span>);
    };

    If.prototype.compileNode = <span class="keyword">function</span>(o) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.isStatement(o)) {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileStatement(o);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.compileExpression(o);
      }
    };

    If.prototype.makeReturn = <span class="keyword">function</span>(res) {
      <span class="keyword">if</span> (res) {
        <span class="keyword">this</span>.elseBody || (<span class="keyword">this</span>.elseBody = <span class="keyword">new</span> Block([<span class="keyword">new</span> Literal(<span class="string">'void 0'</span>)]));
      }
      <span class="keyword">this</span>.body &amp;&amp; (<span class="keyword">this</span>.body = <span class="keyword">new</span> Block([<span class="keyword">this</span>.body.makeReturn(res)]));
      <span class="keyword">this</span>.elseBody &amp;&amp; (<span class="keyword">this</span>.elseBody = <span class="keyword">new</span> Block([<span class="keyword">this</span>.elseBody.makeReturn(res)]));
      <span class="keyword">return</span> <span class="keyword">this</span>;
    };

    If.prototype.ensureBlock = <span class="keyword">function</span>(node) {
      <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Block) {
        <span class="keyword">return</span> node;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">new</span> Block([node]);
      }
    };

    If.prototype.compileStatement = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> body, child, cond, exeq, ifPart;
      child = del(o, <span class="string">'chainChild'</span>);
      exeq = del(o, <span class="string">'isExistentialEquals'</span>);
      <span class="keyword">if</span> (exeq) {
        <span class="keyword">return</span> <span class="keyword">new</span> If(<span class="keyword">this</span>.condition.invert(), <span class="keyword">this</span>.elseBodyNode(), {
          type: <span class="string">'if'</span>
        }).compile(o);
      }
      cond = <span class="keyword">this</span>.condition.compile(o, LEVEL_PAREN);
      o.indent += TAB;
      body = <span class="keyword">this</span>.ensureBlock(<span class="keyword">this</span>.body);
      ifPart = <span class="string">"if ("</span> + cond + <span class="string">") {\n"</span> + (body.compile(o)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"}"</span>;
      <span class="keyword">if</span> (!child) {
        ifPart = <span class="keyword">this</span>.tab + ifPart;
      }
      <span class="keyword">if</span> (!<span class="keyword">this</span>.elseBody) {
        <span class="keyword">return</span> ifPart;
      }
      <span class="keyword">return</span> ifPart + <span class="string">' else '</span> + (<span class="keyword">this</span>.isChain ? (o.indent = <span class="keyword">this</span>.tab, o.chainChild = <span class="literal">true</span>, <span class="keyword">this</span>.elseBody.unwrap().compile(o, LEVEL_TOP)) : <span class="string">"{\n"</span> + (<span class="keyword">this</span>.elseBody.compile(o, LEVEL_TOP)) + <span class="string">"\n"</span> + <span class="keyword">this</span>.tab + <span class="string">"}"</span>);
    };

    If.prototype.compileExpression = <span class="keyword">function</span>(o) {
      <span class="keyword">var</span> alt, body, code, cond;
      cond = <span class="keyword">this</span>.condition.compile(o, LEVEL_COND);
      body = <span class="keyword">this</span>.bodyNode().compile(o, LEVEL_LIST);
      alt = <span class="keyword">this</span>.elseBodyNode() ? <span class="keyword">this</span>.elseBodyNode().compile(o, LEVEL_LIST) : <span class="string">'void 0'</span>;
      code = <span class="string">""</span> + cond + <span class="string">" ? "</span> + body + <span class="string">" : "</span> + alt;
      <span class="keyword">if</span> (o.level >= LEVEL_COND) {
        <span class="keyword">return</span> <span class="string">"("</span> + code + <span class="string">")"</span>;
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> code;
      }
    };

    If.prototype.unfoldSoak = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.soak &amp;&amp; <span class="keyword">this</span>;
    };

    <span class="keyword">return</span> If;

  })(Base);

  Closure = {
    wrap: <span class="keyword">function</span>(expressions, statement, noReturn) {
      <span class="keyword">var</span> args, call, func, mentionsArgs, meth;
      <span class="keyword">if</span> (expressions.jumps()) {
        <span class="keyword">return</span> expressions;
      }
      func = <span class="keyword">new</span> Code([], Block.wrap([expressions]));
      args = [];
      <span class="keyword">if</span> ((mentionsArgs = expressions.contains(<span class="keyword">this</span>.literalArgs)) || expressions.contains(<span class="keyword">this</span>.literalThis)) {
        meth = <span class="keyword">new</span> Literal(mentionsArgs ? <span class="string">'apply'</span> : <span class="string">'call'</span>);
        args = [<span class="keyword">new</span> Literal(<span class="string">'this'</span>)];
        <span class="keyword">if</span> (mentionsArgs) {
          args.push(<span class="keyword">new</span> Literal(<span class="string">'arguments'</span>));
        }
        func = <span class="keyword">new</span> Value(func, [<span class="keyword">new</span> Access(meth)]);
      }
      func.noReturn = noReturn;
      call = <span class="keyword">new</span> Call(func, args);
      <span class="keyword">if</span> (statement) {
        <span class="keyword">return</span> Block.wrap([call]);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> call;
      }
    },
    literalArgs: <span class="keyword">function</span>(node) {
      <span class="keyword">return</span> node <span class="keyword">instanceof</span> Literal &amp;&amp; node.value === <span class="string">'arguments'</span> &amp;&amp; !node.asKey;
    },
    literalThis: <span class="keyword">function</span>(node) {
      <span class="keyword">return</span> (node <span class="keyword">instanceof</span> Literal &amp;&amp; node.value === <span class="string">'this'</span> &amp;&amp; !node.asKey) || (node <span class="keyword">instanceof</span> Code &amp;&amp; node.bound) || (node <span class="keyword">instanceof</span> Call &amp;&amp; node.isSuper);
    }
  };

  unfoldSoak = <span class="keyword">function</span>(o, parent, name) {
    <span class="keyword">var</span> ifn;
    <span class="keyword">if</span> (!(ifn = parent[name].unfoldSoak(o))) {
      <span class="keyword">return</span>;
    }
    parent[name] = ifn.body;
    ifn.body = <span class="keyword">new</span> Value(parent);
    <span class="keyword">return</span> ifn;
  };

  UTILITIES = {
    <span class="string">"extends"</span>: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">"function(child, parent) { for (var key in parent) { if ("</span> + (utility(<span class="string">'hasProp'</span>)) + <span class="string">".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }"</span>;
    },
    bind: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">'function(fn, me){ return function(){ return fn.apply(me, arguments); }; }'</span>;
    },
    indexOf: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">"[].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; }"</span>;
    },
    hasProp: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">'{}.hasOwnProperty'</span>;
    },
    slice: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">'[].slice'</span>;
    }
  };

  LEVEL_TOP = <span class="number">1</span>;

  LEVEL_PAREN = <span class="number">2</span>;

  LEVEL_LIST = <span class="number">3</span>;

  LEVEL_COND = <span class="number">4</span>;

  LEVEL_OP = <span class="number">5</span>;

  LEVEL_ACCESS = <span class="number">6</span>;

  TAB = <span class="string">'  '</span>;

  IDENTIFIER_STR = <span class="string">"[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*"</span>;

  IDENTIFIER = RegExp(<span class="string">"^"</span> + IDENTIFIER_STR + <span class="string">"$"</span>);

  SIMPLENUM = <span class="regexp">/^[+-]?\d+$/</span>;

  METHOD_DEF = RegExp(<span class="string">"^(?:("</span> + IDENTIFIER_STR + <span class="string">")\\.prototype(?:\\.("</span> + IDENTIFIER_STR + <span class="string">")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\]))|("</span> + IDENTIFIER_STR + <span class="string">")$"</span>);

  IS_STRING = <span class="regexp">/^['"]/</span>;

  utility = <span class="keyword">function</span>(name) {
    <span class="keyword">var</span> ref;
    ref = <span class="string">"__"</span> + name;
    Scope.root.assign(ref, UTILITIES[name]());
    <span class="keyword">return</span> ref;
  };

  multident = <span class="keyword">function</span>(code, tab) {
    code = code.replace(<span class="regexp">/\n/g</span>, <span class="string">'$&amp;'</span> + tab);
    <span class="keyword">return</span> code.replace(<span class="regexp">/\s+$/</span>, <span class="string">''</span>);
  };

}).call(<span class="keyword">this</span>);
</code></pre>