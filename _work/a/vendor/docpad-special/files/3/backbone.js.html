<h1>backbone.js</h1>
<pre><code class="lang-js"><span class="comment">//     Backbone.js 0.9.9</span>

<span class="comment">//     (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.</span>
<span class="comment">//     Backbone may be freely distributed under the MIT license.</span>
<span class="comment">//     For all details and documentation:</span>
<span class="comment">//     http://backbonejs.org</span>

(<span class="keyword">function</span>(){

  <span class="comment">// Initial Setup</span>
  <span class="comment">// -------------</span>

  <span class="comment">// Save a reference to the global object (`window` in the browser, `exports`</span>
  <span class="comment">// on the server).</span>
  <span class="keyword">var</span> root = <span class="keyword">this</span>;

  <span class="comment">// Save the previous value of the `Backbone` variable, so that it can be</span>
  <span class="comment">// restored later on, if `noConflict` is used.</span>
  <span class="keyword">var</span> previousBackbone = root.Backbone;

  <span class="comment">// Create a local reference to array methods.</span>
  <span class="keyword">var</span> array = [];
  <span class="keyword">var</span> push = array.push;
  <span class="keyword">var</span> slice = array.slice;
  <span class="keyword">var</span> splice = array.splice;

  <span class="comment">// The top-level namespace. All public Backbone classes and modules will</span>
  <span class="comment">// be attached to this. Exported for both CommonJS and the browser.</span>
  <span class="keyword">var</span> Backbone;
  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) {
    Backbone = exports;
  } <span class="keyword">else</span> {
    Backbone = root.Backbone = {};
  }

  <span class="comment">// Current version of the library. Keep in sync with `package.json`.</span>
  Backbone.VERSION = <span class="string">'0.9.9'</span>;

  <span class="comment">// Require Underscore, if we're on the server, and it's not already present.</span>
  <span class="keyword">var</span> _ = root._;
  <span class="keyword">if</span> (!_ &amp;&amp; (<span class="keyword">typeof</span> require !== <span class="string">'undefined'</span>)) _ = require(<span class="string">'underscore'</span>);

  <span class="comment">// For Backbone's purposes, jQuery, Zepto, or Ender owns the `$` variable.</span>
  Backbone.$ = root.jQuery || root.Zepto || root.ender;

  <span class="comment">// Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable</span>
  <span class="comment">// to its previous owner. Returns a reference to this Backbone object.</span>
  Backbone.noConflict = <span class="keyword">function</span>() {
    root.Backbone = previousBackbone;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };

  <span class="comment">// Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option</span>
  <span class="comment">// will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and</span>
  <span class="comment">// set a `X-Http-Method-Override` header.</span>
  Backbone.emulateHTTP = <span class="literal">false</span>;

  <span class="comment">// Turn on `emulateJSON` to support legacy servers that can't deal with direct</span>
  <span class="comment">// `application/json` requests ... will encode the body as</span>
  <span class="comment">// `application/x-www-form-urlencoded` instead and will send the model in a</span>
  <span class="comment">// form param named `model`.</span>
  Backbone.emulateJSON = <span class="literal">false</span>;

  <span class="comment">// Backbone.Events</span>
  <span class="comment">// ---------------</span>

  <span class="comment">// Regular expression used to split event strings.</span>
  <span class="keyword">var</span> eventSplitter = <span class="regexp">/\s+/</span>;

  <span class="comment">// Implement fancy features of the Events API such as multiple event</span>
  <span class="comment">// names `"change blur"` and jQuery-style event maps `{change: action}`</span>
  <span class="comment">// in terms of the existing API.</span>
  <span class="keyword">var</span> eventsApi = <span class="keyword">function</span>(obj, action, name, rest) {
    <span class="keyword">if</span> (!name) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">'object'</span>) {
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
    } <span class="keyword">else</span> <span class="keyword">if</span> (eventSplitter.test(name)) {
      <span class="keyword">var</span> names = name.split(eventSplitter);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = names.length; i &lt; l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
  };

  <span class="comment">// Optimized internal dispatch function for triggering events. Tries to</span>
  <span class="comment">// keep the usual cases speedy (most Backbone events have 3 arguments).</span>
  <span class="keyword">var</span> triggerEvents = <span class="keyword">function</span>(obj, events, args) {
    <span class="keyword">var</span> ev, i = -<span class="number">1</span>, l = events.length;
    <span class="keyword">switch</span> (args.length) {
    <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx);
    <span class="keyword">return</span>;
    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, args[<span class="number">0</span>]);
    <span class="keyword">return</span>;
    <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, args[<span class="number">0</span>], args[<span class="number">1</span>]);
    <span class="keyword">return</span>;
    <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, args[<span class="number">0</span>], args[<span class="number">1</span>], args[<span class="number">2</span>]);
    <span class="keyword">return</span>;
    <span class="keyword">default</span>: <span class="keyword">while</span> (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  <span class="comment">// A module that can be mixed in to *any object* in order to provide it with</span>
  <span class="comment">// custom events. You may bind with `on` or remove with `off` callback</span>
  <span class="comment">// functions to an event; `trigger`-ing an event fires all callbacks in</span>
  <span class="comment">// succession.</span>
  <span class="comment">//</span>
  <span class="comment">//     var object = {};</span>
  <span class="comment">//     _.extend(object, Backbone.Events);</span>
  <span class="comment">//     object.on('expand', function(){ alert('expanded'); });</span>
  <span class="comment">//     object.trigger('expand');</span>
  <span class="comment">//</span>
  <span class="keyword">var</span> Events = Backbone.Events = {

    <span class="comment">// Bind one or more space separated events, or an events map,</span>
    <span class="comment">// to a `callback` function. Passing `"all"` will bind the callback to</span>
    <span class="comment">// all events fired.</span>
    on: <span class="keyword">function</span>(name, callback, context) {
      <span class="keyword">if</span> (!(eventsApi(<span class="keyword">this</span>, <span class="string">'on'</span>, name, [callback, context]) &amp;&amp; callback)) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">this</span>._events || (<span class="keyword">this</span>._events = {});
      <span class="keyword">var</span> list = <span class="keyword">this</span>._events[name] || (<span class="keyword">this</span>._events[name] = []);
      list.push({callback: callback, context: context, ctx: context || <span class="keyword">this</span>});
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Bind events to only be triggered a single time. After the first time</span>
    <span class="comment">// the callback is invoked, it will be removed.</span>
    once: <span class="keyword">function</span>(name, callback, context) {
      <span class="keyword">if</span> (!(eventsApi(<span class="keyword">this</span>, <span class="string">'once'</span>, name, [callback, context]) &amp;&amp; callback)) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> self = <span class="keyword">this</span>;
      <span class="keyword">var</span> once = _.once(<span class="keyword">function</span>() {
        self.off(name, once);
        callback.apply(<span class="keyword">this</span>, arguments);
      });
      once._callback = callback;
      <span class="keyword">this</span>.on(name, once, context);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Remove one or many callbacks. If `context` is null, removes all</span>
    <span class="comment">// callbacks with that function. If `callback` is null, removes all</span>
    <span class="comment">// callbacks for the event. If `events` is null, removes all bound</span>
    <span class="comment">// callbacks for all events.</span>
    off: <span class="keyword">function</span>(name, callback, context) {
      <span class="keyword">var</span> list, ev, events, names, i, l, j, k;
      <span class="keyword">if</span> (!<span class="keyword">this</span>._events || !eventsApi(<span class="keyword">this</span>, <span class="string">'off'</span>, name, [callback, context])) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">if</span> (!name &amp;&amp; !callback &amp;&amp; !context) {
        <span class="keyword">this</span>._events = {};
        <span class="keyword">return</span> <span class="keyword">this</span>;
      }

      names = name ? [name] : _.keys(<span class="keyword">this</span>._events);
      <span class="keyword">for</span> (i = <span class="number">0</span>, l = names.length; i &lt; l; i++) {
        name = names[i];
        <span class="keyword">if</span> (list = <span class="keyword">this</span>._events[name]) {
          events = [];
          <span class="keyword">if</span> (callback || context) {
            <span class="keyword">for</span> (j = <span class="number">0</span>, k = list.length; j &lt; k; j++) {
              ev = list[j];
              <span class="keyword">if</span> ((callback &amp;&amp; callback !== (ev.callback._callback || ev.callback)) ||
                  (context &amp;&amp; context !== ev.context)) {
                events.push(ev);
              }
            }
          }
          <span class="keyword">this</span>._events[name] = events;
        }
      }

      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Trigger one or many events, firing all bound callbacks. Callbacks are</span>
    <span class="comment">// passed the same arguments as `trigger` is, apart from the event name</span>
    <span class="comment">// (unless you're listening on `"all"`, which will cause your callback to</span>
    <span class="comment">// receive the true name of the event as the first argument).</span>
    trigger: <span class="keyword">function</span>(name) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._events) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> args = slice.call(arguments, <span class="number">1</span>);
      <span class="keyword">if</span> (!eventsApi(<span class="keyword">this</span>, <span class="string">'trigger'</span>, name, args)) <span class="keyword">return</span> <span class="keyword">this</span>;
      <span class="keyword">var</span> events = <span class="keyword">this</span>._events[name];
      <span class="keyword">var</span> allEvents = <span class="keyword">this</span>._events.all;
      <span class="keyword">if</span> (events) triggerEvents(<span class="keyword">this</span>, events, args);
      <span class="keyword">if</span> (allEvents) triggerEvents(<span class="keyword">this</span>, allEvents, arguments);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// An inversion-of-control version of `on`. Tell *this* object to listen to</span>
    <span class="comment">// an event in another object ... keeping track of what it's listening to.</span>
    listenTo: <span class="keyword">function</span>(object, events, callback) {
      <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners || (<span class="keyword">this</span>._listeners = {});
      <span class="keyword">var</span> id = object._listenerId || (object._listenerId = _.uniqueId(<span class="string">'l'</span>));
      listeners[id] = object;
      object.on(events, callback || <span class="keyword">this</span>, <span class="keyword">this</span>);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Tell this object to stop listening to either specific events ... or</span>
    <span class="comment">// to every object it's currently listening to.</span>
    stopListening: <span class="keyword">function</span>(object, events, callback) {
      <span class="keyword">var</span> listeners = <span class="keyword">this</span>._listeners;
      <span class="keyword">if</span> (!listeners) <span class="keyword">return</span>;
      <span class="keyword">if</span> (object) {
        object.off(events, callback, <span class="keyword">this</span>);
        <span class="keyword">if</span> (!events &amp;&amp; !callback) <span class="keyword">delete</span> listeners[object._listenerId];
      } <span class="keyword">else</span> {
        <span class="keyword">for</span> (<span class="keyword">var</span> id <span class="keyword">in</span> listeners) {
          listeners[id].off(<span class="literal">null</span>, <span class="literal">null</span>, <span class="keyword">this</span>);
        }
        <span class="keyword">this</span>._listeners = {};
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    }
  };

  <span class="comment">// Aliases for backwards compatibility.</span>
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  <span class="comment">// Allow the `Backbone` object to serve as a global event bus, for folks who</span>
  <span class="comment">// want global "pubsub" in a convenient place.</span>
  _.extend(Backbone, Events);

  <span class="comment">// Backbone.Model</span>
  <span class="comment">// --------------</span>

  <span class="comment">// Create a new model, with defined attributes. A client id (`cid`)</span>
  <span class="comment">// is automatically generated and assigned for you.</span>
  <span class="keyword">var</span> Model = Backbone.Model = <span class="keyword">function</span>(attributes, options) {
    <span class="keyword">var</span> defaults;
    <span class="keyword">var</span> attrs = attributes || {};
    <span class="keyword">this</span>.cid = _.uniqueId(<span class="string">'c'</span>);
    <span class="keyword">this</span>.changed = {};
    <span class="keyword">this</span>.attributes = {};
    <span class="keyword">this</span>._changes = [];
    <span class="keyword">if</span> (options &amp;&amp; options.collection) <span class="keyword">this</span>.collection = options.collection;
    <span class="keyword">if</span> (options &amp;&amp; options.parse) attrs = <span class="keyword">this</span>.parse(attrs);
    <span class="keyword">if</span> (defaults = _.result(<span class="keyword">this</span>, <span class="string">'defaults'</span>)) _.defaults(attrs, defaults);
    <span class="keyword">this</span>.set(attrs, {silent: <span class="literal">true</span>});
    <span class="keyword">this</span>._currentAttributes = _.clone(<span class="keyword">this</span>.attributes);
    <span class="keyword">this</span>._previousAttributes = _.clone(<span class="keyword">this</span>.attributes);
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
  };

  <span class="comment">// Attach all inheritable methods to the Model prototype.</span>
  _.extend(Model.prototype, Events, {

    <span class="comment">// A hash of attributes whose current and previous value differ.</span>
    changed: <span class="literal">null</span>,

    <span class="comment">// The default name for the JSON `id` attribute is `"id"`. MongoDB and</span>
    <span class="comment">// CouchDB users may want to set this to `"_id"`.</span>
    idAttribute: <span class="string">'id'</span>,

    <span class="comment">// Initialize is an empty function by default. Override it with your own</span>
    <span class="comment">// initialization logic.</span>
    initialize: <span class="keyword">function</span>(){},

    <span class="comment">// Return a copy of the model's `attributes` object.</span>
    toJSON: <span class="keyword">function</span>(options) {
      <span class="keyword">return</span> _.clone(<span class="keyword">this</span>.attributes);
    },

    <span class="comment">// Proxy `Backbone.sync` by default.</span>
    sync: <span class="keyword">function</span>() {
      <span class="keyword">return</span> Backbone.sync.apply(<span class="keyword">this</span>, arguments);
    },

    <span class="comment">// Get the value of an attribute.</span>
    get: <span class="keyword">function</span>(attr) {
      <span class="keyword">return</span> <span class="keyword">this</span>.attributes[attr];
    },

    <span class="comment">// Get the HTML-escaped value of an attribute.</span>
    escape: <span class="keyword">function</span>(attr) {
      <span class="keyword">return</span> _.escape(<span class="keyword">this</span>.get(attr));
    },

    <span class="comment">// Returns `true` if the attribute contains a value that is not null</span>
    <span class="comment">// or undefined.</span>
    has: <span class="keyword">function</span>(attr) {
      <span class="keyword">return</span> <span class="keyword">this</span>.get(attr) != <span class="literal">null</span>;
    },

    <span class="comment">// Set a hash of model attributes on the object, firing `"change"` unless</span>
    <span class="comment">// you choose to silence it.</span>
    set: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">var</span> attr, attrs;
      <span class="keyword">if</span> (key == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">this</span>;

      <span class="comment">// Handle both `"key", value` and `{key: value}` -style arguments.</span>
      <span class="keyword">if</span> (_.isObject(key)) {
        attrs = key;
        options = val;
      } <span class="keyword">else</span> {
        (attrs = {})[key] = val;
      }

      <span class="comment">// Extract attributes and options.</span>
      <span class="keyword">var</span> silent = options &amp;&amp; options.silent;
      <span class="keyword">var</span> unset = options &amp;&amp; options.unset;

      <span class="comment">// Run validation.</span>
      <span class="keyword">if</span> (!<span class="keyword">this</span>._validate(attrs, options)) <span class="keyword">return</span> <span class="literal">false</span>;

      <span class="comment">// Check for changes of `id`.</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>.idAttribute <span class="keyword">in</span> attrs) <span class="keyword">this</span>.id = attrs[<span class="keyword">this</span>.idAttribute];

      <span class="keyword">var</span> now = <span class="keyword">this</span>.attributes;

      <span class="comment">// For each `set` attribute...</span>
      <span class="keyword">for</span> (attr <span class="keyword">in</span> attrs) {
        val = attrs[attr];

        <span class="comment">// Update or delete the current value, and track the change.</span>
        unset ? <span class="keyword">delete</span> now[attr] : now[attr] = val;
        <span class="keyword">this</span>._changes.push(attr, val);
      }

      <span class="comment">// Signal that the model's state has potentially changed, and we need</span>
      <span class="comment">// to recompute the actual changes.</span>
      <span class="keyword">this</span>._hasComputed = <span class="literal">false</span>;

      <span class="comment">// Fire the `"change"` events.</span>
      <span class="keyword">if</span> (!silent) <span class="keyword">this</span>.change(options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Remove an attribute from the model, firing `"change"` unless you choose</span>
    <span class="comment">// to silence it. `unset` is a noop if the attribute doesn't exist.</span>
    unset: <span class="keyword">function</span>(attr, options) {
      <span class="keyword">return</span> <span class="keyword">this</span>.set(attr, <span class="keyword">void</span> <span class="number">0</span>, _.extend({}, options, {unset: <span class="literal">true</span>}));
    },

    <span class="comment">// Clear all attributes on the model, firing `"change"` unless you choose</span>
    <span class="comment">// to silence it.</span>
    clear: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> attrs = {};
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> <span class="keyword">this</span>.attributes) attrs[key] = <span class="keyword">void</span> <span class="number">0</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>.set(attrs, _.extend({}, options, {unset: <span class="literal">true</span>}));
    },

    <span class="comment">// Fetch the model from the server. If the server's representation of the</span>
    <span class="comment">// model differs from its current attributes, they will be overriden,</span>
    <span class="comment">// triggering a `"change"` event.</span>
    fetch: <span class="keyword">function</span>(options) {
      options = options ? _.clone(options) : {};
      <span class="keyword">if</span> (options.parse === <span class="keyword">void</span> <span class="number">0</span>) options.parse = <span class="literal">true</span>;
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">var</span> success = options.success;
      options.success = <span class="keyword">function</span>(resp, status, xhr) {
        <span class="keyword">if</span> (!model.set(model.parse(resp), options)) <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">if</span> (success) success(model, resp, options);
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(<span class="string">'read'</span>, <span class="keyword">this</span>, options);
    },

    <span class="comment">// Set a hash of model attributes, and sync the model to the server.</span>
    <span class="comment">// If the server returns an attributes hash that differs, the model's</span>
    <span class="comment">// state will be `set` again.</span>
    save: <span class="keyword">function</span>(key, val, options) {
      <span class="keyword">var</span> attrs, current, done;

      <span class="comment">// Handle both `"key", value` and `{key: value}` -style arguments.</span>
      <span class="keyword">if</span> (key == <span class="literal">null</span> || _.isObject(key)) {
        attrs = key;
        options = val;
      } <span class="keyword">else</span> <span class="keyword">if</span> (key != <span class="literal">null</span>) {
        (attrs = {})[key] = val;
      }
      options = options ? _.clone(options) : {};

      <span class="comment">// If we're "wait"-ing to set changed attributes, validate early.</span>
      <span class="keyword">if</span> (options.wait) {
        <span class="keyword">if</span> (attrs &amp;&amp; !<span class="keyword">this</span>._validate(attrs, options)) <span class="keyword">return</span> <span class="literal">false</span>;
        current = _.clone(<span class="keyword">this</span>.attributes);
      }

      <span class="comment">// Regular saves `set` attributes before persisting to the server.</span>
      <span class="keyword">var</span> silentOptions = _.extend({}, options, {silent: <span class="literal">true</span>});
      <span class="keyword">if</span> (attrs &amp;&amp; !<span class="keyword">this</span>.set(attrs, options.wait ? silentOptions : options)) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="comment">// Do not persist invalid models.</span>
      <span class="keyword">if</span> (!attrs &amp;&amp; !<span class="keyword">this</span>._validate(<span class="literal">null</span>, options)) <span class="keyword">return</span> <span class="literal">false</span>;

      <span class="comment">// After a successful server-side save, the client is (optionally)</span>
      <span class="comment">// updated with the server-side state.</span>
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">var</span> success = options.success;
      options.success = <span class="keyword">function</span>(resp, status, xhr) {
        done = <span class="literal">true</span>;
        <span class="keyword">var</span> serverAttrs = model.parse(resp);
        <span class="keyword">if</span> (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        <span class="keyword">if</span> (!model.set(serverAttrs, options)) <span class="keyword">return</span> <span class="literal">false</span>;
        <span class="keyword">if</span> (success) success(model, resp, options);
      };

      <span class="comment">// Finish configuring and sending the Ajax request.</span>
      <span class="keyword">var</span> method = <span class="keyword">this</span>.isNew() ? <span class="string">'create'</span> : (options.patch ? <span class="string">'patch'</span> : <span class="string">'update'</span>);
      <span class="keyword">if</span> (method == <span class="string">'patch'</span>) options.attrs = attrs;
      <span class="keyword">var</span> xhr = <span class="keyword">this</span>.sync(method, <span class="keyword">this</span>, options);

      <span class="comment">// When using `wait`, reset attributes to original values unless</span>
      <span class="comment">// `success` has been called already.</span>
      <span class="keyword">if</span> (!done &amp;&amp; options.wait) {
        <span class="keyword">this</span>.clear(silentOptions);
        <span class="keyword">this</span>.set(current, silentOptions);
      }

      <span class="keyword">return</span> xhr;
    },

    <span class="comment">// Destroy this model on the server if it was already persisted.</span>
    <span class="comment">// Optimistically removes the model from its collection, if it has one.</span>
    <span class="comment">// If `wait: true` is passed, waits for the server to respond before removal.</span>
    destroy: <span class="keyword">function</span>(options) {
      options = options ? _.clone(options) : {};
      <span class="keyword">var</span> model = <span class="keyword">this</span>;
      <span class="keyword">var</span> success = options.success;

      <span class="keyword">var</span> destroy = <span class="keyword">function</span>() {
        model.trigger(<span class="string">'destroy'</span>, model, model.collection, options);
      };

      options.success = <span class="keyword">function</span>(resp) {
        <span class="keyword">if</span> (options.wait || model.isNew()) destroy();
        <span class="keyword">if</span> (success) success(model, resp, options);
      };

      <span class="keyword">if</span> (<span class="keyword">this</span>.isNew()) {
        options.success();
        <span class="keyword">return</span> <span class="literal">false</span>;
      }

      <span class="keyword">var</span> xhr = <span class="keyword">this</span>.sync(<span class="string">'delete'</span>, <span class="keyword">this</span>, options);
      <span class="keyword">if</span> (!options.wait) destroy();
      <span class="keyword">return</span> xhr;
    },

    <span class="comment">// Default URL for the model's representation on the server -- if you're</span>
    <span class="comment">// using Backbone's restful methods, override this to change the endpoint</span>
    <span class="comment">// that will be called.</span>
    url: <span class="keyword">function</span>() {
      <span class="keyword">var</span> base = _.result(<span class="keyword">this</span>, <span class="string">'urlRoot'</span>) || _.result(<span class="keyword">this</span>.collection, <span class="string">'url'</span>) || urlError();
      <span class="keyword">if</span> (<span class="keyword">this</span>.isNew()) <span class="keyword">return</span> base;
      <span class="keyword">return</span> base + (base.charAt(base.length - <span class="number">1</span>) === <span class="string">'/'</span> ? <span class="string">''</span> : <span class="string">'/'</span>) + encodeURIComponent(<span class="keyword">this</span>.id);
    },

    <span class="comment">// **parse** converts a response into the hash of attributes to be `set` on</span>
    <span class="comment">// the model. The default implementation is just to pass the response along.</span>
    parse: <span class="keyword">function</span>(resp) {
      <span class="keyword">return</span> resp;
    },

    <span class="comment">// Create a new model with identical attributes to this one.</span>
    clone: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.attributes);
    },

    <span class="comment">// A model is new if it has never been saved to the server, and lacks an id.</span>
    isNew: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.id == <span class="literal">null</span>;
    },

    <span class="comment">// Call this method to manually fire a `"change"` event for this model and</span>
    <span class="comment">// a `"change:attribute"` event for each changed attribute.</span>
    <span class="comment">// Calling this will cause all objects observing the model to update.</span>
    change: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> changing = <span class="keyword">this</span>._changing;
      <span class="keyword">this</span>._changing = <span class="literal">true</span>;

      <span class="comment">// Generate the changes to be triggered on the model.</span>
      <span class="keyword">var</span> triggers = <span class="keyword">this</span>._computeChanges(<span class="literal">true</span>);

      <span class="keyword">this</span>._pending = !!triggers.length;

      <span class="keyword">for</span> (<span class="keyword">var</span> i = triggers.length - <span class="number">2</span>; i >= <span class="number">0</span>; i -= <span class="number">2</span>) {
        <span class="keyword">this</span>.trigger(<span class="string">'change:'</span> + triggers[i], <span class="keyword">this</span>, triggers[i + <span class="number">1</span>], options);
      }

      <span class="keyword">if</span> (changing) <span class="keyword">return</span> <span class="keyword">this</span>;

      <span class="comment">// Trigger a `change` while there have been changes.</span>
      <span class="keyword">while</span> (<span class="keyword">this</span>._pending) {
        <span class="keyword">this</span>._pending = <span class="literal">false</span>;
        <span class="keyword">this</span>.trigger(<span class="string">'change'</span>, <span class="keyword">this</span>, options);
        <span class="keyword">this</span>._previousAttributes = _.clone(<span class="keyword">this</span>.attributes);
      }

      <span class="keyword">this</span>._changing = <span class="literal">false</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Determine if the model has changed since the last `"change"` event.</span>
    <span class="comment">// If you specify an attribute name, determine if that attribute has changed.</span>
    hasChanged: <span class="keyword">function</span>(attr) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>._hasComputed) <span class="keyword">this</span>._computeChanges();
      <span class="keyword">if</span> (attr == <span class="literal">null</span>) <span class="keyword">return</span> !_.isEmpty(<span class="keyword">this</span>.changed);
      <span class="keyword">return</span> _.has(<span class="keyword">this</span>.changed, attr);
    },

    <span class="comment">// Return an object containing all the attributes that have changed, or</span>
    <span class="comment">// false if there are no changed attributes. Useful for determining what</span>
    <span class="comment">// parts of a view need to be updated and/or what attributes need to be</span>
    <span class="comment">// persisted to the server. Unset attributes will be set to undefined.</span>
    <span class="comment">// You can also pass an attributes object to diff against the model,</span>
    <span class="comment">// determining if there *would be* a change.</span>
    changedAttributes: <span class="keyword">function</span>(diff) {
      <span class="keyword">if</span> (!diff) <span class="keyword">return</span> <span class="keyword">this</span>.hasChanged() ? _.clone(<span class="keyword">this</span>.changed) : <span class="literal">false</span>;
      <span class="keyword">var</span> val, changed = <span class="literal">false</span>, old = <span class="keyword">this</span>._previousAttributes;
      <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> diff) {
        <span class="keyword">if</span> (_.isEqual(old[attr], (val = diff[attr]))) <span class="keyword">continue</span>;
        (changed || (changed = {}))[attr] = val;
      }
      <span class="keyword">return</span> changed;
    },

    <span class="comment">// Looking at the built up list of `set` attribute changes, compute how</span>
    <span class="comment">// many of the attributes have actually changed. If `loud`, return a</span>
    <span class="comment">// boiled-down list of only the real changes.</span>
    _computeChanges: <span class="keyword">function</span>(loud) {
      <span class="keyword">this</span>.changed = {};
      <span class="keyword">var</span> already = {};
      <span class="keyword">var</span> triggers = [];
      <span class="keyword">var</span> current = <span class="keyword">this</span>._currentAttributes;
      <span class="keyword">var</span> changes = <span class="keyword">this</span>._changes;

      <span class="comment">// Loop through the current queue of potential model changes.</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> i = changes.length - <span class="number">2</span>; i >= <span class="number">0</span>; i -= <span class="number">2</span>) {
        <span class="keyword">var</span> key = changes[i], val = changes[i + <span class="number">1</span>];
        <span class="keyword">if</span> (already[key]) <span class="keyword">continue</span>;
        already[key] = <span class="literal">true</span>;

        <span class="comment">// Check if the attribute has been modified since the last change,</span>
        <span class="comment">// and update `this.changed` accordingly. If we're inside of a `change`</span>
        <span class="comment">// call, also add a trigger to the list.</span>
        <span class="keyword">if</span> (current[key] !== val) {
          <span class="keyword">this</span>.changed[key] = val;
          <span class="keyword">if</span> (!loud) <span class="keyword">continue</span>;
          triggers.push(key, val);
          current[key] = val;
        }
      }
      <span class="keyword">if</span> (loud) <span class="keyword">this</span>._changes = [];

      <span class="comment">// Signals `this.changed` is current to prevent duplicate calls from `this.hasChanged`.</span>
      <span class="keyword">this</span>._hasComputed = <span class="literal">true</span>;
      <span class="keyword">return</span> triggers;
    },

    <span class="comment">// Get the previous value of an attribute, recorded at the time the last</span>
    <span class="comment">// `"change"` event was fired.</span>
    previous: <span class="keyword">function</span>(attr) {
      <span class="keyword">if</span> (attr == <span class="literal">null</span> || !<span class="keyword">this</span>._previousAttributes) <span class="keyword">return</span> <span class="literal">null</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>._previousAttributes[attr];
    },

    <span class="comment">// Get all of the attributes of the model at the time of the previous</span>
    <span class="comment">// `"change"` event.</span>
    previousAttributes: <span class="keyword">function</span>() {
      <span class="keyword">return</span> _.clone(<span class="keyword">this</span>._previousAttributes);
    },

    <span class="comment">// Run validation against the next complete set of model attributes,</span>
    <span class="comment">// returning `true` if all is well. If a specific `error` callback has</span>
    <span class="comment">// been passed, call that instead of firing the general `"error"` event.</span>
    _validate: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.validate) <span class="keyword">return</span> <span class="literal">true</span>;
      attrs = _.extend({}, <span class="keyword">this</span>.attributes, attrs);
      <span class="keyword">var</span> error = <span class="keyword">this</span>.validate(attrs, options);
      <span class="keyword">if</span> (!error) <span class="keyword">return</span> <span class="literal">true</span>;
      <span class="keyword">if</span> (options &amp;&amp; options.error) options.error(<span class="keyword">this</span>, error, options);
      <span class="keyword">this</span>.trigger(<span class="string">'error'</span>, <span class="keyword">this</span>, error, options);
      <span class="keyword">return</span> <span class="literal">false</span>;
    }

  });

  <span class="comment">// Backbone.Collection</span>
  <span class="comment">// -------------------</span>

  <span class="comment">// Provides a standard collection class for our sets of models, ordered</span>
  <span class="comment">// or unordered. If a `comparator` is specified, the Collection will maintain</span>
  <span class="comment">// its models in sort order, as they're added and removed.</span>
  <span class="keyword">var</span> Collection = Backbone.Collection = <span class="keyword">function</span>(models, options) {
    options || (options = {});
    <span class="keyword">if</span> (options.model) <span class="keyword">this</span>.model = options.model;
    <span class="keyword">if</span> (options.comparator !== <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">this</span>.comparator = options.comparator;
    <span class="keyword">this</span>._reset();
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">if</span> (models) <span class="keyword">this</span>.reset(models, _.extend({silent: <span class="literal">true</span>}, options));
  };

  <span class="comment">// Define the Collection's inheritable methods.</span>
  _.extend(Collection.prototype, Events, {

    <span class="comment">// The default model for a collection is just a **Backbone.Model**.</span>
    <span class="comment">// This should be overridden in most cases.</span>
    model: Model,

    <span class="comment">// Initialize is an empty function by default. Override it with your own</span>
    <span class="comment">// initialization logic.</span>
    initialize: <span class="keyword">function</span>(){},

    <span class="comment">// The JSON representation of a Collection is an array of the</span>
    <span class="comment">// models' attributes.</span>
    toJSON: <span class="keyword">function</span>(options) {
      <span class="keyword">return</span> <span class="keyword">this</span>.map(<span class="keyword">function</span>(model){ <span class="keyword">return</span> model.toJSON(options); });
    },

    <span class="comment">// Proxy `Backbone.sync` by default.</span>
    sync: <span class="keyword">function</span>() {
      <span class="keyword">return</span> Backbone.sync.apply(<span class="keyword">this</span>, arguments);
    },

    <span class="comment">// Add a model, or list of models to the set. Pass **silent** to avoid</span>
    <span class="comment">// firing the `add` event for every new model.</span>
    add: <span class="keyword">function</span>(models, options) {
      <span class="keyword">var</span> i, args, length, model, existing, needsSort;
      <span class="keyword">var</span> at = options &amp;&amp; options.at;
      <span class="keyword">var</span> sort = ((options &amp;&amp; options.sort) == <span class="literal">null</span> ? <span class="literal">true</span> : options.sort);
      models = _.isArray(models) ? models.slice() : [models];

      <span class="comment">// Turn bare objects into model references, and prevent invalid models</span>
      <span class="comment">// from being added.</span>
      <span class="keyword">for</span> (i = models.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
        <span class="keyword">if</span>(!(model = <span class="keyword">this</span>._prepareModel(models[i], options))) {
          <span class="keyword">this</span>.trigger(<span class="string">"error"</span>, <span class="keyword">this</span>, models[i], options);
          models.splice(i, <span class="number">1</span>);
          <span class="keyword">continue</span>;
        }
        models[i] = model;

        existing = model.id != <span class="literal">null</span> &amp;&amp; <span class="keyword">this</span>._byId[model.id];
        <span class="comment">// If a duplicate is found, prevent it from being added and</span>
        <span class="comment">// optionally merge it into the existing model.</span>
        <span class="keyword">if</span> (existing || <span class="keyword">this</span>._byCid[model.cid]) {
          <span class="keyword">if</span> (options &amp;&amp; options.merge &amp;&amp; existing) {
            existing.set(model.attributes, options);
            needsSort = sort;
          }
          models.splice(i, <span class="number">1</span>);
          <span class="keyword">continue</span>;
        }

        <span class="comment">// Listen to added models' events, and index models for lookup by</span>
        <span class="comment">// `id` and by `cid`.</span>
        model.on(<span class="string">'all'</span>, <span class="keyword">this</span>._onModelEvent, <span class="keyword">this</span>);
        <span class="keyword">this</span>._byCid[model.cid] = model;
        <span class="keyword">if</span> (model.id != <span class="literal">null</span>) <span class="keyword">this</span>._byId[model.id] = model;
      }

      <span class="comment">// See if sorting is needed, update `length` and splice in new models.</span>
      <span class="keyword">if</span> (models.length) needsSort = sort;
      <span class="keyword">this</span>.length += models.length;
      args = [at != <span class="literal">null</span> ? at : <span class="keyword">this</span>.models.length, <span class="number">0</span>];
      push.apply(args, models);
      splice.apply(<span class="keyword">this</span>.models, args);

      <span class="comment">// Sort the collection if appropriate.</span>
      <span class="keyword">if</span> (needsSort &amp;&amp; <span class="keyword">this</span>.comparator &amp;&amp; at == <span class="literal">null</span>) <span class="keyword">this</span>.sort({silent: <span class="literal">true</span>});

      <span class="keyword">if</span> (options &amp;&amp; options.silent) <span class="keyword">return</span> <span class="keyword">this</span>;

      <span class="comment">// Trigger `add` events.</span>
      <span class="keyword">while</span> (model = models.shift()) {
        model.trigger(<span class="string">'add'</span>, model, <span class="keyword">this</span>, options);
      }

      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Remove a model, or a list of models from the set. Pass silent to avoid</span>
    <span class="comment">// firing the `remove` event for every model removed.</span>
    remove: <span class="keyword">function</span>(models, options) {
      <span class="keyword">var</span> i, l, index, model;
      options || (options = {});
      models = _.isArray(models) ? models.slice() : [models];
      <span class="keyword">for</span> (i = <span class="number">0</span>, l = models.length; i &lt; l; i++) {
        model = <span class="keyword">this</span>.get(models[i]);
        <span class="keyword">if</span> (!model) <span class="keyword">continue</span>;
        <span class="keyword">delete</span> <span class="keyword">this</span>._byId[model.id];
        <span class="keyword">delete</span> <span class="keyword">this</span>._byCid[model.cid];
        index = <span class="keyword">this</span>.indexOf(model);
        <span class="keyword">this</span>.models.splice(index, <span class="number">1</span>);
        <span class="keyword">this</span>.length--;
        <span class="keyword">if</span> (!options.silent) {
          options.index = index;
          model.trigger(<span class="string">'remove'</span>, model, <span class="keyword">this</span>, options);
        }
        <span class="keyword">this</span>._removeReference(model);
      }
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Add a model to the end of the collection.</span>
    push: <span class="keyword">function</span>(model, options) {
      model = <span class="keyword">this</span>._prepareModel(model, options);
      <span class="keyword">this</span>.add(model, _.extend({at: <span class="keyword">this</span>.length}, options));
      <span class="keyword">return</span> model;
    },

    <span class="comment">// Remove a model from the end of the collection.</span>
    pop: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> model = <span class="keyword">this</span>.at(<span class="keyword">this</span>.length - <span class="number">1</span>);
      <span class="keyword">this</span>.remove(model, options);
      <span class="keyword">return</span> model;
    },

    <span class="comment">// Add a model to the beginning of the collection.</span>
    unshift: <span class="keyword">function</span>(model, options) {
      model = <span class="keyword">this</span>._prepareModel(model, options);
      <span class="keyword">this</span>.add(model, _.extend({at: <span class="number">0</span>}, options));
      <span class="keyword">return</span> model;
    },

    <span class="comment">// Remove a model from the beginning of the collection.</span>
    shift: <span class="keyword">function</span>(options) {
      <span class="keyword">var</span> model = <span class="keyword">this</span>.at(<span class="number">0</span>);
      <span class="keyword">this</span>.remove(model, options);
      <span class="keyword">return</span> model;
    },

    <span class="comment">// Slice out a sub-array of models from the collection.</span>
    slice: <span class="keyword">function</span>(begin, end) {
      <span class="keyword">return</span> <span class="keyword">this</span>.models.slice(begin, end);
    },

    <span class="comment">// Get a model from the set by id.</span>
    get: <span class="keyword">function</span>(obj) {
      <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>._byId[obj.id != <span class="literal">null</span> ? obj.id : obj] || <span class="keyword">this</span>._byCid[obj.cid || obj];
    },

    <span class="comment">// Get the model at the given index.</span>
    at: <span class="keyword">function</span>(index) {
      <span class="keyword">return</span> <span class="keyword">this</span>.models[index];
    },

    <span class="comment">// Return models with matching attributes. Useful for simple cases of `filter`.</span>
    where: <span class="keyword">function</span>(attrs) {
      <span class="keyword">if</span> (_.isEmpty(attrs)) <span class="keyword">return</span> [];
      <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="keyword">function</span>(model) {
        <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> attrs) {
          <span class="keyword">if</span> (attrs[key] !== model.get(key)) <span class="keyword">return</span> <span class="literal">false</span>;
        }
        <span class="keyword">return</span> <span class="literal">true</span>;
      });
    },

    <span class="comment">// Force the collection to re-sort itself. You don't need to call this under</span>
    <span class="comment">// normal circumstances, as the set will maintain sort order as each item</span>
    <span class="comment">// is added.</span>
    sort: <span class="keyword">function</span>(options) {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.comparator) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Cannot sort a set without a comparator'</span>);
      }

      <span class="keyword">if</span> (_.isString(<span class="keyword">this</span>.comparator) || <span class="keyword">this</span>.comparator.length === <span class="number">1</span>) {
        <span class="keyword">this</span>.models = <span class="keyword">this</span>.sortBy(<span class="keyword">this</span>.comparator, <span class="keyword">this</span>);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.models.sort(_.bind(<span class="keyword">this</span>.comparator, <span class="keyword">this</span>));
      }

      <span class="keyword">if</span> (!options || !options.silent) <span class="keyword">this</span>.trigger(<span class="string">'sort'</span>, <span class="keyword">this</span>, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Pluck an attribute from each model in the collection.</span>
    pluck: <span class="keyword">function</span>(attr) {
      <span class="keyword">return</span> _.invoke(<span class="keyword">this</span>.models, <span class="string">'get'</span>, attr);
    },

    <span class="comment">// Smartly update a collection with a change set of models, adding,</span>
    <span class="comment">// removing, and merging as necessary.</span>
    update: <span class="keyword">function</span>(models, options) {
      <span class="keyword">var</span> model, i, l, existing;
      <span class="keyword">var</span> add = [], remove = [], modelMap = {};
      <span class="keyword">var</span> idAttr = <span class="keyword">this</span>.model.prototype.idAttribute;
      options = _.extend({add: <span class="literal">true</span>, merge: <span class="literal">true</span>, remove: <span class="literal">true</span>}, options);
      <span class="keyword">if</span> (options.parse) models = <span class="keyword">this</span>.parse(models);

      <span class="comment">// Allow a single model (or no argument) to be passed.</span>
      <span class="keyword">if</span> (!_.isArray(models)) models = models ? [models] : [];

      <span class="comment">// Proxy to `add` for this case, no need to iterate...</span>
      <span class="keyword">if</span> (options.add &amp;&amp; !options.remove) <span class="keyword">return</span> <span class="keyword">this</span>.add(models, options);

      <span class="comment">// Determine which models to add and merge, and which to remove.</span>
      <span class="keyword">for</span> (i = <span class="number">0</span>, l = models.length; i &lt; l; i++) {
        model = models[i];
        existing = <span class="keyword">this</span>.get(model.id || model.cid || model[idAttr]);
        <span class="keyword">if</span> (options.remove &amp;&amp; existing) modelMap[existing.cid] = <span class="literal">true</span>;
        <span class="keyword">if</span> ((options.add &amp;&amp; !existing) || (options.merge &amp;&amp; existing)) {
          add.push(model);
        }
      }
      <span class="keyword">if</span> (options.remove) {
        <span class="keyword">for</span> (i = <span class="number">0</span>, l = <span class="keyword">this</span>.models.length; i &lt; l; i++) {
          model = <span class="keyword">this</span>.models[i];
          <span class="keyword">if</span> (!modelMap[model.cid]) remove.push(model);
        }
      }

      <span class="comment">// Remove models (if applicable) before we add and merge the rest.</span>
      <span class="keyword">if</span> (remove.length) <span class="keyword">this</span>.remove(remove, options);
      <span class="keyword">if</span> (add.length) <span class="keyword">this</span>.add(add, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// When you have more items than you want to add or remove individually,</span>
    <span class="comment">// you can reset the entire set with a new list of models, without firing</span>
    <span class="comment">// any `add` or `remove` events. Fires `reset` when finished.</span>
    reset: <span class="keyword">function</span>(models, options) {
      options || (options = {});
      <span class="keyword">if</span> (options.parse) models = <span class="keyword">this</span>.parse(models);
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = <span class="keyword">this</span>.models.length; i &lt; l; i++) {
        <span class="keyword">this</span>._removeReference(<span class="keyword">this</span>.models[i]);
      }
      options.previousModels = <span class="keyword">this</span>.models;
      <span class="keyword">this</span>._reset();
      <span class="keyword">if</span> (models) <span class="keyword">this</span>.add(models, _.extend({silent: <span class="literal">true</span>}, options));
      <span class="keyword">if</span> (!options.silent) <span class="keyword">this</span>.trigger(<span class="string">'reset'</span>, <span class="keyword">this</span>, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Fetch the default set of models for this collection, resetting the</span>
    <span class="comment">// collection when they arrive. If `add: true` is passed, appends the</span>
    <span class="comment">// models to the collection instead of resetting.</span>
    fetch: <span class="keyword">function</span>(options) {
      options = options ? _.clone(options) : {};
      <span class="keyword">if</span> (options.parse === <span class="keyword">void</span> <span class="number">0</span>) options.parse = <span class="literal">true</span>;
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      <span class="keyword">var</span> success = options.success;
      options.success = <span class="keyword">function</span>(resp, status, xhr) {
        <span class="keyword">var</span> method = options.update ? <span class="string">'update'</span> : <span class="string">'reset'</span>;
        collection[method](resp, options);
        <span class="keyword">if</span> (success) success(collection, resp, options);
      };
      <span class="keyword">return</span> <span class="keyword">this</span>.sync(<span class="string">'read'</span>, <span class="keyword">this</span>, options);
    },

    <span class="comment">// Create a new instance of a model in this collection. Add the model to the</span>
    <span class="comment">// collection immediately, unless `wait: true` is passed, in which case we</span>
    <span class="comment">// wait for the server to agree.</span>
    create: <span class="keyword">function</span>(model, options) {
      <span class="keyword">var</span> collection = <span class="keyword">this</span>;
      options = options ? _.clone(options) : {};
      model = <span class="keyword">this</span>._prepareModel(model, options);
      <span class="keyword">if</span> (!model) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">if</span> (!options.wait) collection.add(model, options);
      <span class="keyword">var</span> success = options.success;
      options.success = <span class="keyword">function</span>(model, resp, options) {
        <span class="keyword">if</span> (options.wait) collection.add(model, options);
        <span class="keyword">if</span> (success) success(model, resp, options);
      };
      model.save(<span class="literal">null</span>, options);
      <span class="keyword">return</span> model;
    },

    <span class="comment">// **parse** converts a response into a list of models to be added to the</span>
    <span class="comment">// collection. The default implementation is just to pass it through.</span>
    parse: <span class="keyword">function</span>(resp) {
      <span class="keyword">return</span> resp;
    },

    <span class="comment">// Create a new collection with an identical list of models as this one.</span>
    clone: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>.constructor(<span class="keyword">this</span>.models);
    },

    <span class="comment">// Proxy to _'s chain. Can't be proxied the same way the rest of the</span>
    <span class="comment">// underscore methods are proxied because it relies on the underscore</span>
    <span class="comment">// constructor.</span>
    chain: <span class="keyword">function</span>() {
      <span class="keyword">return</span> _(<span class="keyword">this</span>.models).chain();
    },

    <span class="comment">// Reset all internal state. Called when the collection is reset.</span>
    _reset: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.length = <span class="number">0</span>;
      <span class="keyword">this</span>.models = [];
      <span class="keyword">this</span>._byId  = {};
      <span class="keyword">this</span>._byCid = {};
    },

    <span class="comment">// Prepare a model or hash of attributes to be added to this collection.</span>
    _prepareModel: <span class="keyword">function</span>(attrs, options) {
      <span class="keyword">if</span> (attrs <span class="keyword">instanceof</span> Model) {
        <span class="keyword">if</span> (!attrs.collection) attrs.collection = <span class="keyword">this</span>;
        <span class="keyword">return</span> attrs;
      }
      options || (options = {});
      options.collection = <span class="keyword">this</span>;
      <span class="keyword">var</span> model = <span class="keyword">new</span> <span class="keyword">this</span>.model(attrs, options);
      <span class="keyword">if</span> (!model._validate(attrs, options)) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">return</span> model;
    },

    <span class="comment">// Internal method to remove a model's ties to a collection.</span>
    _removeReference: <span class="keyword">function</span>(model) {
      <span class="keyword">if</span> (<span class="keyword">this</span> === model.collection) <span class="keyword">delete</span> model.collection;
      model.off(<span class="string">'all'</span>, <span class="keyword">this</span>._onModelEvent, <span class="keyword">this</span>);
    },

    <span class="comment">// Internal method called every time a model in the set fires an event.</span>
    <span class="comment">// Sets need to update their indexes when models change ids. All other</span>
    <span class="comment">// events simply proxy through. "add" and "remove" events that originate</span>
    <span class="comment">// in other collections are ignored.</span>
    _onModelEvent: <span class="keyword">function</span>(event, model, collection, options) {
      <span class="keyword">if</span> ((event === <span class="string">'add'</span> || event === <span class="string">'remove'</span>) &amp;&amp; collection !== <span class="keyword">this</span>) <span class="keyword">return</span>;
      <span class="keyword">if</span> (event === <span class="string">'destroy'</span>) <span class="keyword">this</span>.remove(model, options);
      <span class="keyword">if</span> (model &amp;&amp; event === <span class="string">'change:'</span> + model.idAttribute) {
        <span class="keyword">delete</span> <span class="keyword">this</span>._byId[model.previous(model.idAttribute)];
        <span class="keyword">if</span> (model.id != <span class="literal">null</span>) <span class="keyword">this</span>._byId[model.id] = model;
      }
      <span class="keyword">this</span>.trigger.apply(<span class="keyword">this</span>, arguments);
    }

  });

  <span class="comment">// Underscore methods that we want to implement on the Collection.</span>
  <span class="keyword">var</span> methods = [<span class="string">'forEach'</span>, <span class="string">'each'</span>, <span class="string">'map'</span>, <span class="string">'collect'</span>, <span class="string">'reduce'</span>, <span class="string">'foldl'</span>,
    <span class="string">'inject'</span>, <span class="string">'reduceRight'</span>, <span class="string">'foldr'</span>, <span class="string">'find'</span>, <span class="string">'detect'</span>, <span class="string">'filter'</span>, <span class="string">'select'</span>,
    <span class="string">'reject'</span>, <span class="string">'every'</span>, <span class="string">'all'</span>, <span class="string">'some'</span>, <span class="string">'any'</span>, <span class="string">'include'</span>, <span class="string">'contains'</span>, <span class="string">'invoke'</span>,
    <span class="string">'max'</span>, <span class="string">'min'</span>, <span class="string">'sortedIndex'</span>, <span class="string">'toArray'</span>, <span class="string">'size'</span>, <span class="string">'first'</span>, <span class="string">'head'</span>, <span class="string">'take'</span>,
    <span class="string">'initial'</span>, <span class="string">'rest'</span>, <span class="string">'tail'</span>, <span class="string">'last'</span>, <span class="string">'without'</span>, <span class="string">'indexOf'</span>, <span class="string">'shuffle'</span>,
    <span class="string">'lastIndexOf'</span>, <span class="string">'isEmpty'</span>];

  <span class="comment">// Mix in each Underscore method as a proxy to `Collection#models`.</span>
  _.each(methods, <span class="keyword">function</span>(method) {
    Collection.prototype[method] = <span class="keyword">function</span>() {
      <span class="keyword">var</span> args = slice.call(arguments);
      args.unshift(<span class="keyword">this</span>.models);
      <span class="keyword">return</span> _[method].apply(_, args);
    };
  });

  <span class="comment">// Underscore methods that take a property name as an argument.</span>
  <span class="keyword">var</span> attributeMethods = [<span class="string">'groupBy'</span>, <span class="string">'countBy'</span>, <span class="string">'sortBy'</span>];

  <span class="comment">// Use attributes instead of properties.</span>
  _.each(attributeMethods, <span class="keyword">function</span>(method) {
    Collection.prototype[method] = <span class="keyword">function</span>(value, context) {
      <span class="keyword">var</span> iterator = _.isFunction(value) ? value : <span class="keyword">function</span>(model) {
        <span class="keyword">return</span> model.get(value);
      };
      <span class="keyword">return</span> _[method](<span class="keyword">this</span>.models, iterator, context);
    };
  });

  <span class="comment">// Backbone.Router</span>
  <span class="comment">// ---------------</span>

  <span class="comment">// Routers map faux-URLs to actions, and fire events when routes are</span>
  <span class="comment">// matched. Creating a new one sets its `routes` hash, if not set statically.</span>
  <span class="keyword">var</span> Router = Backbone.Router = <span class="keyword">function</span>(options) {
    options || (options = {});
    <span class="keyword">if</span> (options.routes) <span class="keyword">this</span>.routes = options.routes;
    <span class="keyword">this</span>._bindRoutes();
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
  };

  <span class="comment">// Cached regular expressions for matching named param parts and splatted</span>
  <span class="comment">// parts of route strings.</span>
  <span class="keyword">var</span> optionalParam = <span class="regexp">/\((.*?)\)/g</span>;
  <span class="keyword">var</span> namedParam    = <span class="regexp">/:\w+/g</span>;
  <span class="keyword">var</span> splatParam    = <span class="regexp">/\*\w+/g</span>;
  <span class="keyword">var</span> escapeRegExp  = <span class="regexp">/[\-{}\[\]+?.,\\\^$|#\s]/g</span>;

  <span class="comment">// Set up all inheritable **Backbone.Router** properties and methods.</span>
  _.extend(Router.prototype, Events, {

    <span class="comment">// Initialize is an empty function by default. Override it with your own</span>
    <span class="comment">// initialization logic.</span>
    initialize: <span class="keyword">function</span>(){},

    <span class="comment">// Manually bind a single named route to a callback. For example:</span>
    <span class="comment">//</span>
    <span class="comment">//     this.route('search/:query/p:num', 'search', function(query, num) {</span>
    <span class="comment">//       ...</span>
    <span class="comment">//     });</span>
    <span class="comment">//</span>
    route: <span class="keyword">function</span>(route, name, callback) {
      <span class="keyword">if</span> (!_.isRegExp(route)) route = <span class="keyword">this</span>._routeToRegExp(route);
      <span class="keyword">if</span> (!callback) callback = <span class="keyword">this</span>[name];
      Backbone.history.route(route, _.bind(<span class="keyword">function</span>(fragment) {
        <span class="keyword">var</span> args = <span class="keyword">this</span>._extractParameters(route, fragment);
        callback &amp;&amp; callback.apply(<span class="keyword">this</span>, args);
        <span class="keyword">this</span>.trigger.apply(<span class="keyword">this</span>, [<span class="string">'route:'</span> + name].concat(args));
        Backbone.history.trigger(<span class="string">'route'</span>, <span class="keyword">this</span>, name, args);
      }, <span class="keyword">this</span>));
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Simple proxy to `Backbone.history` to save a fragment into the history.</span>
    navigate: <span class="keyword">function</span>(fragment, options) {
      Backbone.history.navigate(fragment, options);
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Bind all defined routes to `Backbone.history`. We have to reverse the</span>
    <span class="comment">// order of the routes here to support behavior where the most general</span>
    <span class="comment">// routes can be defined at the bottom of the route map.</span>
    _bindRoutes: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.routes) <span class="keyword">return</span>;
      <span class="keyword">var</span> route, routes = _.keys(<span class="keyword">this</span>.routes);
      <span class="keyword">while</span> ((route = routes.pop()) != <span class="literal">null</span>) {
        <span class="keyword">this</span>.route(route, <span class="keyword">this</span>.routes[route]);
      }
    },

    <span class="comment">// Convert a route string into a regular expression, suitable for matching</span>
    <span class="comment">// against the current location hash.</span>
    _routeToRegExp: <span class="keyword">function</span>(route) {
      route = route.replace(escapeRegExp, <span class="string">'\\$&amp;'</span>)
                   .replace(optionalParam, <span class="string">'(?:$1)?'</span>)
                   .replace(namedParam, <span class="string">'([^\/]+)'</span>)
                   .replace(splatParam, <span class="string">'(.*?)'</span>);
      <span class="keyword">return</span> <span class="keyword">new</span> RegExp(<span class="string">'^'</span> + route + <span class="string">'$'</span>);
    },

    <span class="comment">// Given a route, and a URL fragment that it matches, return the array of</span>
    <span class="comment">// extracted parameters.</span>
    _extractParameters: <span class="keyword">function</span>(route, fragment) {
      <span class="keyword">return</span> route.exec(fragment).slice(<span class="number">1</span>);
    }

  });

  <span class="comment">// Backbone.History</span>
  <span class="comment">// ----------------</span>

  <span class="comment">// Handles cross-browser history management, based on URL fragments. If the</span>
  <span class="comment">// browser does not support `onhashchange`, falls back to polling.</span>
  <span class="keyword">var</span> History = Backbone.History = <span class="keyword">function</span>() {
    <span class="keyword">this</span>.handlers = [];
    _.bindAll(<span class="keyword">this</span>, <span class="string">'checkUrl'</span>);

    <span class="comment">// #1653 - Ensure that `History` can be used outside of the browser.</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> window !== <span class="string">'undefined'</span>) {
      <span class="keyword">this</span>.location = window.location;
      <span class="keyword">this</span>.history = window.history;
    }
  };

  <span class="comment">// Cached regex for stripping a leading hash/slash and trailing space.</span>
  <span class="keyword">var</span> routeStripper = <span class="regexp">/^[#\/]|\s+$/g</span>;

  <span class="comment">// Cached regex for stripping leading and trailing slashes.</span>
  <span class="keyword">var</span> rootStripper = <span class="regexp">/^\/+|\/+$/g</span>;

  <span class="comment">// Cached regex for detecting MSIE.</span>
  <span class="keyword">var</span> isExplorer = <span class="regexp">/msie [\w.]+/</span>;

  <span class="comment">// Cached regex for removing a trailing slash.</span>
  <span class="keyword">var</span> trailingSlash = <span class="regexp">/\/$/</span>;

  <span class="comment">// Has the history handling already been started?</span>
  History.started = <span class="literal">false</span>;

  <span class="comment">// Set up all inheritable **Backbone.History** properties and methods.</span>
  _.extend(History.prototype, Events, {

    <span class="comment">// The default interval to poll for hash changes, if necessary, is</span>
    <span class="comment">// twenty times a second.</span>
    interval: <span class="number">50</span>,

    <span class="comment">// Gets the true hash value. Cannot use location.hash directly due to bug</span>
    <span class="comment">// in Firefox where location.hash will always be decoded.</span>
    getHash: <span class="keyword">function</span>(window) {
      <span class="keyword">var</span> match = (window || <span class="keyword">this</span>).location.href.match(<span class="regexp">/#(.*)$/</span>);
      <span class="keyword">return</span> match ? match[<span class="number">1</span>] : <span class="string">''</span>;
    },

    <span class="comment">// Get the cross-browser normalized URL fragment, either from the URL,</span>
    <span class="comment">// the hash, or the override.</span>
    getFragment: <span class="keyword">function</span>(fragment, forcePushState) {
      <span class="keyword">if</span> (fragment == <span class="literal">null</span>) {
        <span class="keyword">if</span> (<span class="keyword">this</span>._hasPushState || !<span class="keyword">this</span>._wantsHashChange || forcePushState) {
          fragment = <span class="keyword">this</span>.location.pathname;
          <span class="keyword">var</span> root = <span class="keyword">this</span>.root.replace(trailingSlash, <span class="string">''</span>);
          <span class="keyword">if</span> (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } <span class="keyword">else</span> {
          fragment = <span class="keyword">this</span>.getHash();
        }
      }
      <span class="keyword">return</span> fragment.replace(routeStripper, <span class="string">''</span>);
    },

    <span class="comment">// Start the hash change handling, returning `true` if the current URL matches</span>
    <span class="comment">// an existing route, and `false` otherwise.</span>
    start: <span class="keyword">function</span>(options) {
      <span class="keyword">if</span> (History.started) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Backbone.history has already been started"</span>);
      History.started = <span class="literal">true</span>;

      <span class="comment">// Figure out the initial configuration. Do we need an iframe?</span>
      <span class="comment">// Is pushState desired ... is it available?</span>
      <span class="keyword">this</span>.options          = _.extend({}, {root: <span class="string">'/'</span>}, <span class="keyword">this</span>.options, options);
      <span class="keyword">this</span>.root             = <span class="keyword">this</span>.options.root;
      <span class="keyword">this</span>._wantsHashChange = <span class="keyword">this</span>.options.hashChange !== <span class="literal">false</span>;
      <span class="keyword">this</span>._wantsPushState  = !!<span class="keyword">this</span>.options.pushState;
      <span class="keyword">this</span>._hasPushState    = !!(<span class="keyword">this</span>.options.pushState &amp;&amp; <span class="keyword">this</span>.history &amp;&amp; <span class="keyword">this</span>.history.pushState);
      <span class="keyword">var</span> fragment          = <span class="keyword">this</span>.getFragment();
      <span class="keyword">var</span> docMode           = document.documentMode;
      <span class="keyword">var</span> oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) &amp;&amp; (!docMode || docMode &lt;= <span class="number">7</span>));

      <span class="comment">// Normalize root to always include a leading and trailing slash.</span>
      <span class="keyword">this</span>.root = (<span class="string">'/'</span> + <span class="keyword">this</span>.root + <span class="string">'/'</span>).replace(rootStripper, <span class="string">'/'</span>);

      <span class="keyword">if</span> (oldIE &amp;&amp; <span class="keyword">this</span>._wantsHashChange) {
        <span class="keyword">this</span>.iframe = Backbone.$(<span class="string">'&lt;iframe src="javascript:0" tabindex="-1" />'</span>).hide().appendTo(<span class="string">'body'</span>)[<span class="number">0</span>].contentWindow;
        <span class="keyword">this</span>.navigate(fragment);
      }

      <span class="comment">// Depending on whether we're using pushState or hashes, and whether</span>
      <span class="comment">// 'onhashchange' is supported, determine how we check the URL state.</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>._hasPushState) {
        Backbone.$(window).bind(<span class="string">'popstate'</span>, <span class="keyword">this</span>.checkUrl);
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._wantsHashChange &amp;&amp; (<span class="string">'onhashchange'</span> <span class="keyword">in</span> window) &amp;&amp; !oldIE) {
        Backbone.$(window).bind(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.checkUrl);
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._wantsHashChange) {
        <span class="keyword">this</span>._checkUrlInterval = setInterval(<span class="keyword">this</span>.checkUrl, <span class="keyword">this</span>.interval);
      }

      <span class="comment">// Determine if we need to change the base url, for a pushState link</span>
      <span class="comment">// opened by a non-pushState browser.</span>
      <span class="keyword">this</span>.fragment = fragment;
      <span class="keyword">var</span> loc = <span class="keyword">this</span>.location;
      <span class="keyword">var</span> atRoot = loc.pathname.replace(<span class="regexp">/[^\/]$/</span>, <span class="string">'$&amp;/'</span>) === <span class="keyword">this</span>.root;

      <span class="comment">// If we've started off with a route from a `pushState`-enabled browser,</span>
      <span class="comment">// but we're currently in a browser that doesn't support it...</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>._wantsHashChange &amp;&amp; <span class="keyword">this</span>._wantsPushState &amp;&amp; !<span class="keyword">this</span>._hasPushState &amp;&amp; !atRoot) {
        <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getFragment(<span class="literal">null</span>, <span class="literal">true</span>);
        <span class="keyword">this</span>.location.replace(<span class="keyword">this</span>.root + <span class="keyword">this</span>.location.search + <span class="string">'#'</span> + <span class="keyword">this</span>.fragment);
        <span class="comment">// Return immediately as browser will do redirect to new url</span>
        <span class="keyword">return</span> <span class="literal">true</span>;

      <span class="comment">// Or if we've started out with a hash-based route, but we're currently</span>
      <span class="comment">// in a browser where it could be `pushState`-based instead...</span>
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._wantsPushState &amp;&amp; <span class="keyword">this</span>._hasPushState &amp;&amp; atRoot &amp;&amp; loc.hash) {
        <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getHash().replace(routeStripper, <span class="string">''</span>);
        <span class="keyword">this</span>.history.replaceState({}, document.title, <span class="keyword">this</span>.root + <span class="keyword">this</span>.fragment + loc.search);
      }

      <span class="keyword">if</span> (!<span class="keyword">this</span>.options.silent) <span class="keyword">return</span> <span class="keyword">this</span>.loadUrl();
    },

    <span class="comment">// Disable Backbone.history, perhaps temporarily. Not useful in a real app,</span>
    <span class="comment">// but possibly useful for unit testing Routers.</span>
    stop: <span class="keyword">function</span>() {
      Backbone.$(window).unbind(<span class="string">'popstate'</span>, <span class="keyword">this</span>.checkUrl).unbind(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.checkUrl);
      clearInterval(<span class="keyword">this</span>._checkUrlInterval);
      History.started = <span class="literal">false</span>;
    },

    <span class="comment">// Add a route to be tested when the fragment changes. Routes added later</span>
    <span class="comment">// may override previous routes.</span>
    route: <span class="keyword">function</span>(route, callback) {
      <span class="keyword">this</span>.handlers.unshift({route: route, callback: callback});
    },

    <span class="comment">// Checks the current URL to see if it has changed, and if it has,</span>
    <span class="comment">// calls `loadUrl`, normalizing across the hidden iframe.</span>
    checkUrl: <span class="keyword">function</span>(e) {
      <span class="keyword">var</span> current = <span class="keyword">this</span>.getFragment();
      <span class="keyword">if</span> (current === <span class="keyword">this</span>.fragment &amp;&amp; <span class="keyword">this</span>.iframe) {
        current = <span class="keyword">this</span>.getFragment(<span class="keyword">this</span>.getHash(<span class="keyword">this</span>.iframe));
      }
      <span class="keyword">if</span> (current === <span class="keyword">this</span>.fragment) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">if</span> (<span class="keyword">this</span>.iframe) <span class="keyword">this</span>.navigate(current);
      <span class="keyword">this</span>.loadUrl() || <span class="keyword">this</span>.loadUrl(<span class="keyword">this</span>.getHash());
    },

    <span class="comment">// Attempt to load the current URL fragment. If a route succeeds with a</span>
    <span class="comment">// match, returns `true`. If no defined routes matches the fragment,</span>
    <span class="comment">// returns `false`.</span>
    loadUrl: <span class="keyword">function</span>(fragmentOverride) {
      <span class="keyword">var</span> fragment = <span class="keyword">this</span>.fragment = <span class="keyword">this</span>.getFragment(fragmentOverride);
      <span class="keyword">var</span> matched = _.any(<span class="keyword">this</span>.handlers, <span class="keyword">function</span>(handler) {
        <span class="keyword">if</span> (handler.route.test(fragment)) {
          handler.callback(fragment);
          <span class="keyword">return</span> <span class="literal">true</span>;
        }
      });
      <span class="keyword">return</span> matched;
    },

    <span class="comment">// Save a fragment into the hash history, or replace the URL state if the</span>
    <span class="comment">// 'replace' option is passed. You are responsible for properly URL-encoding</span>
    <span class="comment">// the fragment in advance.</span>
    <span class="comment">//</span>
    <span class="comment">// The options object can contain `trigger: true` if you wish to have the</span>
    <span class="comment">// route callback be fired (not usually desirable), or `replace: true`, if</span>
    <span class="comment">// you wish to modify the current URL without adding an entry to the history.</span>
    navigate: <span class="keyword">function</span>(fragment, options) {
      <span class="keyword">if</span> (!History.started) <span class="keyword">return</span> <span class="literal">false</span>;
      <span class="keyword">if</span> (!options || options === <span class="literal">true</span>) options = {trigger: options};
      fragment = <span class="keyword">this</span>.getFragment(fragment || <span class="string">''</span>);
      <span class="keyword">if</span> (<span class="keyword">this</span>.fragment === fragment) <span class="keyword">return</span>;
      <span class="keyword">this</span>.fragment = fragment;
      <span class="keyword">var</span> url = <span class="keyword">this</span>.root + fragment;

      <span class="comment">// If pushState is available, we use it to set the fragment as a real URL.</span>
      <span class="keyword">if</span> (<span class="keyword">this</span>._hasPushState) {
        <span class="keyword">this</span>.history[options.replace ? <span class="string">'replaceState'</span> : <span class="string">'pushState'</span>]({}, document.title, url);

      <span class="comment">// If hash changes haven't been explicitly disabled, update the hash</span>
      <span class="comment">// fragment to store history.</span>
      } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._wantsHashChange) {
        <span class="keyword">this</span>._updateHash(<span class="keyword">this</span>.location, fragment, options.replace);
        <span class="keyword">if</span> (<span class="keyword">this</span>.iframe &amp;&amp; (fragment !== <span class="keyword">this</span>.getFragment(<span class="keyword">this</span>.getHash(<span class="keyword">this</span>.iframe)))) {
          <span class="comment">// Opening and closing the iframe tricks IE7 and earlier to push a</span>
          <span class="comment">// history entry on hash-tag change.  When replace is true, we don't</span>
          <span class="comment">// want this.</span>
          <span class="keyword">if</span>(!options.replace) <span class="keyword">this</span>.iframe.document.open().close();
          <span class="keyword">this</span>._updateHash(<span class="keyword">this</span>.iframe.location, fragment, options.replace);
        }

      <span class="comment">// If you've told us that you explicitly don't want fallback hashchange-</span>
      <span class="comment">// based history, then `navigate` becomes a page refresh.</span>
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.location.assign(url);
      }
      <span class="keyword">if</span> (options.trigger) <span class="keyword">this</span>.loadUrl(fragment);
    },

    <span class="comment">// Update the hash location, either replacing the current entry, or adding</span>
    <span class="comment">// a new one to the browser history.</span>
    _updateHash: <span class="keyword">function</span>(location, fragment, replace) {
      <span class="keyword">if</span> (replace) {
        <span class="keyword">var</span> href = location.href.replace(<span class="regexp">/(javascript:|#).*$/</span>, <span class="string">''</span>);
        location.replace(href + <span class="string">'#'</span> + fragment);
      } <span class="keyword">else</span> {
        <span class="comment">// #1649 - Some browsers require that `hash` contains a leading #.</span>
        location.hash = <span class="string">'#'</span> + fragment;
      }
    }

  });

  <span class="comment">// Create the default Backbone.history.</span>
  Backbone.history = <span class="keyword">new</span> History;

  <span class="comment">// Backbone.View</span>
  <span class="comment">// -------------</span>

  <span class="comment">// Creating a Backbone.View creates its initial element outside of the DOM,</span>
  <span class="comment">// if an existing element is not provided...</span>
  <span class="keyword">var</span> View = Backbone.View = <span class="keyword">function</span>(options) {
    <span class="keyword">this</span>.cid = _.uniqueId(<span class="string">'view'</span>);
    <span class="keyword">this</span>._configure(options || {});
    <span class="keyword">this</span>._ensureElement();
    <span class="keyword">this</span>.initialize.apply(<span class="keyword">this</span>, arguments);
    <span class="keyword">this</span>.delegateEvents();
  };

  <span class="comment">// Cached regex to split keys for `delegate`.</span>
  <span class="keyword">var</span> delegateEventSplitter = <span class="regexp">/^(\S+)\s*(.*)$/</span>;

  <span class="comment">// List of view options to be merged as properties.</span>
  <span class="keyword">var</span> viewOptions = [<span class="string">'model'</span>, <span class="string">'collection'</span>, <span class="string">'el'</span>, <span class="string">'id'</span>, <span class="string">'attributes'</span>, <span class="string">'className'</span>, <span class="string">'tagName'</span>, <span class="string">'events'</span>];

  <span class="comment">// Set up all inheritable **Backbone.View** properties and methods.</span>
  _.extend(View.prototype, Events, {

    <span class="comment">// The default `tagName` of a View's element is `"div"`.</span>
    tagName: <span class="string">'div'</span>,

    <span class="comment">// jQuery delegate for element lookup, scoped to DOM elements within the</span>
    <span class="comment">// current view. This should be prefered to global lookups where possible.</span>
    $: <span class="keyword">function</span>(selector) {
      <span class="keyword">return</span> <span class="keyword">this</span>.$el.find(selector);
    },

    <span class="comment">// Initialize is an empty function by default. Override it with your own</span>
    <span class="comment">// initialization logic.</span>
    initialize: <span class="keyword">function</span>(){},

    <span class="comment">// **render** is the core function that your view should override, in order</span>
    <span class="comment">// to populate its element (`this.el`), with the appropriate HTML. The</span>
    <span class="comment">// convention is for **render** to always return `this`.</span>
    render: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Remove this view by taking the element out of the DOM, and removing any</span>
    <span class="comment">// applicable Backbone.Events listeners.</span>
    remove: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.$el.remove();
      <span class="keyword">this</span>.stopListening();
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// For small amounts of DOM Elements, where a full-blown template isn't</span>
    <span class="comment">// needed, use **make** to manufacture elements, one at a time.</span>
    <span class="comment">//</span>
    <span class="comment">//     var el = this.make('li', {'class': 'row'}, this.model.escape('title'));</span>
    <span class="comment">//</span>
    make: <span class="keyword">function</span>(tagName, attributes, content) {
      <span class="keyword">var</span> el = document.createElement(tagName);
      <span class="keyword">if</span> (attributes) Backbone.$(el).attr(attributes);
      <span class="keyword">if</span> (content != <span class="literal">null</span>) Backbone.$(el).html(content);
      <span class="keyword">return</span> el;
    },

    <span class="comment">// Change the view's element (`this.el` property), including event</span>
    <span class="comment">// re-delegation.</span>
    setElement: <span class="keyword">function</span>(element, delegate) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.$el) <span class="keyword">this</span>.undelegateEvents();
      <span class="keyword">this</span>.$el = element <span class="keyword">instanceof</span> Backbone.$ ? element : Backbone.$(element);
      <span class="keyword">this</span>.el = <span class="keyword">this</span>.$el[<span class="number">0</span>];
      <span class="keyword">if</span> (delegate !== <span class="literal">false</span>) <span class="keyword">this</span>.delegateEvents();
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Set callbacks, where `this.events` is a hash of</span>
    <span class="comment">//</span>
    <span class="comment">// *{"event selector": "callback"}*</span>
    <span class="comment">//</span>
    <span class="comment">//     {</span>
    <span class="comment">//       'mousedown .title':  'edit',</span>
    <span class="comment">//       'click .button':     'save'</span>
    <span class="comment">//       'click .open':       function(e) { ... }</span>
    <span class="comment">//     }</span>
    <span class="comment">//</span>
    <span class="comment">// pairs. Callbacks will be bound to the view, with `this` set properly.</span>
    <span class="comment">// Uses event delegation for efficiency.</span>
    <span class="comment">// Omitting the selector binds the event to `this.el`.</span>
    <span class="comment">// This only works for delegate-able events: not `focus`, `blur`, and</span>
    <span class="comment">// not `change`, `submit`, and `reset` in Internet Explorer.</span>
    delegateEvents: <span class="keyword">function</span>(events) {
      <span class="keyword">if</span> (!(events || (events = _.result(<span class="keyword">this</span>, <span class="string">'events'</span>)))) <span class="keyword">return</span>;
      <span class="keyword">this</span>.undelegateEvents();
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> events) {
        <span class="keyword">var</span> method = events[key];
        <span class="keyword">if</span> (!_.isFunction(method)) method = <span class="keyword">this</span>[events[key]];
        <span class="keyword">if</span> (!method) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'Method "'</span> + events[key] + <span class="string">'" does not exist'</span>);
        <span class="keyword">var</span> match = key.match(delegateEventSplitter);
        <span class="keyword">var</span> eventName = match[<span class="number">1</span>], selector = match[<span class="number">2</span>];
        method = _.bind(method, <span class="keyword">this</span>);
        eventName += <span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid;
        <span class="keyword">if</span> (selector === <span class="string">''</span>) {
          <span class="keyword">this</span>.$el.bind(eventName, method);
        } <span class="keyword">else</span> {
          <span class="keyword">this</span>.$el.delegate(selector, eventName, method);
        }
      }
    },

    <span class="comment">// Clears all callbacks previously bound to the view with `delegateEvents`.</span>
    <span class="comment">// You usually don't need to use this, but may wish to if you have multiple</span>
    <span class="comment">// Backbone views attached to the same DOM element.</span>
    undelegateEvents: <span class="keyword">function</span>() {
      <span class="keyword">this</span>.$el.unbind(<span class="string">'.delegateEvents'</span> + <span class="keyword">this</span>.cid);
    },

    <span class="comment">// Performs the initial configuration of a View with a set of options.</span>
    <span class="comment">// Keys with special meaning *(model, collection, id, className)*, are</span>
    <span class="comment">// attached directly to the view.</span>
    _configure: <span class="keyword">function</span>(options) {
      <span class="keyword">if</span> (<span class="keyword">this</span>.options) options = _.extend({}, _.result(<span class="keyword">this</span>, <span class="string">'options'</span>), options);
      _.extend(<span class="keyword">this</span>, _.pick(options, viewOptions));
      <span class="keyword">this</span>.options = options;
    },

    <span class="comment">// Ensure that the View has a DOM element to render into.</span>
    <span class="comment">// If `this.el` is a string, pass it through `$()`, take the first</span>
    <span class="comment">// matching element, and re-assign it to `el`. Otherwise, create</span>
    <span class="comment">// an element from the `id`, `className` and `tagName` properties.</span>
    _ensureElement: <span class="keyword">function</span>() {
      <span class="keyword">if</span> (!<span class="keyword">this</span>.el) {
        <span class="keyword">var</span> attrs = _.extend({}, _.result(<span class="keyword">this</span>, <span class="string">'attributes'</span>));
        <span class="keyword">if</span> (<span class="keyword">this</span>.id) attrs.id = _.result(<span class="keyword">this</span>, <span class="string">'id'</span>);
        <span class="keyword">if</span> (<span class="keyword">this</span>.className) attrs[<span class="string">'class'</span>] = _.result(<span class="keyword">this</span>, <span class="string">'className'</span>);
        <span class="keyword">this</span>.setElement(<span class="keyword">this</span>.make(_.result(<span class="keyword">this</span>, <span class="string">'tagName'</span>), attrs), <span class="literal">false</span>);
      } <span class="keyword">else</span> {
        <span class="keyword">this</span>.setElement(_.result(<span class="keyword">this</span>, <span class="string">'el'</span>), <span class="literal">false</span>);
      }
    }

  });

  <span class="comment">// Backbone.sync</span>
  <span class="comment">// -------------</span>

  <span class="comment">// Map from CRUD to HTTP for our default `Backbone.sync` implementation.</span>
  <span class="keyword">var</span> methodMap = {
    <span class="string">'create'</span>: <span class="string">'POST'</span>,
    <span class="string">'update'</span>: <span class="string">'PUT'</span>,
    <span class="string">'patch'</span>:  <span class="string">'PATCH'</span>,
    <span class="string">'delete'</span>: <span class="string">'DELETE'</span>,
    <span class="string">'read'</span>:   <span class="string">'GET'</span>
  };

  <span class="comment">// Override this function to change the manner in which Backbone persists</span>
  <span class="comment">// models to the server. You will be passed the type of request, and the</span>
  <span class="comment">// model in question. By default, makes a RESTful Ajax request</span>
  <span class="comment">// to the model's `url()`. Some possible customizations could be:</span>
  <span class="comment">//</span>
  <span class="comment">// * Use `setTimeout` to batch rapid-fire updates into a single request.</span>
  <span class="comment">// * Send up the models as XML instead of JSON.</span>
  <span class="comment">// * Persist models via WebSockets instead of Ajax.</span>
  <span class="comment">//</span>
  <span class="comment">// Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests</span>
  <span class="comment">// as `POST`, with a `_method` parameter containing the true HTTP method,</span>
  <span class="comment">// as well as all requests with the body as `application/x-www-form-urlencoded`</span>
  <span class="comment">// instead of `application/json` with the model in a param named `model`.</span>
  <span class="comment">// Useful when interfacing with server-side languages like **PHP** that make</span>
  <span class="comment">// it difficult to read the body of `PUT` requests.</span>
  Backbone.sync = <span class="keyword">function</span>(method, model, options) {
    <span class="keyword">var</span> type = methodMap[method];

    <span class="comment">// Default options, unless specified.</span>
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    <span class="comment">// Default JSON-request options.</span>
    <span class="keyword">var</span> params = {type: type, dataType: <span class="string">'json'</span>};

    <span class="comment">// Ensure that we have a URL.</span>
    <span class="keyword">if</span> (!options.url) {
      params.url = _.result(model, <span class="string">'url'</span>) || urlError();
    }

    <span class="comment">// Ensure that we have the appropriate request data.</span>
    <span class="keyword">if</span> (options.data == <span class="literal">null</span> &amp;&amp; model &amp;&amp; (method === <span class="string">'create'</span> || method === <span class="string">'update'</span> || method === <span class="string">'patch'</span>)) {
      params.contentType = <span class="string">'application/json'</span>;
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    <span class="comment">// For older servers, emulate JSON by encoding the request into an HTML-form.</span>
    <span class="keyword">if</span> (options.emulateJSON) {
      params.contentType = <span class="string">'application/x-www-form-urlencoded'</span>;
      params.data = params.data ? {model: params.data} : {};
    }

    <span class="comment">// For older servers, emulate HTTP by mimicking the HTTP method with `_method`</span>
    <span class="comment">// And an `X-HTTP-Method-Override` header.</span>
    <span class="keyword">if</span> (options.emulateHTTP &amp;&amp; (type === <span class="string">'PUT'</span> || type === <span class="string">'DELETE'</span> || type === <span class="string">'PATCH'</span>)) {
      params.type = <span class="string">'POST'</span>;
      <span class="keyword">if</span> (options.emulateJSON) params.data._method = type;
      <span class="keyword">var</span> beforeSend = options.beforeSend;
      options.beforeSend = <span class="keyword">function</span>(xhr) {
        xhr.setRequestHeader(<span class="string">'X-HTTP-Method-Override'</span>, type);
        <span class="keyword">if</span> (beforeSend) <span class="keyword">return</span> beforeSend.apply(<span class="keyword">this</span>, arguments);
      };
    }

    <span class="comment">// Don't process data on a non-GET request.</span>
    <span class="keyword">if</span> (params.type !== <span class="string">'GET'</span> &amp;&amp; !options.emulateJSON) {
      params.processData = <span class="literal">false</span>;
    }

    <span class="keyword">var</span> success = options.success;
    options.success = <span class="keyword">function</span>(resp, status, xhr) {
      <span class="keyword">if</span> (success) success(resp, status, xhr);
      model.trigger(<span class="string">'sync'</span>, model, resp, options);
    };

    <span class="keyword">var</span> error = options.error;
    options.error = <span class="keyword">function</span>(xhr, status, thrown) {
      <span class="keyword">if</span> (error) error(model, xhr, options);
      model.trigger(<span class="string">'error'</span>, model, xhr, options);
    };

    <span class="comment">// Make the request, allowing the user to override any Ajax options.</span>
    <span class="keyword">var</span> xhr = Backbone.ajax(_.extend(params, options));
    model.trigger(<span class="string">'request'</span>, model, xhr, options);
    <span class="keyword">return</span> xhr;
  };

  <span class="comment">// Set the default implementation of `Backbone.ajax` to proxy through to `$`.</span>
  Backbone.ajax = <span class="keyword">function</span>() {
    <span class="keyword">return</span> Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  <span class="comment">// Helpers</span>
  <span class="comment">// -------</span>

  <span class="comment">// Helper function to correctly set up the prototype chain, for subclasses.</span>
  <span class="comment">// Similar to `goog.inherits`, but uses a hash of prototype properties and</span>
  <span class="comment">// class properties to be extended.</span>
  <span class="keyword">var</span> extend = <span class="keyword">function</span>(protoProps, staticProps) {
    <span class="keyword">var</span> parent = <span class="keyword">this</span>;
    <span class="keyword">var</span> child;

    <span class="comment">// The constructor function for the new subclass is either defined by you</span>
    <span class="comment">// (the "constructor" property in your `extend` definition), or defaulted</span>
    <span class="comment">// by us to simply call the parent's constructor.</span>
    <span class="keyword">if</span> (protoProps &amp;&amp; _.has(protoProps, <span class="string">'constructor'</span>)) {
      child = protoProps.constructor;
    } <span class="keyword">else</span> {
      child = <span class="keyword">function</span>(){ parent.apply(<span class="keyword">this</span>, arguments); };
    }

    <span class="comment">// Add static properties to the constructor function, if supplied.</span>
    _.extend(child, parent, staticProps);

    <span class="comment">// Set the prototype chain to inherit from `parent`, without calling</span>
    <span class="comment">// `parent`'s constructor function.</span>
    <span class="keyword">var</span> Surrogate = <span class="keyword">function</span>(){ <span class="keyword">this</span>.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = <span class="keyword">new</span> Surrogate;

    <span class="comment">// Add prototype properties (instance properties) to the subclass,</span>
    <span class="comment">// if supplied.</span>
    <span class="keyword">if</span> (protoProps) _.extend(child.prototype, protoProps);

    <span class="comment">// Set a convenience property in case the parent's prototype is needed</span>
    <span class="comment">// later.</span>
    child.__super__ = parent.prototype;

    <span class="keyword">return</span> child;
  };

  <span class="comment">// Set up inheritance for the model, collection, router, view and history.</span>
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  <span class="comment">// Throw an error when a URL is needed, and none is supplied.</span>
  <span class="keyword">var</span> urlError = <span class="keyword">function</span>() {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'A "url" property or function must be specified'</span>);
  };

}).call(<span class="keyword">this</span>);
</code></pre>