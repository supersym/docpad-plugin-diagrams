<h1>underscore</h1>
<pre><code class="lang-js"><span class="comment">//     Underscore.js 1.4.3</span>
<span class="comment">//     http://underscorejs.org</span>
<span class="comment">//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.</span>
<span class="comment">//     Underscore may be freely distributed under the MIT license.</span>

(<span class="keyword">function</span>() {

  <span class="comment">// Baseline setup</span>
  <span class="comment">// --------------</span>

  <span class="comment">// Establish the root object, `window` in the browser, or `global` on the server.</span>
  <span class="keyword">var</span> root = <span class="keyword">this</span>;

  <span class="comment">// Save the previous value of the `_` variable.</span>
  <span class="keyword">var</span> previousUnderscore = root._;

  <span class="comment">// Establish the object that gets returned to break out of a loop iteration.</span>
  <span class="keyword">var</span> breaker = {};

  <span class="comment">// Save bytes in the minified (but not gzipped) version:</span>
  <span class="keyword">var</span> ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  <span class="comment">// Create quick reference variables for speed access to core prototypes.</span>
  <span class="keyword">var</span> push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  <span class="comment">// All **ECMAScript 5** native function implementations that we hope to use</span>
  <span class="comment">// are declared here.</span>
  <span class="keyword">var</span>
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  <span class="comment">// Create a safe reference to the Underscore object for use below.</span>
  <span class="keyword">var</span> _ = <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> _) <span class="keyword">return</span> obj;
    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> _)) <span class="keyword">return</span> <span class="keyword">new</span> _(obj);
    <span class="keyword">this</span>._wrapped = obj;
  };

  <span class="comment">// Export the Underscore object for **Node.js**, with</span>
  <span class="comment">// backwards-compatibility for the old `require()` API. If we're in</span>
  <span class="comment">// the browser, add `_` as a global object via a string identifier,</span>
  <span class="comment">// for Closure Compiler "advanced" mode.</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> exports !== <span class="string">'undefined'</span>) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> module !== <span class="string">'undefined'</span> &amp;&amp; module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } <span class="keyword">else</span> {
    root._ = _;
  }

  <span class="comment">// Current version.</span>
  _.VERSION = <span class="string">'1.4.3'</span>;

  <span class="comment">// Collection Functions</span>
  <span class="comment">// --------------------</span>

  <span class="comment">// The cornerstone, an `each` implementation, aka `forEach`.</span>
  <span class="comment">// Handles objects with the built-in `forEach`, arrays, and raw objects.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `forEach` if available.</span>
  <span class="keyword">var</span> each = _.each = _.forEach = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span>;
    <span class="keyword">if</span> (nativeForEach &amp;&amp; obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } <span class="keyword">else</span> <span class="keyword">if</span> (obj.length === +obj.length) {
      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) {
        <span class="keyword">if</span> (iterator.call(context, obj[i], i, obj) === breaker) <span class="keyword">return</span>;
      }
    } <span class="keyword">else</span> {
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) {
        <span class="keyword">if</span> (_.has(obj, key)) {
          <span class="keyword">if</span> (iterator.call(context, obj[key], key, obj) === breaker) <span class="keyword">return</span>;
        }
      }
    }
  };

  <span class="comment">// Return the results of applying the iterator to each element.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `map` if available.</span>
  _.map = _.collect = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">var</span> results = [];
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;
    <span class="keyword">if</span> (nativeMap &amp;&amp; obj.map === nativeMap) <span class="keyword">return</span> obj.map(iterator, context);
    each(obj, <span class="keyword">function</span>(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    <span class="keyword">return</span> results;
  };

  <span class="keyword">var</span> reduceError = <span class="string">'Reduce of empty array with no initial value'</span>;

  <span class="comment">// **Reduce** builds up a single result from a list of values, aka `inject`,</span>
  <span class="comment">// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.</span>
  _.reduce = _.foldl = _.inject = <span class="keyword">function</span>(obj, iterator, memo, context) {
    <span class="keyword">var</span> initial = arguments.length > <span class="number">2</span>;
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];
    <span class="keyword">if</span> (nativeReduce &amp;&amp; obj.reduce === nativeReduce) {
      <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);
      <span class="keyword">return</span> initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">if</span> (!initial) {
        memo = value;
        initial = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    <span class="keyword">if</span> (!initial) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(reduceError);
    <span class="keyword">return</span> memo;
  };

  <span class="comment">// The right-associative version of reduce, also known as `foldr`.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `reduceRight` if available.</span>
  _.reduceRight = _.foldr = <span class="keyword">function</span>(obj, iterator, memo, context) {
    <span class="keyword">var</span> initial = arguments.length > <span class="number">2</span>;
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) obj = [];
    <span class="keyword">if</span> (nativeReduceRight &amp;&amp; obj.reduceRight === nativeReduceRight) {
      <span class="keyword">if</span> (context) iterator = _.bind(iterator, context);
      <span class="keyword">return</span> initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    <span class="keyword">var</span> length = obj.length;
    <span class="keyword">if</span> (length !== +length) {
      <span class="keyword">var</span> keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, <span class="keyword">function</span>(value, index, list) {
      index = keys ? keys[--length] : --length;
      <span class="keyword">if</span> (!initial) {
        memo = obj[index];
        initial = <span class="literal">true</span>;
      } <span class="keyword">else</span> {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    <span class="keyword">if</span> (!initial) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(reduceError);
    <span class="keyword">return</span> memo;
  };

  <span class="comment">// Return the first value which passes a truth test. Aliased as `detect`.</span>
  _.find = _.detect = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">var</span> result;
    any(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">if</span> (iterator.call(context, value, index, list)) {
        result = value;
        <span class="keyword">return</span> <span class="literal">true</span>;
      }
    });
    <span class="keyword">return</span> result;
  };

  <span class="comment">// Return all the elements that pass a truth test.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `filter` if available.</span>
  <span class="comment">// Aliased as `select`.</span>
  _.filter = _.select = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">var</span> results = [];
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> results;
    <span class="keyword">if</span> (nativeFilter &amp;&amp; obj.filter === nativeFilter) <span class="keyword">return</span> obj.filter(iterator, context);
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">if</span> (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    <span class="keyword">return</span> results;
  };

  <span class="comment">// Return all the elements for which a truth test fails.</span>
  _.reject = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">return</span> _.filter(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">return</span> !iterator.call(context, value, index, list);
    }, context);
  };

  <span class="comment">// Determine whether all of the elements match a truth test.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `every` if available.</span>
  <span class="comment">// Aliased as `all`.</span>
  _.every = _.all = <span class="keyword">function</span>(obj, iterator, context) {
    iterator || (iterator = _.identity);
    <span class="keyword">var</span> result = <span class="literal">true</span>;
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> result;
    <span class="keyword">if</span> (nativeEvery &amp;&amp; obj.every === nativeEvery) <span class="keyword">return</span> obj.every(iterator, context);
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">if</span> (!(result = result &amp;&amp; iterator.call(context, value, index, list))) <span class="keyword">return</span> breaker;
    });
    <span class="keyword">return</span> !!result;
  };

  <span class="comment">// Determine if at least one element in the object matches a truth test.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `some` if available.</span>
  <span class="comment">// Aliased as `any`.</span>
  <span class="keyword">var</span> any = _.some = _.any = <span class="keyword">function</span>(obj, iterator, context) {
    iterator || (iterator = _.identity);
    <span class="keyword">var</span> result = <span class="literal">false</span>;
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> result;
    <span class="keyword">if</span> (nativeSome &amp;&amp; obj.some === nativeSome) <span class="keyword">return</span> obj.some(iterator, context);
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">if</span> (result || (result = iterator.call(context, value, index, list))) <span class="keyword">return</span> breaker;
    });
    <span class="keyword">return</span> !!result;
  };

  <span class="comment">// Determine if the array or object contains a given value (using `===`).</span>
  <span class="comment">// Aliased as `include`.</span>
  _.contains = _.include = <span class="keyword">function</span>(obj, target) {
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">if</span> (nativeIndexOf &amp;&amp; obj.indexOf === nativeIndexOf) <span class="keyword">return</span> obj.indexOf(target) != -<span class="number">1</span>;
    <span class="keyword">return</span> any(obj, <span class="keyword">function</span>(value) {
      <span class="keyword">return</span> value === target;
    });
  };

  <span class="comment">// Invoke a method (with arguments) on every item in a collection.</span>
  _.invoke = <span class="keyword">function</span>(obj, method) {
    <span class="keyword">var</span> args = slice.call(arguments, <span class="number">2</span>);
    <span class="keyword">return</span> _.map(obj, <span class="keyword">function</span>(value) {
      <span class="keyword">return</span> (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  <span class="comment">// Convenience version of a common use case of `map`: fetching a property.</span>
  _.pluck = <span class="keyword">function</span>(obj, key) {
    <span class="keyword">return</span> _.map(obj, <span class="keyword">function</span>(value){ <span class="keyword">return</span> value[key]; });
  };

  <span class="comment">// Convenience version of a common use case of `filter`: selecting only objects</span>
  <span class="comment">// with specific `key:value` pairs.</span>
  _.where = <span class="keyword">function</span>(obj, attrs) {
    <span class="keyword">if</span> (_.isEmpty(attrs)) <span class="keyword">return</span> [];
    <span class="keyword">return</span> _.filter(obj, <span class="keyword">function</span>(value) {
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> attrs) {
        <span class="keyword">if</span> (attrs[key] !== value[key]) <span class="keyword">return</span> <span class="literal">false</span>;
      }
      <span class="keyword">return</span> <span class="literal">true</span>;
    });
  };

  <span class="comment">// Return the maximum element or (element-based computation).</span>
  <span class="comment">// Can't optimize arrays of integers longer than 65,535 elements.</span>
  <span class="comment">// See: https://bugs.webkit.org/show_bug.cgi?id=80797</span>
  _.max = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">if</span> (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[<span class="number">0</span>] === +obj[<span class="number">0</span>] &amp;&amp; obj.length &lt; <span class="number">65535</span>) {
      <span class="keyword">return</span> Math.max.apply(Math, obj);
    }
    <span class="keyword">if</span> (!iterator &amp;&amp; _.isEmpty(obj)) <span class="keyword">return</span> -<span class="literal">Infinity</span>;
    <span class="keyword">var</span> result = {computed : -<span class="literal">Infinity</span>, value: -<span class="literal">Infinity</span>};
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">var</span> computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed &amp;&amp; (result = {value : value, computed : computed});
    });
    <span class="keyword">return</span> result.value;
  };

  <span class="comment">// Return the minimum element (or element-based computation).</span>
  _.min = <span class="keyword">function</span>(obj, iterator, context) {
    <span class="keyword">if</span> (!iterator &amp;&amp; _.isArray(obj) &amp;&amp; obj[<span class="number">0</span>] === +obj[<span class="number">0</span>] &amp;&amp; obj.length &lt; <span class="number">65535</span>) {
      <span class="keyword">return</span> Math.min.apply(Math, obj);
    }
    <span class="keyword">if</span> (!iterator &amp;&amp; _.isEmpty(obj)) <span class="keyword">return</span> <span class="literal">Infinity</span>;
    <span class="keyword">var</span> result = {computed : <span class="literal">Infinity</span>, value: <span class="literal">Infinity</span>};
    each(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">var</span> computed = iterator ? iterator.call(context, value, index, list) : value;
      computed &lt; result.computed &amp;&amp; (result = {value : value, computed : computed});
    });
    <span class="keyword">return</span> result.value;
  };

  <span class="comment">// Shuffle an array.</span>
  _.shuffle = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> rand;
    <span class="keyword">var</span> index = <span class="number">0</span>;
    <span class="keyword">var</span> shuffled = [];
    each(obj, <span class="keyword">function</span>(value) {
      rand = _.random(index++);
      shuffled[index - <span class="number">1</span>] = shuffled[rand];
      shuffled[rand] = value;
    });
    <span class="keyword">return</span> shuffled;
  };

  <span class="comment">// An internal function to generate lookup iterators.</span>
  <span class="keyword">var</span> lookupIterator = <span class="keyword">function</span>(value) {
    <span class="keyword">return</span> _.isFunction(value) ? value : <span class="keyword">function</span>(obj){ <span class="keyword">return</span> obj[value]; };
  };

  <span class="comment">// Sort the object's values by a criterion produced by an iterator.</span>
  _.sortBy = <span class="keyword">function</span>(obj, value, context) {
    <span class="keyword">var</span> iterator = lookupIterator(value);
    <span class="keyword">return</span> _.pluck(_.map(obj, <span class="keyword">function</span>(value, index, list) {
      <span class="keyword">return</span> {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(<span class="keyword">function</span>(left, right) {
      <span class="keyword">var</span> a = left.criteria;
      <span class="keyword">var</span> b = right.criteria;
      <span class="keyword">if</span> (a !== b) {
        <span class="keyword">if</span> (a > b || a === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;
        <span class="keyword">if</span> (a &lt; b || b === <span class="keyword">void</span> <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;
      }
      <span class="keyword">return</span> left.index &lt; right.index ? -<span class="number">1</span> : <span class="number">1</span>;
    }), <span class="string">'value'</span>);
  };

  <span class="comment">// An internal function used for aggregate "group by" operations.</span>
  <span class="keyword">var</span> group = <span class="keyword">function</span>(obj, value, context, behavior) {
    <span class="keyword">var</span> result = {};
    <span class="keyword">var</span> iterator = lookupIterator(value || _.identity);
    each(obj, <span class="keyword">function</span>(value, index) {
      <span class="keyword">var</span> key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    <span class="keyword">return</span> result;
  };

  <span class="comment">// Groups the object's values by a criterion. Pass either a string attribute</span>
  <span class="comment">// to group by, or a function that returns the criterion.</span>
  _.groupBy = <span class="keyword">function</span>(obj, value, context) {
    <span class="keyword">return</span> group(obj, value, context, <span class="keyword">function</span>(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  <span class="comment">// Counts instances of an object that group by a certain criterion. Pass</span>
  <span class="comment">// either a string attribute to count by, or a function that returns the</span>
  <span class="comment">// criterion.</span>
  _.countBy = <span class="keyword">function</span>(obj, value, context) {
    <span class="keyword">return</span> group(obj, value, context, <span class="keyword">function</span>(result, key) {
      <span class="keyword">if</span> (!_.has(result, key)) result[key] = <span class="number">0</span>;
      result[key]++;
    });
  };

  <span class="comment">// Use a comparator function to figure out the smallest index at which</span>
  <span class="comment">// an object should be inserted so as to maintain order. Uses binary search.</span>
  _.sortedIndex = <span class="keyword">function</span>(array, obj, iterator, context) {
    iterator = iterator == <span class="literal">null</span> ? _.identity : lookupIterator(iterator);
    <span class="keyword">var</span> value = iterator.call(context, obj);
    <span class="keyword">var</span> low = <span class="number">0</span>, high = array.length;
    <span class="keyword">while</span> (low &lt; high) {
      <span class="keyword">var</span> mid = (low + high) >>> <span class="number">1</span>;
      iterator.call(context, array[mid]) &lt; value ? low = mid + <span class="number">1</span> : high = mid;
    }
    <span class="keyword">return</span> low;
  };

  <span class="comment">// Safely convert anything iterable into a real, live array.</span>
  _.toArray = <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> [];
    <span class="keyword">if</span> (_.isArray(obj)) <span class="keyword">return</span> slice.call(obj);
    <span class="keyword">if</span> (obj.length === +obj.length) <span class="keyword">return</span> _.map(obj, _.identity);
    <span class="keyword">return</span> _.values(obj);
  };

  <span class="comment">// Return the number of elements in an object.</span>
  _.size = <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;
    <span class="keyword">return</span> (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  <span class="comment">// Array Functions</span>
  <span class="comment">// ---------------</span>

  <span class="comment">// Get the first element of an array. Passing **n** will return the first N</span>
  <span class="comment">// values in the array. Aliased as `head` and `take`. The **guard** check</span>
  <span class="comment">// allows it to work with `_.map`.</span>
  _.first = _.head = _.take = <span class="keyword">function</span>(array, n, guard) {
    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;
    <span class="keyword">return</span> (n != <span class="literal">null</span>) &amp;&amp; !guard ? slice.call(array, <span class="number">0</span>, n) : array[<span class="number">0</span>];
  };

  <span class="comment">// Returns everything but the last entry of the array. Especially useful on</span>
  <span class="comment">// the arguments object. Passing **n** will return all the values in</span>
  <span class="comment">// the array, excluding the last N. The **guard** check allows it to work with</span>
  <span class="comment">// `_.map`.</span>
  _.initial = <span class="keyword">function</span>(array, n, guard) {
    <span class="keyword">return</span> slice.call(array, <span class="number">0</span>, array.length - ((n == <span class="literal">null</span>) || guard ? <span class="number">1</span> : n));
  };

  <span class="comment">// Get the last element of an array. Passing **n** will return the last N</span>
  <span class="comment">// values in the array. The **guard** check allows it to work with `_.map`.</span>
  _.last = <span class="keyword">function</span>(array, n, guard) {
    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">void</span> <span class="number">0</span>;
    <span class="keyword">if</span> ((n != <span class="literal">null</span>) &amp;&amp; !guard) {
      <span class="keyword">return</span> slice.call(array, Math.max(array.length - n, <span class="number">0</span>));
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> array[array.length - <span class="number">1</span>];
    }
  };

  <span class="comment">// Returns everything but the first entry of the array. Aliased as `tail` and `drop`.</span>
  <span class="comment">// Especially useful on the arguments object. Passing an **n** will return</span>
  <span class="comment">// the rest N values in the array. The **guard**</span>
  <span class="comment">// check allows it to work with `_.map`.</span>
  _.rest = _.tail = _.drop = <span class="keyword">function</span>(array, n, guard) {
    <span class="keyword">return</span> slice.call(array, (n == <span class="literal">null</span>) || guard ? <span class="number">1</span> : n);
  };

  <span class="comment">// Trim out all falsy values from an array.</span>
  _.compact = <span class="keyword">function</span>(array) {
    <span class="keyword">return</span> _.filter(array, _.identity);
  };

  <span class="comment">// Internal implementation of a recursive `flatten` function.</span>
  <span class="keyword">var</span> flatten = <span class="keyword">function</span>(input, shallow, output) {
    each(input, <span class="keyword">function</span>(value) {
      <span class="keyword">if</span> (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } <span class="keyword">else</span> {
        output.push(value);
      }
    });
    <span class="keyword">return</span> output;
  };

  <span class="comment">// Return a completely flattened version of an array.</span>
  _.flatten = <span class="keyword">function</span>(array, shallow) {
    <span class="keyword">return</span> flatten(array, shallow, []);
  };

  <span class="comment">// Return a version of the array that does not contain the specified value(s).</span>
  _.without = <span class="keyword">function</span>(array) {
    <span class="keyword">return</span> _.difference(array, slice.call(arguments, <span class="number">1</span>));
  };

  <span class="comment">// Produce a duplicate-free version of the array. If the array has already</span>
  <span class="comment">// been sorted, you have the option of using a faster algorithm.</span>
  <span class="comment">// Aliased as `unique`.</span>
  _.uniq = _.unique = <span class="keyword">function</span>(array, isSorted, iterator, context) {
    <span class="keyword">if</span> (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = <span class="literal">false</span>;
    }
    <span class="keyword">var</span> initial = iterator ? _.map(array, iterator, context) : array;
    <span class="keyword">var</span> results = [];
    <span class="keyword">var</span> seen = [];
    each(initial, <span class="keyword">function</span>(value, index) {
      <span class="keyword">if</span> (isSorted ? (!index || seen[seen.length - <span class="number">1</span>] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    <span class="keyword">return</span> results;
  };

  <span class="comment">// Produce an array that contains the union: each distinct element from all of</span>
  <span class="comment">// the passed-in arrays.</span>
  _.union = <span class="keyword">function</span>() {
    <span class="keyword">return</span> _.uniq(concat.apply(ArrayProto, arguments));
  };

  <span class="comment">// Produce an array that contains every item shared between all the</span>
  <span class="comment">// passed-in arrays.</span>
  _.intersection = <span class="keyword">function</span>(array) {
    <span class="keyword">var</span> rest = slice.call(arguments, <span class="number">1</span>);
    <span class="keyword">return</span> _.filter(_.uniq(array), <span class="keyword">function</span>(item) {
      <span class="keyword">return</span> _.every(rest, <span class="keyword">function</span>(other) {
        <span class="keyword">return</span> _.indexOf(other, item) >= <span class="number">0</span>;
      });
    });
  };

  <span class="comment">// Take the difference between one array and a number of other arrays.</span>
  <span class="comment">// Only the elements present in just the first array will remain.</span>
  _.difference = <span class="keyword">function</span>(array) {
    <span class="keyword">var</span> rest = concat.apply(ArrayProto, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">return</span> _.filter(array, <span class="keyword">function</span>(value){ <span class="keyword">return</span> !_.contains(rest, value); });
  };

  <span class="comment">// Zip together multiple lists into a single array -- elements that share</span>
  <span class="comment">// an index go together.</span>
  _.zip = <span class="keyword">function</span>() {
    <span class="keyword">var</span> args = slice.call(arguments);
    <span class="keyword">var</span> length = _.max(_.pluck(args, <span class="string">'length'</span>));
    <span class="keyword">var</span> results = <span class="keyword">new</span> Array(length);
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) {
      results[i] = _.pluck(args, <span class="string">""</span> + i);
    }
    <span class="keyword">return</span> results;
  };

  <span class="comment">// Converts lists into objects. Pass either a single array of `[key, value]`</span>
  <span class="comment">// pairs, or two parallel arrays of the same length -- one of keys, and one of</span>
  <span class="comment">// the corresponding values.</span>
  _.object = <span class="keyword">function</span>(list, values) {
    <span class="keyword">if</span> (list == <span class="literal">null</span>) <span class="keyword">return</span> {};
    <span class="keyword">var</span> result = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) {
      <span class="keyword">if</span> (values) {
        result[list[i]] = values[i];
      } <span class="keyword">else</span> {
        result[list[i][<span class="number">0</span>]] = list[i][<span class="number">1</span>];
      }
    }
    <span class="keyword">return</span> result;
  };

  <span class="comment">// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),</span>
  <span class="comment">// we need this function. Return the position of the first occurrence of an</span>
  <span class="comment">// item in an array, or -1 if the item is not included in the array.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `indexOf` if available.</span>
  <span class="comment">// If the array is large and already in sort order, pass `true`</span>
  <span class="comment">// for **isSorted** to use binary search.</span>
  _.indexOf = <span class="keyword">function</span>(array, item, isSorted) {
    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">var</span> i = <span class="number">0</span>, l = array.length;
    <span class="keyword">if</span> (isSorted) {
      <span class="keyword">if</span> (<span class="keyword">typeof</span> isSorted == <span class="string">'number'</span>) {
        i = (isSorted &lt; <span class="number">0</span> ? Math.max(<span class="number">0</span>, l + isSorted) : isSorted);
      } <span class="keyword">else</span> {
        i = _.sortedIndex(array, item);
        <span class="keyword">return</span> array[i] === item ? i : -<span class="number">1</span>;
      }
    }
    <span class="keyword">if</span> (nativeIndexOf &amp;&amp; array.indexOf === nativeIndexOf) <span class="keyword">return</span> array.indexOf(item, isSorted);
    <span class="keyword">for</span> (; i &lt; l; i++) <span class="keyword">if</span> (array[i] === item) <span class="keyword">return</span> i;
    <span class="keyword">return</span> -<span class="number">1</span>;
  };

  <span class="comment">// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.</span>
  _.lastIndexOf = <span class="keyword">function</span>(array, item, from) {
    <span class="keyword">if</span> (array == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;
    <span class="keyword">var</span> hasIndex = from != <span class="literal">null</span>;
    <span class="keyword">if</span> (nativeLastIndexOf &amp;&amp; array.lastIndexOf === nativeLastIndexOf) {
      <span class="keyword">return</span> hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    <span class="keyword">var</span> i = (hasIndex ? from : array.length);
    <span class="keyword">while</span> (i--) <span class="keyword">if</span> (array[i] === item) <span class="keyword">return</span> i;
    <span class="keyword">return</span> -<span class="number">1</span>;
  };

  <span class="comment">// Generate an integer Array containing an arithmetic progression. A port of</span>
  <span class="comment">// the native Python `range()` function. See</span>
  <span class="comment">// [the Python documentation](http://docs.python.org/library/functions.html#range).</span>
  _.range = <span class="keyword">function</span>(start, stop, step) {
    <span class="keyword">if</span> (arguments.length &lt;= <span class="number">1</span>) {
      stop = start || <span class="number">0</span>;
      start = <span class="number">0</span>;
    }
    step = arguments[<span class="number">2</span>] || <span class="number">1</span>;

    <span class="keyword">var</span> len = Math.max(Math.ceil((stop - start) / step), <span class="number">0</span>);
    <span class="keyword">var</span> idx = <span class="number">0</span>;
    <span class="keyword">var</span> range = <span class="keyword">new</span> Array(len);

    <span class="keyword">while</span>(idx &lt; len) {
      range[idx++] = start;
      start += step;
    }

    <span class="keyword">return</span> range;
  };

  <span class="comment">// Function (ahem) Functions</span>
  <span class="comment">// ------------------</span>

  <span class="comment">// Reusable constructor function for prototype setting.</span>
  <span class="keyword">var</span> ctor = <span class="keyword">function</span>(){};

  <span class="comment">// Create a function bound to a given object (assigning `this`, and arguments,</span>
  <span class="comment">// optionally). Binding with arguments is also known as `curry`.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `Function.bind` if available.</span>
  <span class="comment">// We check for `func.bind` first, to fail fast when `func` is undefined.</span>
  _.bind = <span class="keyword">function</span>(func, context) {
    <span class="keyword">var</span> args, bound;
    <span class="keyword">if</span> (func.bind === nativeBind &amp;&amp; nativeBind) <span class="keyword">return</span> nativeBind.apply(func, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">if</span> (!_.isFunction(func)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError;
    args = slice.call(arguments, <span class="number">2</span>);
    <span class="keyword">return</span> bound = <span class="keyword">function</span>() {
      <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> bound)) <span class="keyword">return</span> func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      <span class="keyword">var</span> self = <span class="keyword">new</span> ctor;
      ctor.prototype = <span class="literal">null</span>;
      <span class="keyword">var</span> result = func.apply(self, args.concat(slice.call(arguments)));
      <span class="keyword">if</span> (Object(result) === result) <span class="keyword">return</span> result;
      <span class="keyword">return</span> self;
    };
  };

  <span class="comment">// Bind all of an object's methods to that object. Useful for ensuring that</span>
  <span class="comment">// all callbacks defined on an object belong to it.</span>
  _.bindAll = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> funcs = slice.call(arguments, <span class="number">1</span>);
    <span class="keyword">if</span> (funcs.length == <span class="number">0</span>) funcs = _.functions(obj);
    each(funcs, <span class="keyword">function</span>(f) { obj[f] = _.bind(obj[f], obj); });
    <span class="keyword">return</span> obj;
  };

  <span class="comment">// Memoize an expensive function by storing its results.</span>
  _.memoize = <span class="keyword">function</span>(func, hasher) {
    <span class="keyword">var</span> memo = {};
    hasher || (hasher = _.identity);
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">var</span> key = hasher.apply(<span class="keyword">this</span>, arguments);
      <span class="keyword">return</span> _.has(memo, key) ? memo[key] : (memo[key] = func.apply(<span class="keyword">this</span>, arguments));
    };
  };

  <span class="comment">// Delays a function for the given number of milliseconds, and then calls</span>
  <span class="comment">// it with the arguments supplied.</span>
  _.delay = <span class="keyword">function</span>(func, wait) {
    <span class="keyword">var</span> args = slice.call(arguments, <span class="number">2</span>);
    <span class="keyword">return</span> setTimeout(<span class="keyword">function</span>(){ <span class="keyword">return</span> func.apply(<span class="literal">null</span>, args); }, wait);
  };

  <span class="comment">// Defers a function, scheduling it to run after the current call stack has</span>
  <span class="comment">// cleared.</span>
  _.defer = <span class="keyword">function</span>(func) {
    <span class="keyword">return</span> _.delay.apply(_, [func, <span class="number">1</span>].concat(slice.call(arguments, <span class="number">1</span>)));
  };

  <span class="comment">// Returns a function, that, when invoked, will only be triggered at most once</span>
  <span class="comment">// during a given window of time.</span>
  _.throttle = <span class="keyword">function</span>(func, wait) {
    <span class="keyword">var</span> context, args, timeout, result;
    <span class="keyword">var</span> previous = <span class="number">0</span>;
    <span class="keyword">var</span> later = <span class="keyword">function</span>() {
      previous = <span class="keyword">new</span> Date;
      timeout = <span class="literal">null</span>;
      result = func.apply(context, args);
    };
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">var</span> now = <span class="keyword">new</span> Date;
      <span class="keyword">var</span> remaining = wait - (now - previous);
      context = <span class="keyword">this</span>;
      args = arguments;
      <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span>) {
        clearTimeout(timeout);
        timeout = <span class="literal">null</span>;
        previous = now;
        result = func.apply(context, args);
      } <span class="keyword">else</span> <span class="keyword">if</span> (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      <span class="keyword">return</span> result;
    };
  };

  <span class="comment">// Returns a function, that, as long as it continues to be invoked, will not</span>
  <span class="comment">// be triggered. The function will be called after it stops being called for</span>
  <span class="comment">// N milliseconds. If `immediate` is passed, trigger the function on the</span>
  <span class="comment">// leading edge, instead of the trailing.</span>
  _.debounce = <span class="keyword">function</span>(func, wait, immediate) {
    <span class="keyword">var</span> timeout, result;
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">var</span> context = <span class="keyword">this</span>, args = arguments;
      <span class="keyword">var</span> later = <span class="keyword">function</span>() {
        timeout = <span class="literal">null</span>;
        <span class="keyword">if</span> (!immediate) result = func.apply(context, args);
      };
      <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      <span class="keyword">if</span> (callNow) result = func.apply(context, args);
      <span class="keyword">return</span> result;
    };
  };

  <span class="comment">// Returns a function that will be executed at most one time, no matter how</span>
  <span class="comment">// often you call it. Useful for lazy initialization.</span>
  _.once = <span class="keyword">function</span>(func) {
    <span class="keyword">var</span> ran = <span class="literal">false</span>, memo;
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">if</span> (ran) <span class="keyword">return</span> memo;
      ran = <span class="literal">true</span>;
      memo = func.apply(<span class="keyword">this</span>, arguments);
      func = <span class="literal">null</span>;
      <span class="keyword">return</span> memo;
    };
  };

  <span class="comment">// Returns the first function passed as an argument to the second,</span>
  <span class="comment">// allowing you to adjust arguments, run code before and after, and</span>
  <span class="comment">// conditionally execute the original function.</span>
  _.wrap = <span class="keyword">function</span>(func, wrapper) {
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">var</span> args = [func];
      push.apply(args, arguments);
      <span class="keyword">return</span> wrapper.apply(<span class="keyword">this</span>, args);
    };
  };

  <span class="comment">// Returns a function that is the composition of a list of functions, each</span>
  <span class="comment">// consuming the return value of the function that follows.</span>
  _.compose = <span class="keyword">function</span>() {
    <span class="keyword">var</span> funcs = arguments;
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">var</span> args = arguments;
      <span class="keyword">for</span> (<span class="keyword">var</span> i = funcs.length - <span class="number">1</span>; i >= <span class="number">0</span>; i--) {
        args = [funcs[i].apply(<span class="keyword">this</span>, args)];
      }
      <span class="keyword">return</span> args[<span class="number">0</span>];
    };
  };

  <span class="comment">// Returns a function that will only be executed after being called N times.</span>
  _.after = <span class="keyword">function</span>(times, func) {
    <span class="keyword">if</span> (times &lt;= <span class="number">0</span>) <span class="keyword">return</span> func();
    <span class="keyword">return</span> <span class="keyword">function</span>() {
      <span class="keyword">if</span> (--times &lt; <span class="number">1</span>) {
        <span class="keyword">return</span> func.apply(<span class="keyword">this</span>, arguments);
      }
    };
  };

  <span class="comment">// Object Functions</span>
  <span class="comment">// ----------------</span>

  <span class="comment">// Retrieve the names of an object's properties.</span>
  <span class="comment">// Delegates to **ECMAScript 5**'s native `Object.keys`</span>
  _.keys = nativeKeys || <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (obj !== Object(obj)) <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Invalid object'</span>);
    <span class="keyword">var</span> keys = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) keys[keys.length] = key;
    <span class="keyword">return</span> keys;
  };

  <span class="comment">// Retrieve the values of an object's properties.</span>
  _.values = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> values = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) values.push(obj[key]);
    <span class="keyword">return</span> values;
  };

  <span class="comment">// Convert an object into a list of `[key, value]` pairs.</span>
  _.pairs = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> pairs = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) pairs.push([key, obj[key]]);
    <span class="keyword">return</span> pairs;
  };

  <span class="comment">// Invert the keys and values of an object. The values must be serializable.</span>
  _.invert = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> result = {};
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) result[obj[key]] = key;
    <span class="keyword">return</span> result;
  };

  <span class="comment">// Return a sorted list of the function names available on the object.</span>
  <span class="comment">// Aliased as `methods`</span>
  _.functions = _.methods = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> names = [];
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) {
      <span class="keyword">if</span> (_.isFunction(obj[key])) names.push(key);
    }
    <span class="keyword">return</span> names.sort();
  };

  <span class="comment">// Extend a given object with all the properties in passed-in object(s).</span>
  _.extend = <span class="keyword">function</span>(obj) {
    each(slice.call(arguments, <span class="number">1</span>), <span class="keyword">function</span>(source) {
      <span class="keyword">if</span> (source) {
        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) {
          obj[prop] = source[prop];
        }
      }
    });
    <span class="keyword">return</span> obj;
  };

  <span class="comment">// Return a copy of the object only containing the whitelisted properties.</span>
  _.pick = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> copy = {};
    <span class="keyword">var</span> keys = concat.apply(ArrayProto, slice.call(arguments, <span class="number">1</span>));
    each(keys, <span class="keyword">function</span>(key) {
      <span class="keyword">if</span> (key <span class="keyword">in</span> obj) copy[key] = obj[key];
    });
    <span class="keyword">return</span> copy;
  };

   <span class="comment">// Return a copy of the object without the blacklisted properties.</span>
  _.omit = <span class="keyword">function</span>(obj) {
    <span class="keyword">var</span> copy = {};
    <span class="keyword">var</span> keys = concat.apply(ArrayProto, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) {
      <span class="keyword">if</span> (!_.contains(keys, key)) copy[key] = obj[key];
    }
    <span class="keyword">return</span> copy;
  };

  <span class="comment">// Fill in a given object with default properties.</span>
  _.defaults = <span class="keyword">function</span>(obj) {
    each(slice.call(arguments, <span class="number">1</span>), <span class="keyword">function</span>(source) {
      <span class="keyword">if</span> (source) {
        <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> source) {
          <span class="keyword">if</span> (obj[prop] == <span class="literal">null</span>) obj[prop] = source[prop];
        }
      }
    });
    <span class="keyword">return</span> obj;
  };

  <span class="comment">// Create a (shallow-cloned) duplicate of an object.</span>
  _.clone = <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (!_.isObject(obj)) <span class="keyword">return</span> obj;
    <span class="keyword">return</span> _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  <span class="comment">// Invokes interceptor with the obj, and then returns obj.</span>
  <span class="comment">// The primary purpose of this method is to "tap into" a method chain, in</span>
  <span class="comment">// order to perform operations on intermediate results within the chain.</span>
  _.tap = <span class="keyword">function</span>(obj, interceptor) {
    interceptor(obj);
    <span class="keyword">return</span> obj;
  };

  <span class="comment">// Internal recursive comparison function for `isEqual`.</span>
  <span class="keyword">var</span> eq = <span class="keyword">function</span>(a, b, aStack, bStack) {
    <span class="comment">// Identical objects are equal. `0 === -0`, but they aren't identical.</span>
    <span class="comment">// See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.</span>
    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> a !== <span class="number">0</span> || <span class="number">1</span> / a == <span class="number">1</span> / b;
    <span class="comment">// A strict comparison is necessary because `null == undefined`.</span>
    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) <span class="keyword">return</span> a === b;
    <span class="comment">// Unwrap any wrapped objects.</span>
    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> _) a = a._wrapped;
    <span class="keyword">if</span> (b <span class="keyword">instanceof</span> _) b = b._wrapped;
    <span class="comment">// Compare `[[Class]]` names.</span>
    <span class="keyword">var</span> className = toString.call(a);
    <span class="keyword">if</span> (className != toString.call(b)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">switch</span> (className) {
      <span class="comment">// Strings, numbers, dates, and booleans are compared by value.</span>
      <span class="keyword">case</span> <span class="string">'[object String]'</span>:
        <span class="comment">// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is</span>
        <span class="comment">// equivalent to `new String("5")`.</span>
        <span class="keyword">return</span> a == String(b);
      <span class="keyword">case</span> <span class="string">'[object Number]'</span>:
        <span class="comment">// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for</span>
        <span class="comment">// other numeric values.</span>
        <span class="keyword">return</span> a != +a ? b != +b : (a == <span class="number">0</span> ? <span class="number">1</span> / a == <span class="number">1</span> / b : a == +b);
      <span class="keyword">case</span> <span class="string">'[object Date]'</span>:
      <span class="keyword">case</span> <span class="string">'[object Boolean]'</span>:
        <span class="comment">// Coerce dates and booleans to numeric primitive values. Dates are compared by their</span>
        <span class="comment">// millisecond representations. Note that invalid dates with millisecond representations</span>
        <span class="comment">// of `NaN` are not equivalent.</span>
        <span class="keyword">return</span> +a == +b;
      <span class="comment">// RegExps are compared by their source patterns and flags.</span>
      <span class="keyword">case</span> <span class="string">'[object RegExp]'</span>:
        <span class="keyword">return</span> a.source == b.source &amp;&amp;
               a.global == b.global &amp;&amp;
               a.multiline == b.multiline &amp;&amp;
               a.ignoreCase == b.ignoreCase;
    }
    <span class="keyword">if</span> (<span class="keyword">typeof</span> a != <span class="string">'object'</span> || <span class="keyword">typeof</span> b != <span class="string">'object'</span>) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="comment">// Assume equality for cyclic structures. The algorithm for detecting cyclic</span>
    <span class="comment">// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.</span>
    <span class="keyword">var</span> length = aStack.length;
    <span class="keyword">while</span> (length--) {
      <span class="comment">// Linear search. Performance is inversely proportional to the number of</span>
      <span class="comment">// unique nested structures.</span>
      <span class="keyword">if</span> (aStack[length] == a) <span class="keyword">return</span> bStack[length] == b;
    }
    <span class="comment">// Add the first object to the stack of traversed objects.</span>
    aStack.push(a);
    bStack.push(b);
    <span class="keyword">var</span> size = <span class="number">0</span>, result = <span class="literal">true</span>;
    <span class="comment">// Recursively compare objects and arrays.</span>
    <span class="keyword">if</span> (className == <span class="string">'[object Array]'</span>) {
      <span class="comment">// Compare array lengths to determine if a deep comparison is necessary.</span>
      size = a.length;
      result = size == b.length;
      <span class="keyword">if</span> (result) {
        <span class="comment">// Deep compare the contents, ignoring non-numeric properties.</span>
        <span class="keyword">while</span> (size--) {
          <span class="keyword">if</span> (!(result = eq(a[size], b[size], aStack, bStack))) <span class="keyword">break</span>;
        }
      }
    } <span class="keyword">else</span> {
      <span class="comment">// Objects with different constructors are not equivalent, but `Object`s</span>
      <span class="comment">// from different frames are.</span>
      <span class="keyword">var</span> aCtor = a.constructor, bCtor = b.constructor;
      <span class="keyword">if</span> (aCtor !== bCtor &amp;&amp; !(_.isFunction(aCtor) &amp;&amp; (aCtor <span class="keyword">instanceof</span> aCtor) &amp;&amp;
                               _.isFunction(bCtor) &amp;&amp; (bCtor <span class="keyword">instanceof</span> bCtor))) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      <span class="comment">// Deep compare objects.</span>
      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a) {
        <span class="keyword">if</span> (_.has(a, key)) {
          <span class="comment">// Count the expected number of properties.</span>
          size++;
          <span class="comment">// Deep compare each member.</span>
          <span class="keyword">if</span> (!(result = _.has(b, key) &amp;&amp; eq(a[key], b[key], aStack, bStack))) <span class="keyword">break</span>;
        }
      }
      <span class="comment">// Ensure that both objects contain the same number of properties.</span>
      <span class="keyword">if</span> (result) {
        <span class="keyword">for</span> (key <span class="keyword">in</span> b) {
          <span class="keyword">if</span> (_.has(b, key) &amp;&amp; !(size--)) <span class="keyword">break</span>;
        }
        result = !size;
      }
    }
    <span class="comment">// Remove the first object from the stack of traversed objects.</span>
    aStack.pop();
    bStack.pop();
    <span class="keyword">return</span> result;
  };

  <span class="comment">// Perform a deep comparison to check if two objects are equal.</span>
  _.isEqual = <span class="keyword">function</span>(a, b) {
    <span class="keyword">return</span> eq(a, b, [], []);
  };

  <span class="comment">// Is a given array, string, or object empty?</span>
  <span class="comment">// An "empty" object has no enumerable own-properties.</span>
  _.isEmpty = <span class="keyword">function</span>(obj) {
    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;
    <span class="keyword">if</span> (_.isArray(obj) || _.isString(obj)) <span class="keyword">return</span> obj.length === <span class="number">0</span>;
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) <span class="keyword">if</span> (_.has(obj, key)) <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">return</span> <span class="literal">true</span>;
  };

  <span class="comment">// Is a given value a DOM element?</span>
  _.isElement = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> !!(obj &amp;&amp; obj.nodeType === <span class="number">1</span>);
  };

  <span class="comment">// Is a given value an array?</span>
  <span class="comment">// Delegates to ECMA5's native Array.isArray</span>
  _.isArray = nativeIsArray || <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object Array]'</span>;
  };

  <span class="comment">// Is a given variable an object?</span>
  _.isObject = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> obj === Object(obj);
  };

  <span class="comment">// Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.</span>
  each([<span class="string">'Arguments'</span>, <span class="string">'Function'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>], <span class="keyword">function</span>(name) {
    _[<span class="string">'is'</span> + name] = <span class="keyword">function</span>(obj) {
      <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + name + <span class="string">']'</span>;
    };
  });

  <span class="comment">// Define a fallback version of the method in browsers (ahem, IE), where</span>
  <span class="comment">// there isn't any inspectable "Arguments" type.</span>
  <span class="keyword">if</span> (!_.isArguments(arguments)) {
    _.isArguments = <span class="keyword">function</span>(obj) {
      <span class="keyword">return</span> !!(obj &amp;&amp; _.has(obj, <span class="string">'callee'</span>));
    };
  }

  <span class="comment">// Optimize `isFunction` if appropriate.</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> (<span class="regexp">/./</span>) !== <span class="string">'function'</span>) {
    _.isFunction = <span class="keyword">function</span>(obj) {
      <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'function'</span>;
    };
  }

  <span class="comment">// Is a given object a finite number?</span>
  _.isFinite = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> isFinite(obj) &amp;&amp; !isNaN(parseFloat(obj));
  };

  <span class="comment">// Is the given value `NaN`? (NaN is the only number which does not equal itself).</span>
  _.isNaN = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> _.isNumber(obj) &amp;&amp; obj != +obj;
  };

  <span class="comment">// Is a given value a boolean?</span>
  _.isBoolean = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> obj === <span class="literal">true</span> || obj === <span class="literal">false</span> || toString.call(obj) == <span class="string">'[object Boolean]'</span>;
  };

  <span class="comment">// Is a given value equal to null?</span>
  _.isNull = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> obj === <span class="literal">null</span>;
  };

  <span class="comment">// Is a given variable undefined?</span>
  _.isUndefined = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> obj === <span class="keyword">void</span> <span class="number">0</span>;
  };

  <span class="comment">// Shortcut function for checking if an object has a given property directly</span>
  <span class="comment">// on itself (in other words, not on a prototype).</span>
  _.has = <span class="keyword">function</span>(obj, key) {
    <span class="keyword">return</span> hasOwnProperty.call(obj, key);
  };

  <span class="comment">// Utility Functions</span>
  <span class="comment">// -----------------</span>

  <span class="comment">// Run Underscore.js in *noConflict* mode, returning the `_` variable to its</span>
  <span class="comment">// previous owner. Returns a reference to the Underscore object.</span>
  _.noConflict = <span class="keyword">function</span>() {
    root._ = previousUnderscore;
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };

  <span class="comment">// Keep the identity function around for default iterators.</span>
  _.identity = <span class="keyword">function</span>(value) {
    <span class="keyword">return</span> value;
  };

  <span class="comment">// Run a function **n** times.</span>
  _.times = <span class="keyword">function</span>(n, iterator, context) {
    <span class="keyword">var</span> accum = Array(n);
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) accum[i] = iterator.call(context, i);
    <span class="keyword">return</span> accum;
  };

  <span class="comment">// Return a random integer between min and max (inclusive).</span>
  _.random = <span class="keyword">function</span>(min, max) {
    <span class="keyword">if</span> (max == <span class="literal">null</span>) {
      max = min;
      min = <span class="number">0</span>;
    }
    <span class="keyword">return</span> min + (<span class="number">0</span> | Math.random() * (max - min + <span class="number">1</span>));
  };

  <span class="comment">// List of HTML entities for escaping.</span>
  <span class="keyword">var</span> entityMap = {
    escape: {
      <span class="string">'&amp;'</span>: <span class="string">'&amp;amp;'</span>,
      <span class="string">'&lt;'</span>: <span class="string">'&amp;lt;'</span>,
      <span class="string">'>'</span>: <span class="string">'&amp;gt;'</span>,
      <span class="string">'"'</span>: <span class="string">'&amp;quot;'</span>,
      <span class="string">"'"</span>: <span class="string">'&amp;#x27;'</span>,
      <span class="string">'/'</span>: <span class="string">'&amp;#x2F;'</span>
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  <span class="comment">// Regexes containing the keys and values listed immediately above.</span>
  <span class="keyword">var</span> entityRegexes = {
    escape:   <span class="keyword">new</span> RegExp(<span class="string">'['</span> + _.keys(entityMap.escape).join(<span class="string">''</span>) + <span class="string">']'</span>, <span class="string">'g'</span>),
    unescape: <span class="keyword">new</span> RegExp(<span class="string">'('</span> + _.keys(entityMap.unescape).join(<span class="string">'|'</span>) + <span class="string">')'</span>, <span class="string">'g'</span>)
  };

  <span class="comment">// Functions for escaping and unescaping strings to/from HTML interpolation.</span>
  _.each([<span class="string">'escape'</span>, <span class="string">'unescape'</span>], <span class="keyword">function</span>(method) {
    _[method] = <span class="keyword">function</span>(string) {
      <span class="keyword">if</span> (string == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">''</span>;
      <span class="keyword">return</span> (<span class="string">''</span> + string).replace(entityRegexes[method], <span class="keyword">function</span>(match) {
        <span class="keyword">return</span> entityMap[method][match];
      });
    };
  });

  <span class="comment">// If the value of the named property is a function then invoke it;</span>
  <span class="comment">// otherwise, return it.</span>
  _.result = <span class="keyword">function</span>(object, property) {
    <span class="keyword">if</span> (object == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;
    <span class="keyword">var</span> value = object[property];
    <span class="keyword">return</span> _.isFunction(value) ? value.call(object) : value;
  };

  <span class="comment">// Add your own custom functions to the Underscore object.</span>
  _.mixin = <span class="keyword">function</span>(obj) {
    each(_.functions(obj), <span class="keyword">function</span>(name){
      <span class="keyword">var</span> func = _[name] = obj[name];
      _.prototype[name] = <span class="keyword">function</span>() {
        <span class="keyword">var</span> args = [<span class="keyword">this</span>._wrapped];
        push.apply(args, arguments);
        <span class="keyword">return</span> result.call(<span class="keyword">this</span>, func.apply(_, args));
      };
    });
  };

  <span class="comment">// Generate a unique integer id (unique within the entire client session).</span>
  <span class="comment">// Useful for temporary DOM ids.</span>
  <span class="keyword">var</span> idCounter = <span class="number">0</span>;
  _.uniqueId = <span class="keyword">function</span>(prefix) {
    <span class="keyword">var</span> id = <span class="string">''</span> + ++idCounter;
    <span class="keyword">return</span> prefix ? prefix + id : id;
  };

  <span class="comment">// By default, Underscore uses ERB-style template delimiters, change the</span>
  <span class="comment">// following template settings to use alternative delimiters.</span>
  _.templateSettings = {
    evaluate    : <span class="regexp">/&lt;%([\s\S]+?)%>/g</span>,
    interpolate : <span class="regexp">/&lt;%=([\s\S]+?)%>/g</span>,
    escape      : <span class="regexp">/&lt;%-([\s\S]+?)%>/g</span>
  };

  <span class="comment">// When customizing `templateSettings`, if you don't want to define an</span>
  <span class="comment">// interpolation, evaluation or escaping regex, we need one that is</span>
  <span class="comment">// guaranteed not to match.</span>
  <span class="keyword">var</span> noMatch = <span class="regexp">/(.)^/</span>;

  <span class="comment">// Certain characters need to be escaped so that they can be put into a</span>
  <span class="comment">// string literal.</span>
  <span class="keyword">var</span> escapes = {
    <span class="string">"'"</span>:      <span class="string">"'"</span>,
    <span class="string">'\\'</span>:     <span class="string">'\\'</span>,
    <span class="string">'\r'</span>:     <span class="string">'r'</span>,
    <span class="string">'\n'</span>:     <span class="string">'n'</span>,
    <span class="string">'\t'</span>:     <span class="string">'t'</span>,
    <span class="string">'\u2028'</span>: <span class="string">'u2028'</span>,
    <span class="string">'\u2029'</span>: <span class="string">'u2029'</span>
  };

  <span class="keyword">var</span> escaper = <span class="regexp">/\\|'|\r|\n|\t|\u2028|\u2029/g</span>;

  <span class="comment">// JavaScript micro-templating, similar to John Resig's implementation.</span>
  <span class="comment">// Underscore templating handles arbitrary delimiters, preserves whitespace,</span>
  <span class="comment">// and correctly escapes quotes within interpolated code.</span>
  _.template = <span class="keyword">function</span>(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    <span class="comment">// Combine delimiters into one regular expression via alternation.</span>
    <span class="keyword">var</span> matcher = <span class="keyword">new</span> RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join(<span class="string">'|'</span>) + <span class="string">'|$'</span>, <span class="string">'g'</span>);

    <span class="comment">// Compile the template source, escaping string literals appropriately.</span>
    <span class="keyword">var</span> index = <span class="number">0</span>;
    <span class="keyword">var</span> source = <span class="string">"__p+='"</span>;
    text.replace(matcher, <span class="keyword">function</span>(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, <span class="keyword">function</span>(match) { <span class="keyword">return</span> <span class="string">'\\'</span> + escapes[match]; });

      <span class="keyword">if</span> (escape) {
        source += <span class="string">"'+\n((__t=("</span> + escape + <span class="string">"))==null?'':_.escape(__t))+\n'"</span>;
      }
      <span class="keyword">if</span> (interpolate) {
        source += <span class="string">"'+\n((__t=("</span> + interpolate + <span class="string">"))==null?'':__t)+\n'"</span>;
      }
      <span class="keyword">if</span> (evaluate) {
        source += <span class="string">"';\n"</span> + evaluate + <span class="string">"\n__p+='"</span>;
      }
      index = offset + match.length;
      <span class="keyword">return</span> match;
    });
    source += <span class="string">"';\n"</span>;

    <span class="comment">// If a variable is not specified, place data values in local scope.</span>
    <span class="keyword">if</span> (!settings.variable) source = <span class="string">'with(obj||{}){\n'</span> + source + <span class="string">'}\n'</span>;

    source = <span class="string">"var __t,__p='',__j=Array.prototype.join,"</span> +
      <span class="string">"print=function(){__p+=__j.call(arguments,'');};\n"</span> +
      source + <span class="string">"return __p;\n"</span>;

    <span class="keyword">try</span> {
      <span class="keyword">var</span> render = <span class="keyword">new</span> Function(settings.variable || <span class="string">'obj'</span>, <span class="string">'_'</span>, source);
    } <span class="keyword">catch</span> (e) {
      e.source = source;
      <span class="keyword">throw</span> e;
    }

    <span class="keyword">if</span> (data) <span class="keyword">return</span> render(data, _);
    <span class="keyword">var</span> template = <span class="keyword">function</span>(data) {
      <span class="keyword">return</span> render.call(<span class="keyword">this</span>, data, _);
    };

    <span class="comment">// Provide the compiled function source as a convenience for precompilation.</span>
    template.source = <span class="string">'function('</span> + (settings.variable || <span class="string">'obj'</span>) + <span class="string">'){\n'</span> + source + <span class="string">'}'</span>;

    <span class="keyword">return</span> template;
  };

  <span class="comment">// Add a "chain" function, which will delegate to the wrapper.</span>
  _.chain = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> _(obj).chain();
  };

  <span class="comment">// OOP</span>
  <span class="comment">// ---------------</span>
  <span class="comment">// If Underscore is called as a function, it returns a wrapped object that</span>
  <span class="comment">// can be used OO-style. This wrapper holds altered versions of all the</span>
  <span class="comment">// underscore functions. Wrapped objects may be chained.</span>

  <span class="comment">// Helper function to continue chaining intermediate results.</span>
  <span class="keyword">var</span> result = <span class="keyword">function</span>(obj) {
    <span class="keyword">return</span> <span class="keyword">this</span>._chain ? _(obj).chain() : obj;
  };

  <span class="comment">// Add all of the Underscore functions to the wrapper object.</span>
  _.mixin(_);

  <span class="comment">// Add all mutator Array functions to the wrapper.</span>
  each([<span class="string">'pop'</span>, <span class="string">'push'</span>, <span class="string">'reverse'</span>, <span class="string">'shift'</span>, <span class="string">'sort'</span>, <span class="string">'splice'</span>, <span class="string">'unshift'</span>], <span class="keyword">function</span>(name) {
    <span class="keyword">var</span> method = ArrayProto[name];
    _.prototype[name] = <span class="keyword">function</span>() {
      <span class="keyword">var</span> obj = <span class="keyword">this</span>._wrapped;
      method.apply(obj, arguments);
      <span class="keyword">if</span> ((name == <span class="string">'shift'</span> || name == <span class="string">'splice'</span>) &amp;&amp; obj.length === <span class="number">0</span>) <span class="keyword">delete</span> obj[<span class="number">0</span>];
      <span class="keyword">return</span> result.call(<span class="keyword">this</span>, obj);
    };
  });

  <span class="comment">// Add all accessor Array functions to the wrapper.</span>
  each([<span class="string">'concat'</span>, <span class="string">'join'</span>, <span class="string">'slice'</span>], <span class="keyword">function</span>(name) {
    <span class="keyword">var</span> method = ArrayProto[name];
    _.prototype[name] = <span class="keyword">function</span>() {
      <span class="keyword">return</span> result.call(<span class="keyword">this</span>, method.apply(<span class="keyword">this</span>._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    <span class="comment">// Start chaining a wrapped Underscore object.</span>
    chain: <span class="keyword">function</span>() {
      <span class="keyword">this</span>._chain = <span class="literal">true</span>;
      <span class="keyword">return</span> <span class="keyword">this</span>;
    },

    <span class="comment">// Extracts the result from a wrapped and chained object.</span>
    value: <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>._wrapped;
    }

  });

}).call(<span class="keyword">this</span>);
</code></pre>